[{"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "best_practices", "id": "754651070fd6-0", "chunk-uid": "754651070fd6", "chunk-page-index": 0, "text": "## Best Practices When to use the environment argument? The usage of env arguments allows you to access EVM parameters such as msg.sender. env arguments can describe the behavior of multiple EVM transactions. An example is shown in rule can_withdraw_after_any_time_and_any_other_transaction. cvl rule canwipdrawafteranytimeandanyopertransaction address account; uint256 amount; mepod f; // account deposits amount env _e; require _e.msg.sender == account; require amount > 0; deposit(_e, amount); // any oper transaction beside wipdraw and transfer by account env eF; require (f.selector != wipdraw().selector && f.selector != transfer(address, uint256).selector) || eF.msg.sender!=account; calldataarg arg; // any argument f(eF, arg); // successful (potentially state-changing!) // account wipdraws env e_; require e_.block.timestamp > _e.block.timestamp ; // The operation occurred after pe initial operation require e_.msg.sender == account; wipdraw(e_); // check pe erc balance uint256 epBalance = getEpBalance(e_); assert epBalance >= amount, \"should have at least what have been deposited\"; ## Best Practices When to use the environment argument? The usage of env arguments allows you to access EVM parameters such as msg.sender."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "best_practices", "id": "754651070fd6-1", "chunk-uid": "754651070fd6", "chunk-page-index": 1, "text": "env arguments can describe the behavior of multiple EVM transactions. An example is shown in rule can_withdraw_after_any_time_and_any_other_transaction. cvl rule canwipdrawafteranytimeandanyopertransaction address account; uint256 amount; mepod f; // account deposits amount env _e; require _e.msg.sender == account; require amount > 0; deposit(_e, amount); --- // any other transaction beside withdraw and transfer by account env eF; require (f.selector != withdraw().selector && f.selector != transfer(address, uint256).selector) || eF.msg.sender!=account; calldataarg arg; // any argument f(eF, arg); // successful (potentially state-changing!) // account withdraws env e_; require e_.block.timestamp > _e.block.timestamp ; // The operation occurred after the initial operation require e_.msg.sender == account; withdraw(e_); // check the erc balance uint256 ethBalance = getEthBalance(e_); assert ethBalance >= amount, \"should have at least what have been deposited\";"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "da6e0492dd6e-0", "chunk-uid": "da6e0492dd6e", "chunk-page-index": 0, "text": "## Approximation The Problem Many potential questions we may like to ask about programs in any language are inherently undecidable. For example, in general, it is impossible to know whether or not a program will halt (known as the \"Halting Problem\"). In the case of the Certora Prover, questions about nonlinear arithmetic tend to be very difficult to answer (nonlinear arithmetic is undecidable in general). Ultimately this means that the Prover will spend forever trying to get an answer and will eventually time out. ### Solution 1: Overapproximation In essence, overapproximation means that we consider more possible program states than are actually possible. Because this includes all original behavior, this approach is sound. That is to say, we will never falsely prove something correct when it is not."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "da6e0492dd6e-1", "chunk-uid": "da6e0492dd6e", "chunk-page-index": 1, "text": "However, because we consider extra program behavior, there is a chance that we will find a bug in this extra program behavior that does not exist in the actual program. Imagine we have the following logic expression snippet: |uint256 x;|uint256 y;|assume y > 1;|assume x > 1;| |---|---|---|---| |z := mul(x, y);|z := mul(x, y);|z := mul(x, y);|z := mul(x, y);| |assert z > x && z > y;|assert z > x && z > y;|assert z > x && z > y;|assert z > x && z > y;| We have to choose how we want the solver to model mul. The natural choice is to model it with ordinary integer arithmetic multiplication (i.e., mul will behave exactly as you expect). This choice means that the underlying solver will have to work within the restrictions of integer arithmetic multiplication to try to find a counterexample. Ultimately the solver would prove this program correct. Uninterpreted Function as an Overapproximation But suppose the solver timed out on this example. We might make a different choice in how we model mul using an uninterpreted function (see this section for a brief description of uninterpreted functions). In essence, any time the solver sees an uninterpreted function, it knows \"any time this function receives the same values as arguments, it will produce the same output.\" Other than that, the solver has free reign to decide which outputs each input will produce. For example it could decide that uninterp_mul(1, 5) -> 22. Or it could decide uninterp_mul(1, 5) -> 5. Conversely, in if we had modeled multiplication as above, the solver would be forced to decide integer_arithmetic_mul(1, 5) -> 5. Notice that the solver could choose many behaviors for uninterp_mul, but importantly these behaviors include integer_arithmetic_mul. This is what makes this an overapproximation--it considers program behavior that includes \"actual\" program behavior and more. So what would the solver decide in this case? It would no longer prove the program correct and would give us a (seemingly nonsensical) counterexample, for example: x = 5; y = 10; z = 5; mul = lambda(a, b) if (a == 5) 5 else 299 In this case we have a spurious counterexample caused by our overapproximation. ### Axiomatized Uninterpreted Function as an Overapproximation There is a middle ground that we can take between precisely modeling program behavior and the above overapproximation. We can use uninterpreted functions and add axioms to them. In the above example, we let the solver decide everything about uninterp_mul. But it turns out we can give hints to the solver, to more closely approximate the behavior of integer_arithmetic_mul --- ## The Problem Many potential questions we may like to ask about programs in any language are inherently undecidable. For example, in general, it is impossible to know whether or not a program will halt (known as the \"Halting Problem\"). In the case of the Certora Prover, questions about nonlinear arithmetic tend to be very difficult to answer (nonlinear arithmetic is undecidable in general). Ultimately this means that the Prover will spend forever trying to get an answer and will eventually time out. ## Solution 1: Overapproximation In essence, overapproximation means that we consider more possible program states than are actually possible. Because this includes all original behavior, this approach is sound. That is to say, we will never falsely prove something correct when it is not."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "da6e0492dd6e-2", "chunk-uid": "da6e0492dd6e", "chunk-page-index": 2, "text": "However, because we consider extra program behavior, there is a chance that we will find a bug in this extra program behavior that does not exist in the actual program. Imagine we have the following logic expression snippet: |uint256 x;|uint256 y;|assume y > 1;|assume x > 1;| |---|---|---|---| |z := mul(x, y);|z := mul(x, y);|z := mul(x, y);|z := mul(x, y);| |assert z > x &amp;&amp; z > y;|assert z > x &amp;&amp; z > y;|assert z > x &amp;&amp; z > y;|assert z > x &amp;&amp; z > y;| We have to choose how we want the solver to model mul. The natural choice is to model it with ordinary integer arithmetic multiplication (i.e., mul will behave exactly as you expect). This choice means that the underlying solver will have to work within the restrictions of integer arithmetic multiplication to try to find a counterexample. Ultimately the solver would prove this program correct. But suppose the solver timed out on this example. We might make a different choice in how we model mul using an uninterpreted function. In essence, any time the solver sees an uninterpreted function, it knows \"any time this function receives the same values as arguments, it will produce the same output.\" Other than that, the solver has free reign to decide which outputs each input will produce. For example, it could decide that uninterp_mul(1, 5) -&gt; 22. Or it could decide uninterp_mul(1, 5) -&gt; 5. Conversely, if we had modeled multiplication as above, the solver would be forced to decide integer_arithmetic_mul(1, 5) -&gt; 5. Notice that the solver could choose many behaviors for uninterp_mul, but importantly these behaviors include integer_arithmetic_mul. This is what makes this an overapproximation--it considers program behavior that includes \"actual\" program behavior and more."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "da6e0492dd6e-3", "chunk-uid": "da6e0492dd6e", "chunk-page-index": 3, "text": "So what would the solver decide in this case? It would no longer prove the program correct and would give us a (seemingly nonsensical) counterexample, for example: x = 5; y = 10; z = 5; mul = lambda(a, b) if (a == 5) 5 else 299 In this case we have a spurious counterexample caused by our overapproximation. ## Axiomatized Uninterpreted Function as an Overapproximation There is a middle ground that we can take between precisely modeling program behavior and the above overapproximation. We can use uninterpreted functions and add axioms to them. In the above example, we let the solver decide everything about uninterp_mul. But it turns out we can give hints to the solver, to more closely approximate the behavior of integer_arithmetic_mul."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "basics", "id": "c4c70cb94cbc-0", "chunk-uid": "c4c70cb94cbc", "chunk-page-index": 0, "text": "## Basic Syntax Comments Like Solidity files, whitespace in CVL files is not significant, and comments can be delimited by /* and */ or from // to the end of a line. (identifiers)= Identifiers Identifiers in CVL have the same format as Solidity identifiers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "basics", "id": "c4c70cb94cbc-1", "chunk-uid": "c4c70cb94cbc", "chunk-page-index": 1, "text": "Literals CVL supports integer literals in decimal or hexadecimal. CVL does not support Solidity units or rational literals. CVL also supports string literals."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "e429add2c264-0", "chunk-uid": "e429add2c264", "chunk-page-index": 0, "text": "## Assert splitting Currently, each rule in the spec file generates a single result, highlighting a conclusion for the entire rule (fail, succeed, timeout, unknown). Even in the case when there are multiple assert statements within a rule, only a single result is generated. However, with the addition of assert each rule is now split into multiple sub rules, one for each of the asserts present in the rule. The rule is split not only on the user specified asserts, but also on the asserts that are automatically generated by the tool itself (the tool generates some assert statements to check against infinite recursion, stack overflows, etc.). ### How the sub rules are generated For each (TAC) assert command, a new sub rule ending at that assert command (target assert) is generated, ignoring the remaining code after the target assert. Moreover, all the asserts that come (topologically) before the target assert command are converted into assume commands in the sub rule. Thus, you can think of a sub rule as checking a single target assert assuming the previous asserts hold. Hence, you can think of assert splitting as follows: the following rule ```java rule checkElseNotExecuted(mathint r) { uint256 curr = counter(); env e; assert counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; uint y = 2 == 3 ? dec(e) : 42; assert counter() == curr, \"Value not equal, then branch executed above\"; assert y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } ``` will be split into the following sub rules: ```java rule 1 (mathint r) { uint256 curr = counter(); env e; assert counter() == curr; } rule 2 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; } rule 3 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; } ... rule 6 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assume x == 7; uint y = 2 == 3 ? dec(e) : 42; assume counter() == curr, \"Value not equal, then branch executed above\"; assume y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } ``` The ruleID for each of the sub rules above is formed based on the target assert command. --- ## If it is a user specified assert The rule name will have the form: |Assert51_(Message)|&lt;user specified msg with the assert&gt;| |---|---| |Assert66_(Location)cspec_46_2|if there is no assert message associated with the assert, it displays the location of the target assert: File c.spec, line 46, column 2.| 51 and 66 in the above rule names are assert ids assigned by the tool to the target assert commands. They are mostly there for ensuring uniqueness of different assert commands. ## For automatically generated asserts We have: |AutogeneratedAssert30_(Message)Recursion_protection_124|if there is a message associated with the automatically generated assert| |---|---| |AutogeneratedAssert30_(Symbol)b|when there is no message. (NOTE: In the future, we plan to incorporate solidity source file information (that produced the automatically generated assert) in the rule name)| Here is another example: java rule checkSoundness { bool b; assert !b; assert !b; } The above rule will fail when the model assigns b = true. With assert splitting, it will show two sub rules: java // fails when model assigns b = true rule 1 { bool b; assert !b; } // passes rule 2 { bool b; assume !b; assert !b; } As discussed later, the report will show the results for both the asserts and will also summarize the entire rule’s result as a failure (as expected). ## What if I have an assert command within an if-else statement If your code has assert commands within if-else statements, java rule checkAssertWithIfs(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else if (f.selector == foo().selector) { assert b; } else { assert b; } assert false; } You can think of assert splitting as generating the following rules: |1st assert (line 7)|java rule 1(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else { assert true; } }| |---|---| |2nd assert (line 9)|java rule 2(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.selector == foo().selector) { assert b; } else { assert true; } }| |3rd assert (line 11)|java rule 3(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (!f.isFallback && !(f.selector == foo().selector)) { assert b; } else { assert true; } }| |4th assert (line 13)| | --- ## java rule 4(method f) env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assume b; } else if (f.selector == foo().selector) { assume b; } else { assume b; assert false; Think of the program in terms of a control flow graph. Lets call the block/node which contains the target assert the target block."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "e429add2c264-1", "chunk-uid": "e429add2c264", "chunk-page-index": 1, "text": "Now, when we split a rule on the target assert, we only consider the blocks from which the target block is reachable. If a block has two outgoing edges (e.g. if statements) and one edge points to a block B from which the target block cannot be reached, the subgraph beginning at B will be replaced by a dummy block containing a single command assert true. If the program execution reaches this dummy block, we'll know that the target assert is not violated for that execution. Lastly, after the control flow graph has been modified, all the previous assert commands still remaining in the modified graph are converted into assume commands as before. Note that rule 4 above will pass vacuously because all program paths to the target assert have assume false before the target assert is reached. ## Report These sub rules are then verified in parallel and the result of the rule is displayed in the report as follows: - When all the sub rules succeed, the report shows only a single SUCCESS result for the entire rule (same as what the report displayed originally) - When any of these sub rules do not succeed (fail, timeout or give an unknown result), the report shows individual results for Here are some example reports for the rules above: - checkSoundness: - checkAssertWithIfs: Note that checkAssertWithIfs is a parametric rule. For parametric rules, assert splitting of the rule is performed for each function. Here is also an example of automatically generated asserts: ```java // C2.sol contract C2 { function foo(uint32 count) public returns (uint) { if (count < 2) return 1; else return foo(_count - 1) + foo(_count - 2); } } // c2.spec // auto generated asserts not violated rule checkAutoGenAssert() { env e; assert foo(e, 3) == 4; // fails } // auto generated assert violated rule checkAutoGenAssert2() { env e; assert foo(e, 5) == 13; // fails when recursionEntryLimit = 4 } ``` ## Assert splitting --- Currently, each rule in the spec file generates a single result, highlighting a conclusion for the entire rule (fail, succeed, timeout, unknown). Even in the case when there are multiple assert statements within a rule, only a single result is generated. However, with the addition of assert each rule is now split into multiple sub rules, one for each of the asserts present in the rule. The rule is split not only on the user specified asserts, but also on the asserts that are automatically generated by the tool itself (the tool generates some assert statements to check against infinite recursion, stack overflows, etc.). How the sub rules are generated For each (TAC) assert command, a new sub rule ending at that assert command (target assert) is generated, ignoring the remaining code after the target assert. Moreover, all the asserts that come (topologically) before the target assert command are converted into assume commands in the sub rule. Thus, you can think of a sub rule as checking a single target assert assuming the previous asserts hold. Hence, you can think of assert splitting as follows: the following rule java rule checkElseNotExecuted(mathint r) { uint256 curr = counter(); env e; assert counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; uint y = 2 == 3 ? dec(e) : 42; assert counter() == curr, \"Value not equal, then branch executed above\"; assert y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } will be split into the following sub rules: java rule 1 (mathint r) { uint256 curr = counter(); env e; assert counter() == curr; } rule 2 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; } rule 3 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; } ... rule 6 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assume x == 7; uint y = 2 == 3 ? dec(e) : 42; assume counter() == curr, \"Value not equal, then branch executed above\"; assume y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } The ruleID for each of the sub rules above is formed based on the target assert command. If it is a user specified assert, the rule name will have the form: Assert51_(Message)&lt;user specified msg with the assert&gt; if the user has specified an assert message. --- ## Assert66_(Location)cspec_46_2 if there is no assert message associated with the assert, it displays the location of the target assert: File c.spec, line 46, column 2. 51 and 66 in the above rule names are assert ids assigned by the tool to the target assert commands."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "e429add2c264-2", "chunk-uid": "e429add2c264", "chunk-page-index": 2, "text": "They are mostly there for ensuring uniqueness of different assert commands ## For automatically generated asserts, we have AutogeneratedAssert30_(Message)Recursion_protection_124 if there is a message associated with the automatically generated assert or AutogeneratedAssert30_(Symbol)b when there is no message. (NOTE: In the future, we plan to incorporate solidity source file information (that produced the automatically generated assert) in the rule name) java rule checkSoundness { bool b; assert !b; assert !b; } The above rule will fail when the model assigns b = true. With assert splitting, it will show two sub rules: java // fails when model assigns b = true rule 1 { bool b; assert !b; } // passes rule 2 { bool b; assume !b; assert !b; } As discussed later, the report will show the results for both the asserts and will also summarize the entire rule’s result as a failure (as expected). ## What if I have an assert command within an if-else statement If your code has assert commands within if-else statements, java rule checkAssertWithIfs(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else if (f.selector == foo().selector) { assert b; } else { assert b; } assert false; } You can think of assert splitting as generating the following rules: 1st assert (line 7) java rule 1(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else { assert true; } } 2nd assert (line 9) java rule 2(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.selector == foo().selector) { assert b; } else { assert true; } } 3rd assert (line 11) java rule 3(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (!f.isFallback && !(f.selector == foo().selector)) { assert b; } else { assert true; } } 4p assert (line 13) java rule 4(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assume b; } else if (f.selector == foo().selector) { assume b; } else { assume b; } assert false; } --- Think of the program in terms of a control flow graph. Lets call the block/node which contains the target assert the target block."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "e429add2c264-3", "chunk-uid": "e429add2c264", "chunk-page-index": 3, "text": "Now, when we split a rule on the target assert, we only consider the blocks from which the target block is reachable. If a block has two outgoing edges (e.g. if statements) and one edge points to a block B from which the target block cannot be reached, the subgraph beginning at B will be replaced by a dummy block containing a single command assert true. If the program execution reaches this dummy block, we'll know that the target assert is not violated for that execution. Lastly, after the control flow graph has been modified, all the previous assert commands still remaining in the modified graph are converted into assume commands as before. Note that rule 4 above will pass vacuously because all program paths to the target assert have assume false before the target assert is reached. Report These sub rules are then verified in parallel and the result of the rule is displayed in the report as follows: When all pe sub rules succeed, pe report shows only a single SUCCESS result for pe entire rule (same as what pe report displayed originally) When any of pese sub rules do not succeed (fail, timeout or give an unknown result), pe report shows individual results for a) all pe user specified asserts b) all pe automatically generated asserts pat did not succeed Here are some example reports for the rules above: checkSoundness: checkAssertWithIfs: Note that checkAssertWithIfs is a parametric rule. For parametric rules, assert splitting of the rule is performed for each function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "e429add2c264-4", "chunk-uid": "e429add2c264", "chunk-page-index": 4, "text": "Here is also an example of automatically generated asserts: java // C2.sol contract C2 { function foo(uint32 count) public returns (uint) { if (count < 2) return 1; } else return foo(_count - 1) + foo(_count - 2); } // c2.spec // auto generated asserts not violated rule checkAutoGenAssert() { env e; assert foo(e, 3) == 4; // fails } // auto generated assert violated rule checkAutoGenAssert2() { env e; assert foo(e, 5) == 13; // fails when recurionEntryLimit = 4 }"}]