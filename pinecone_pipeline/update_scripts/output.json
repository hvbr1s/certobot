[{"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "checking", "id": "5fc97924967a-0", "chunk-uid": "5fc97924967a", "chunk-page-index": 0, "text": "## Checking Specifications Effective formal verification relies on accurate specifications. A flaw in the specification could lead to critical bugs slipping through undetected. Certora offers a set of tools to enhance the accuracy of specifications and identify potential issues. This chapter outlines these tools and demonstrates their application."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "checking", "id": "5fc97924967a-1", "chunk-uid": "5fc97924967a", "chunk-page-index": 1, "text": "### Detecting Vacuous Specifications A vacuous statement is one that is technically true but lacks meaningful content. Consider the following example: |Contract:|solidity function balanceOf(address account, uint256 id) public view override returns (uint256) { require(account != address(0), \"account is zero\"); return _balances[id][account]; }| |---|---| |Specification:|cvl rule heldtokenshould_exist{ address user; uint256 token; require balanceOf(0, token) == 0; require balanceOf(user, token) <= totalSupplyOf(token); assert balanceOf(user, token) > 0 => token_exists(token);}| The specification contains a flaw; the statement balanceOf(0, token) == 0; will always revert due to the require in the contract, resulting in an empty starting state. To address such issues, Certora allows to run Vacuity checks. These checks append assert false to each rule, exposing vacuously proven assumptions. This ensures that every rule in the specification has at least one input that reaches all the assertions. It is a useful check, but nevertheless, it is not a good measure for coverage. for more information on coverage measure checkout mutation testing. Note: Vacuity in real-world examples often arises from combinations of requirements, not just isolated statements. ### Identifying Tautology Specifications Tautology, a special case of vacuity known as the \"vacuous assertion,\" occurs when a statement is always true regardless of the system's state. An example is provided below: cvl rule somethingisalwaystransferred{ address receiver; uint256 balancebefore_transfer = balanceOf(receiver); require balanceOf(receiver) == 0; uint256 amount; require amount > 0; transfer(receiver, amount); uint256 balance_after_transfer = balanceOf(receiver); assert balanceOf(receiver) <= balance_after_transfer;} In this case, the assert statement is always true since it compares equal values, neglecting any meaningful checks related to the transfer behavior. Certora allows to run Assert tautology checks to address such instances. By removing preconditions and operations, these checks focus solely on the assert statement, revealing whether it is always true regardless of the process being examined. ### Conclusion For more comprehensive examples and solutions, please refer to our documentation. Certora's suite of verification tools empowers developers to enhance the precision of their specifications, ensuring robust and reliable smart contract development. --- ## Checking Specifications Effective formal verification relies on accurate specifications. A flaw in the specification could lead to critical bugs slipping through undetected. Certora offers a set of tools to enhance the accuracy of specifications and identify potential issues. This chapter outlines these tools and demonstrates their application."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "checking", "id": "5fc97924967a-2", "chunk-uid": "5fc97924967a", "chunk-page-index": 2, "text": "### Detecting Vacuous Specifications A vacuous statement is one that is technically true but lacks meaningful content. Consider the following example: |Contract:|solidity function balanceOf(address account, uint256 id) public view override returns (uint256) { require(account != address(0), \"account is zero\"); return _balances[id][account]; }| |---|---| |Specification:|cvl rule heldtokenshould_exist{ address user; uint256 token; require balanceOf(0, token) == 0; require balanceOf(user, token) <= totalSupplyOf(token); assert balanceOf(user, token) > 0 => token_exists(token);}| The specification contains a flaw; the statement balanceOf(0, token) == 0; will always revert due to the require in the contract, resulting in an empty starting state. To address such issues, Certora allows to run Vacuity checks. These checks append assert false to each rule, exposing vacuously proven assumptions. This ensures that every rule in the specification has at least one input that reaches all the assertions. It is a useful check, but nevertheless, it is not a good measure for coverage. For more information on coverage measure checkout mutation testing. Note: Vacuity in real-world examples often arises from combinations of requirements, not just isolated statements. ### Identifying Tautology Specifications Tautology, a special case of vacuity known as the \"vacuous assertion,\" occurs when a statement is always true regardless of the system's state. An example is provided below: Specification: cvl rule somethingisalwaystransferred{ address receiver; uint256 balancebefore_transfer = balanceOf(receiver); require balanceOf(receiver) == 0; uint256 amount; require amount > 0; transfer(receiver, amount); uint256 balance_after_transfer = balanceOf(receiver); assert balanceOf(receiver) <= balance_after_transfer;} In this case, the assert statement is always true since it compares equal values, neglecting any meaningful checks related to the transfer behavior. Certora allows to run Assert tautology checks to address such instances. By removing preconditions and operations, these checks focus solely on the assert statement, revealing whether it is always true regardless of the process being examined. ### Conclusion For more comprehensive examples and solutions, please refer to our documentation. Certora's suite of verification tools empowers developers to enhance the precision of their specifications, ensuring robust and reliable smart contract development."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-0", "chunk-uid": "25f4f4007c44", "chunk-page-index": 0, "text": "## Glossary |Term|Definition| |---|---| |axiom|a statement accepted as true without proof.| |call trace|TODO| |CFG|control flow graph control flow path Control flow graphs (short: CFGs) are a program representation that illustrates in which order the program's instructions are processed during program execution. The nodes in a control flow graph represent single non-branching sequences of commands."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-1", "chunk-uid": "25f4f4007c44", "chunk-page-index": 1, "text": "The edges in a control flow graph represent the possibility of control passing from the last command of the source node to the first command of the target node. For instance, an if-statement in the program will lead to a branching, i.e., a node with two outgoing edges, in the control flow graph. A CVL rule can be seen as a program with some extra \"assert\" commands, thus a rule has a CFG like regular programs. The Certora Prover's TAC reports contain a control flow graph of the TAC intermediate representation of each given CVL rule. The control flow paths are the paths from source to sink in a given CFG. In general (and in practice) the number of control flow paths grows exponentially with the size of the CFG. This is known as the path explosion problem. Further reading: Wikipedia: Control-flow graph Wikipedia: Path explosion problem| |environment|The environment of a method call refers to the global variables that solidity provides, including msg, block, and tx. CVL represents these variables in a structure of type env. The environment does not include the contract state or the state of other contracts --- these are referred to as the storage.| |EVM|Ethereum Virtual Machine EVM bytecode EVM is short for Ethereum Virtual Machine. EVM bytecode is one of the source languages that the Certora Prover internally can take as input for verification. It is produced by the Solidity and Vyper compilers, among others. For details on what the EVM is and how it works, the following links provide good entry points. Official documentation, Wikipedia| |EVM memory EVM storage|The EVM has two major concepts of memory, called memory and storage. In brief, memory variables keep data only for the duration of a single EVM transaction, while storage variables are stored persistently in the Ethereum blockchain. Official documentation| |havoc|In some cases, the Certora Prover should assume that some variables can change in an unknown way."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-2", "chunk-uid": "25f4f4007c44", "chunk-page-index": 2, "text": "For example, an external function on an unknown contract may have an arbitrary effect on the state of a third contract. In this case, we say that the variable was \"havoced\". See havoc-summary and havoc-stmt for more details.| |hyperproperty|A hyperproperty describes a relationship between two hypothetical sequences of operations starting from the same initial state. For example, a statement like \"two small deposits will have the same effect as one large deposit\" is a hyperproperty. See storage-type for more details.| |invariant|An invariant (or representation invariant) is a property of the contract state that is expected to hold between invocations of contract methods. See invariants.| |model example counterexample witness example|We use the terms \"model\" and \"example\" interchangeably. In the context of a CVL rule, they refer to an assignment of values to all of the CVL variables and contract storage that either violates an assert statement or fulfills a satisfy statement. In the assert case, we also call the model a \"counterexample\". In the satisfy case, we also call the model \"witness example\". See rule-overview. In the context of SMT solvers, a model is a valuation of the logical constants and uninterpreted functions in the input formula that makes the formula evaluate to true, also see SAT result.| |linear arithmetic nonlinear arithmetic|An arithmetic expression is called linear if it consists only of additions, subtractions, and multiplications by constant. Division and modulo where the second parameter is a constant are also linear arithmetic."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-3", "chunk-uid": "25f4f4007c44", "chunk-page-index": 3, "text": "Examples for linear expressions are x * 3, x / 3, 5 * (x + 3 * y). Every arithmetic expression that is not linear is nonlinear. Examples for nonlinear expressions are x * y, x * (1 + y), x * x, 3 / x, 3 ^ x.| --- overapproximation underapproximation Sometimes it is useful to replace a complex piece of code with something simpler that is easier to reason about. If the approximation includes all of the possible behaviors of the original code (and possibly others), it is called an \"overapproximation\"; if it does not then it is called an \"underapproximation\". Example: A {ref}NONDET &lt;view-summary&gt; summary is an overapproximation because every possible value that the original implementation could return is considered by the Certora Prover, while an {ref}ALWAYS &lt;view-summary&gt; summary is an underapproximation if the summarized method could return more than one value. Proofs on overapproximated programs are {term}sound, but there may be spurious {term}counterexamples caused by behavior that the original code did not exhibit. Underapproximations are more dangerous because a property that is successfully verified on the underapproximation may not hold on the approximated code. parametric rule A parametric rule is a rule that calls an ambiguous method, either using a method variable, or using an overloaded function name. The Certora Prover will generate a separate report for each possible instantiation of the method. See {ref}parametric-rules for more information. quantifier quantified expression The symbols forall and exist are sometimes referred to as quantifiers, and expressions of the form forall type v . e and exist type v . e are referred to as quantified expressions. See {ref}logic-exprs for details about quantifiers in CVL. sanity {todo} This section is incomplete. See {ref}`--rule_sanity` and {ref}`built-in-sanity` for partial information. SAT UNSAT SAT result UNSAT result SAT and UNSAT are the results that an {term}SMT solver returns on a successful run (i.e. not a timeout). SAT means that the input formula is satisfiable and a {term}model has been found. UNSAT means that the input formula is unsatisfiable (and thus there is no model for it). Within the Certora Prover, what SAT means depends on the type of rule being checked: For an assert rule, SAT means the rule is violated and the SMT model corresponds to a counterexample. For a satisfy rule, SAT means the rule is not violated and the SMT model corresponds to a witness example. Conversely, UNSAT means that an assert is never violated or a satisfy never fulfilled respectively. See also {ref}rule-overview. scene The scene refers to the set of contract instances that the Certora Prover knows about. SMT SMT solver \"SMT\" is short for \"Satisfiability Modulo Theories\"."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-4", "chunk-uid": "25f4f4007c44", "chunk-page-index": 4, "text": "An SMT solver takes as input a formula in predicate logic and returns whether the formula is satisfiable (short \"SAT\") or unsatisfiable (short: \"UNSAT\"). The \"Modulo Theory\" part means that the solver assumes a meaning for certain symbols in the formula. For instance the theory of integer arithmetic stipulates that the symbols +, -, *, etc. have their regular everyday mathematical meaning. When the formula is satisfiable, the SMT solver can also return a model for the formula. I.e. an assignment of the formula's variables that makes the formula evaluate to \"true\". For instance, on the formula \"x &gt; 5 /\\ x = y * y\", a solver will return SAT, and produce any valuation where x is the square of an integer and larger than 5, and y is the root of x. Further reading: Wikipedia sound unsound Soundness means that any rule violations in the code being verified are guaranteed to be reported by the Certora Prover. Unsound approximations such as loop unrolling or certain kinds of harnessing may cause real bugs to be missed by the Prover, and should therefore be used with caution."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-5", "chunk-uid": "25f4f4007c44", "chunk-page-index": 5, "text": "See {doc}/docs/prover/approx/index for more details. split split leaf split leaves Control flow splitting is a technique to speed up verification by splitting the program into smaller parts and verifying them separately. These smaller programs are called splits. Splits that cannot be split further are called split leaves. See {ref}control-flow-splitting. summary summarize A method summary is a user-provided approximation of the behavior of a contract method. Summaries are useful if the implementation of a method is not available or if the implementation is too complex for the Certora Prover to analyze without timing out. See {doc}/docs/cvl/methods for complete information on different types of method summaries. TAC TAC (originally short for \"three address code\") is an intermediate representation (Wikipedia) used by the Certora Prover. TAC code is kept invisible to the user most of the time, so its details are not in the scope of this documentation. We provide a working understanding, which is helpful for some advanced proving tasks, in the {ref}tac-reports section. tautology A tautology is a logical statement that is always true. --- vacuous vacuity A logical statement is vacuous if it is technically true but only because it doesn't say anything. For example, \"every integer that is both greater than 5 and less than 3 is a perfect square\" is technically true, but only because there are no numbers that are both greater than 5 and less than 3. Similarly, a rule or assertion can pass, but only because the require statements rule out all of the {term}models. In this case, the rule doesn't say anything about the program being verified. The {doc}../prover/checking/sanity help detect vacuous rules. verification condition The Certora Prover works by translating a program and a specification into a single logical formula that is satisfiable if and only if the program violates the specification. This formula is called a verification condition. Usually, a run of the Certora Prover generates many verification conditions. For instance a verification condition is generated for every {term}parametric rule, and also for each of the sanity checks triggered by {ref}--rule_sanity. See also {ref}white-paper, {ref}user-guide. wildcard exact A methods block entry that explicitly uses _ as a receiver is a wildcard entry; all other entries are called exact entries. See {doc}/docs/cvl/methods. |Term|Definition| |---|---| |axiom|a statement accepted as true without proof.| |call trace|TODO| |CFG|control flow graph control flow path Control flow graphs (short: CFGs) are a program representation that illustrates in which order the program's instructions are processed during program execution. The nodes in a control flow graph represent single non-branching sequences of commands."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-6", "chunk-uid": "25f4f4007c44", "chunk-page-index": 6, "text": "The edges in a control flow graph represent the possibility of control passing from the last command of the source node to the first command of the target node. For instance, an if-statement in the program will lead to a branching, i.e., a node with two outgoing edges, in the control flow graph. A CVL rule can be seen as a program with some extra \"assert\" commands, thus a rule has a CFG like regular programs. The Certora Prover's TAC reports contain a control flow graph of the {term}TAC intermediate representation of each given CVL rule. The control flow paths are the paths from source to sink in a given CFG. In general (and in practice) the number of control flow paths grows exponentially with the size of the CFG. This is known as the path explosion problem. Further reading: Wikipedia: Control-flow graph Wikipedia: Path explosion problem| |environment|The environment of a method call refers to the global variables that solidity provides, including msg, block, and tx. CVL represents these variables in a structure of type {ref}env &lt;env&gt;. The environment does not include the contract state or the state of other contracts --- these are referred to as the {ref}storage &lt;storage-type&gt;.| |EVM|Ethereum Virtual Machine EVM bytecode EVM is short for Ethereum Virtual Machine. EVM bytecode is one of the source languages that the Certora Prover internally can take as input for verification. It is produced by the Solidity and Vyper compilers, among others. For details on what the EVM is and how it works, the following links provide good entry points. Official documentation, Wikipedia| |EVM memory|EVM storage The {term}EVM has two major concepts of memory, called memory and storage. In brief, memory variables keep data only for the duration of a single EVM transaction, while storage variables are stored persistently in the Ethereum blockchain. Official documentation| |havoc|In some cases, the Certora Prover should assume that some variables can change in an unknown way."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-7", "chunk-uid": "25f4f4007c44", "chunk-page-index": 7, "text": "For example, an external function on an unknown contract may have an arbitrary effect on the state of a third contract. In this case, we say that the variable was \"havoced\". See {ref}havoc-summary and {ref}havoc-stmt for more details.| --- hyperproperty A hyperproperty describes a relationship between two hypothetical sequences of operations starting from the same initial state. For example, a statement like \"two small deposits will have the same effect as one large deposit\" is a hyperproperty. See {ref}storage-type for more details. invariant An invariant (or representation invariant) is a property of the contract state that is expected to hold between invocations of contract methods. See {ref}invariants. model example counterexample witness example We use the terms \"model\" and \"example\" interchangeably. In the context of a CVL rule, they refer to an assignment of values to all of the CVL variables and contract storage that either violates an assert statement or fulfills a satisfy statement. In the assert case, we also call the model a \"counterexample\". In the satisfy case, we also call the model \"witness example\". See {ref}rule-overview. In the context of {term}SMT solvers, a model is a valuation of the logical constants and uninterpreted functions in the input formula that makes the formula evaluate to true, also see {term}SAT result. linear arithmetic nonlinear arithmetic An arithmetic expression is called linear if it consists only of additions, subtractions, and multiplications by constant. Division and modulo where the second parameter is a constant are also linear arithmetic. Examples for linear expressions are x * 3, x / 3, 5 * (x + 3 * y). Every arithmetic expression that is not linear is nonlinear. Examples for nonlinear expressions are x * y, x * (1 + y), x * x, 3 / x, 3 ^ x. overapproximation underapproximation Sometimes it is useful to replace a complex piece of code with something simpler that is easier to reason about. If the approximation includes all of the possible behaviors of the original code (and possibly others), it is called an \"overapproximation\"; if it does not then it is called an \"underapproximation\". Example: A summary\">NONDET <view-summary> summary is an overapproximation because every possible value that the original implementation could return is considered by the Certora Prover, while an summary\">ALWAYS <view-summary> summary is an underapproximation if the summarized method could return more than one value. Proofs on overapproximated programs are {term}sound, but there may be spurious {term}counterexamples caused by behavior that the original code did not exhibit. Underapproximations are more dangerous because a property that is successfully verified on the underapproximation may not hold on the approximated code. parametric rule A parametric rule is a rule that calls an ambiguous method, either using a method variable, or using an overloaded function name. The Certora Prover will generate a separate report for each possible instantiation of the method. See {ref}parametric-rules for more information. quantifier quantified expression The symbols forall and exist are sometimes referred to as quantifiers, and expressions of the form forall type v . e and exist type v . e are referred to as quantified expressions. See {ref}logic-exprs for details about quantifiers in CVL. sanity {todo} This section is incomplete. See --rule_sanity and built-in-sanity for partial information. SAT UNSAT SAT result UNSAT result SAT and UNSAT are the results that an {term}SMT solver returns on a successful run (i.e. not a timeout). SAT means that the input formula is satisfiable and a {term}model has been found. UNSAT means that the input formula is unsatisfiable (and thus there is no model for it). Within the Certora Prover, what SAT means depends on the type of rule being checked: For an assert rule, SAT means the rule is violated and the SMT model corresponds to a counterexample. For a satisfy rule, SAT means the rule is not violated and the SMT model corresponds to a witness example. Conversely, UNSAT means that an assert is never violated or a satisfy never fulfilled respectively. See also {ref}rule-overview. scene The scene refers to the set of contract instances that the Certora Prover knows about. SMT SMT solver \"SMT\" is short for \"Satisfiability Modulo Theories\"."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-8", "chunk-uid": "25f4f4007c44", "chunk-page-index": 8, "text": "An SMT solver takes as input a formula in predicate logic and returns whether the formula is satisfiable (short \"SAT\") or unsatisfiable (short: \"UNSAT\"). The \"Modulo Theory\" part means that the solver assumes a meaning for certain symbols in the formula. For instance the theory of integer arithmetic stipulates that the symbols +, -, *, etc. have their regular everyday mathematical meaning. When the formula is satisfiable, the SMT solver can also return a model for the formula. I.e. an assignment of the formula's variables that makes the formula evaluate to \"true\". For instance, on the formula \"x > 5 /\\ x = y * y\", a solver will return SAT, and produce any valuation where x is the square of an integer and larger than 5, and y is the root of x. Further reading: Wikipedia --- sound unsound Soundness means that any rule violations in the code being verified are guaranteed to be reported by the Certora Prover. Unsound approximations such as loop unrolling or certain kinds of harnessing may cause real bugs to be missed by the Prover, and should therefore be used with caution."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-9", "chunk-uid": "25f4f4007c44", "chunk-page-index": 9, "text": "See {doc}/docs/prover/approx/index for more details. split split leaf split leaves Control flow splitting is a technique to speed up verification by splitting the program into smaller parts and verifying them separately. These smaller programs are called splits. Splits that cannot be split further are called split leaves. See {ref}control-flow-splitting. summary summarize A method summary is a user-provided approximation of the behavior of a contract method. Summaries are useful if the implementation of a method is not available or if the implementation is too complex for the Certora Prover to analyze without timing out. See {doc}/docs/cvl/methods for complete information on different types of method summaries. TAC TAC (originally short for \"three address code\") is an intermediate representation (Wikipedia) used by the Certora Prover. TAC code is kept invisible to the user most of the time, so its details are not in the scope of this documentation. We provide a working understanding, which is helpful for some advanced proving tasks, in the {ref}tac-reports section. tautology A tautology is a logical statement that is always true. vacuous vacuity A logical statement is vacuous if it is technically true but only because it doesn't say anything. For example, \"every integer that is both greater than 5 and less than 3 is a perfect square\" is technically true, but only because there are no numbers that are both greater than 5 and less than 3. Similarly, a rule or assertion can pass, but only because the require statements rule out all of the {term}models. In this case, the rule doesn't say anything about the program being verified. The {doc}../prover/checking/sanity help detect vacuous rules. verification condition The Certora Prover works by translating a program an a specification into a single logical formula that is satisfiable if and only if the program violates the specification. This formula is called a verification condition. Usually, a run of the Certora Prover generates many verification conditions. For instance a verification condition is generated for every {term}parametric rule, and also for each of the sanity checks triggered by {ref}--rule_sanity."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "glossary", "id": "25f4f4007c44-10", "chunk-uid": "25f4f4007c44", "chunk-page-index": 10, "text": "See also {ref}white-paper, {ref}user-guide. wildcard exact A methods block entry that explicitly uses _ as a receiver is a wildcard entry; all other entries are called exact entries. See {doc}/docs/cvl/methods."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-0", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 0, "text": "## Timeouts In the following, we will give a basic classification of timeouts, explain some candidate causes for timeouts, and show ways to sometimes prevent them. See timeouts-background for a glimpse into some of the theoretical background on verification timeouts. ## Classification of Timeouts For a first classification of timeouts in Certora Prover, we consider on where in the Prover's pipeline they occur. The pipeline starts by compiling a CVL rule and the linked EVM bytecode into an intermediate language (called TAC)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-1", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 1, "text": "This is followed by many static analyses and program transformations. Afterwards, the TAC program is iteratively split into parts and translated into logical formulas. The logical formulas are then sent to an SMT solver. For more details on how programs are split up see control-flow-splitting. For a more comprehensive overview of the Certora Prover, see the whitepaper-technical section of the Certora Technology White Paper. We classify Certora Prover timeouts as follows: 1. timeouts that happen before SMT solvers are running 2. timeouts where the SMT queries in sum lead to a global timeout 3. timeouts where a single SMT query could not be solved Types 1. and 2. are signified by a hard stop of the Prover. That means the Prover ran into the timeout of the cloud job, which is set at 2 hours, and was forcefully shut down from everything it was doing (it is possible to lower that timeout using the --global_timeout flag). A message like \"hard stop reached\" appears in the \"Global problems\" pane of the report, and error symbols next to one or many rules. A hard stop message appearing under Global Problems Type 3. is signified by a soft stop. This means an SMT solver shut down due to hitting the limit for a single SMT run (set via --smt_timeout). A rule that timed out in the SMT solver In the remainder, we will focus on the mitigation of SMT timeouts, i.e., types 2. and 3. Non-SMT Timeouts (Type 1.) should be reported to Certora. ## Identifying timeout causes As a first step towards resolving an SMT timeout, we need to diagnose its root causes. In our experience, the following are some of the most common reasons for SMT timeouts: - non-trivial amount of nonlinear arithmetic - very high path count - high Storage/Memory complexity --- ## The term \"nonlinear arithmetic\" refers to computations involving multiplications or divisions of variables. These are notoriously hard for solvers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-2", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 2, "text": "The path count is the number of paths from the initial location to the final location in the rule's control flow graph. In the worst case, this leads to a very high number of sub-cases that the solver needs to consider. Furthermore, a high number of updates to Storage or Memory can be challenging for the solver because it needs to reason about aliasing of Storage/Memory locations. This list is not exhaustive, but the majority of timeouts we have observed so far can be traced back to one or more of these causes. While these are not the only sources of complexity, they provide a good idea of the probable causes for a given timeout. ## Complexity feedback from Certora Prover Certora Prover provides help with diagnosing timeouts. We present these features in this section. ### Difficulty statistics Certora Prover provides statistics on the problem sizes it encounters. These statistics are available in the tac-reports that are generated in case of an SMT timeout. The statistics are structured according to the timeout reasons given above. Currently, the Prover tracks the following statistics: |Statistic|Summary|Complexity| |---|---|---| |Nonlinear operations count|1|LOW| |Path count|20 to 280|MEDIUM| |Memory/storage complexity measures| | | The meanings of the LOW/MEDIUM/HIGH classifications are as follows: - LOW: unlikely to be a reason for a timeout - MEDIUM: might be a reason for a timeout; the timeout might also be a result of the combined complexity with other measures - HIGH: likely to be a reason for a timeout, even if it is the only aspect of the verification problem that shows high complexity For more details on the individual statistics and how to make use of them, also see the section on dealing-with-complexity below. ## Timeout TAC reports For each verification item, there is a TAC graph linked in the verification report. In case of a timeout, this graph contains information on which parts of the program were part of the actual timeout and which were already solved successfully. It also contains statistics on the above-described timeout causes. In the timeout case, the TAC reports contain some additional information that should help with diagnosing the timeout. ## Finding timeout causes through modularization In addition to the other techniques described here, it can be insightful to remove parts of the code to isolate the timeout reason. If timeouts are eliminated through this, modular verification techniques can be employed to prove. --- ## correctness of the parts separately These techniques are a relatively blunt instrument, but can be necessary in particular with large or complex code bases. ## Sanity rules One way of isolating the timeout cause is by running with a trivial specification. This way, the specification is ruled out as the source of complexity. Thus, a timeout on such a rule hints towards some parts of the program code being challenging for the solver, rather than the program code in combination with another, less trivial, spec. Sanity rules are such trivial specifications. For documentation on them, see sanity and deep sanity. ## Library contracts Some systems are based on multiple library contracts which implement the business logic. They also forward storage updates to a single external contract holding the storage. In these systems, it can be appropriate to verify each library independently. If you encounter timeouts when trying to verify the main entry point contract to the system, check the impact of the libraries on the verification by summarizing all external library (delegate) calls as NONDET, using the option -summarizeExtLibraryCallsAsNonDetPreLinking as follows: sh certoraRun ... --prover_args '-summarizeExtLibraryCallsAsNonDetPreLinking true' Note: This option is only applied for delegatecalls and external library calls. Internal calls are automatically inlined by the Solidity compiler and are subject to summarizations specified in the spec file's methods block. ## Timeout prevention Timeout prevention approaches fall into these categories: 1. changing tool settings 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-3", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 3, "text": "changing specs 3. changing source code Changing tool settings is least invasive and easy to do, thus it is usually preferable to the other options. However, there are cases when parts of the input code that are very hard to reason about need to be worked around. Sometimes a combination of approaches is needed to resolve a timeout. In the following we will discuss some concrete approaches to timeout prevention. This collection will be extended over time based on user's experiences and tool improvements. Note: The old documentation has a section on troubleshooting that addresses timeouts, which might complement the information given here. There is also some helpful information in the section on summarization."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-4", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 4, "text": "Some of the information in these references is out of date. ## Running rules individually The Certora Prover works on the rules of the specification in parallel. Even if no rule is very expensive on its own, working on all of them in parallel can add up quickly and thereby exceed the timeout. Try running individual rules only via the -rule option, or split the specification into separate files. Keep in mind that a parametric rule, as well as an invariant, spawns a sub-rule for every contract method. This can further be reduced via the --method option. --- ## Detect candidates for summarization In a large codebase it can be hard to find all the functions that may be difficult for the Prover. A traditional approach would be to run a simple parametric rule to explore all functions in the relevant contracts, and studying resulting potential timeouts. However such an approach prolongs the feedback loop of working with the Prover. As an alternative approach, the Prover supports an overapproximating auto-summarization mode. It is based on the idea that internal view or pure functions (in Solidity) that are analyzed and found to be heuristically difficult for the Prover can be automatically summarized as NONDET, resulting in two positive outcomes: 1. The run is faster since complex code is summarized early in the Prover's pipeline. 2. The Prover emits the list of new summaries (i.e., for functions that were not summarized already in the given specification) it auto-generated, so that the user can then adapt the list and make the user-specified summaries more precise, or remove them altogether if the user wishes so. The Prover will not auto-summarize methods that were already summarized by the user. To enable this mode, add --auto_nondet_difficult_internal_funcs to the certoraRun command. The minimal difficulty threshold used for the auto-summarization can be adjusted using --auto_nondet_minimal_difficulty. ### Example usage Many DeFi protocols use the openzeppelin math libraries. One such library is MathUpgradeable, providing a mulDiv functionality: function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result). The implementation is known to be difficult for the Prover due to applying numerous multiplication, division and mulmod operations, and thus is often summarized. However, it is sometimes easy to miss the library also contains a more generalized version of mulDiv that supports either rounding-up or rounding down: function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256). Sometimes it can be beneficial to summarize the generalized function as well."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-5", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 5, "text": "The auto-summarization will highlight the generalized function in its output: auto-summarizer-output-example The contents can be copy-pasted into the methods block directly for future runs. The \"Contracts Call Resolutions\" tab and the \"Rule Call Resolution\" bar also show the instrumented auto-summaries, and distinguishes between them and user-defined summaries. ## Dealing with complexity screenshots in this subsection are taken from this run: https://vaas-stg.certora.com/output/80942/9101c7e51a27456eb51bd9d088949c92?anonymousKey=25cca030b7594b795d994e937b5a027812d9406d and from the (usual) delvtech/element example In this section we list some hints for timeout prevention based on which of the statistics (path count, number of nonlinear operations, memory/storage complexity) is showing high severity on a given rule. The techniques described further down under modular verification are worth considering no matter which statistic is showing high severity. ### Dealing with a high path count The number of control flow paths is a major indication of how difficult a rule is to solve. Intuitively, in order to obtain a correctness proof for the rule, an argument for the correctness of each of its paths has to be found. --- The Certora Prover indicates the path count in the Live Statistics panel. The path count is given once for the whole rule and, separately on a per-call basis. The per-call path count always includes the paths of all deeper calls (the same holds for the count of nonlinear operations of the call). Global and per-call path counts are displayed in the Live Statistics panel for each rule. Path explosion The number of paths that are given in the path count statistic might seem very high to users. The essential reason for these high number is known as the path explosion problem: The path count is usually exponential in the number of nodes and edges in the control flow graph. For some intuition on how this happens, see the following illustration. Whenever there is a sequence of subgraphs that branch and then join again, the simplest variant of this being the diamond shapes in the picture, the path count of the whole graph is the product of these subgraph's path counts. Thus it is typical for the path count of a control flow graph to grow exponentially in its number of nodes (or edges). Illustration of path explosion through a sequence of n \"diamond\" shapes in the control flow graph. The shown control flow graph has 2n paths. The path count statistic for a given rule is based on the control flow graph of the rule with all calls (and their calls and so forth) inlined. For example, if some method with 5 paths is called 10 times within the rule, its control flow graph will appear 10 times as a subgraph of the rule's control flow graph. If, for instance all these calls were made in sequence, and there was no further branching in the rule, the path count would be 5 * 10. A particular potential cause for path explosion are dispatcher. How much a DISPATCHER summary contributes to the path count depends on three factors: - how many potential call targets there are (how many known implementations) - how often the summarized function is called - whether the function is called in sequence or in parallel in the control flow (generally control flow branchings in sequence lead to an exponential path explosion) Mitigation approaches In order to reduce the path count of a rule, the usual modularization techniques, like method summarization, can be applied. (See also the section modular-verification below.) As pointed out in the previous sub-section, DISPATCHER summaries can lead to a path explosion, so replacing them for instance with AUTO summaries can have a significant impact. (See also auto-summary.) Furthermore, it can help to change the parameters of the control flow splitting feature of the Certora Prover. Control flow splitting is a natural area to consider when the path count of a rule is high. When applying this technique, the Certora Prover internally divides each verification condition into smaller subproblems and attempts to solve them separately. For a more detailed explanation, see control-flow-splitting. We list a few option combinations that can help in various settings. There is a tradeoff between spending time in different places: The Prover can either try to spend much time at a low splitting level in the hope that no further splitting will be needed, or it can split quickly in the hope that the subproblems will be much easier to solve. The options on control flow splitting are described in more detail in the corresponding section of the CLI documentation. In the following, we list some brief examples how they can be used to avoid timeouts in certain scenarios. When the relevant source code is very large, the shallow splits have a chance of being too large for the solvers, thus eager splitting might help: sh certoraRun ... --prover_args '-smt_initialSplitDepth 5 -depth 15' When there are very many subproblems that are of medium difficulty there is a chance that the Prover has to split too often (not being able to \"close\" any sub-splits). In that case, a lazier splitting strategy could help. We achieve lazier splitting by --- giving the solver more time to find a solution before we split a problem. sh certoraRun ... --prover_args '-mediumTimeout 30 -depth 5' It can also help to have splitting run in parallel (the splits are solved sequentially by default). sh certoraRun ... --prover_args '-splitParallel true' If the expectation is that the rule is violated (or not violated in case of a satisfy-style rule), the {ref}- dontStopAtFirstSplitTimeout option can prove useful. sh certoraRun ... --prover_args '-dontStopAtFirstSplitTimeout true -depth 15 -mediumTimeout 5' -- smt_timeout 10 (high-nonlinear-op-count)= Dealing with nonlinear arithmetic Nonlinear integer arithmetic is often the hardest part of the formulas that the Certora Prover is solving. The Certora Prover displays the absolute number of nonlinear operations, as well as their number per external call, in the Live Statistics panel. In the per-call display, there is a warning-sign next to the call when there is a non-trivial number of nonlinear operations in the call or its sub-call. Currently, everything above and including two nonlinear operations is marked in this way. Counting the number of nonlinear operations is a rather coarse statistic. There are formulas with 10 nonlinear operations that are out of reach of current SMT solvers, while in other cases formulas with 120 operations are solved. Nevertheless, reducing the number of nonlinear operations has often proven a successful measure in timeout prevention even if some remained. The main techniques in reducing these numbers are modularization and underapproximation. Modularization, typically by introducing method summaries, can help reduce the size of the rule, thus reducing the nonlinear operations. The per-call statistics in the Live Statistics panel (picture below) can help with identifying nonlinearity hot spots. Summarizing these hot spots in particular can help reduce the number of nonlinear operations, especially when a method is called multiple times. In some rules it is feasible to only consider an underapproximation of the actual behavior by fixing some value that is used very often in nonlinear computations to a concrete value. A typical example would be the decimal digits in fixed decimal arithmetic -- having this unconstrained can increase nonlinearity in the rule massively, although only a small range of values is actually feasible. Of course, great care has to be taken in choosing these underapproximations, since they lead to missed bugs otherwise. A weaker form of underapproximation would be to introduce an extra requirement on the range of some variable that contributes to nonlinearity. For example for the number of decimals in a fixed decimal computation only values between 0 and 256 make sense, and in practice values from an even smaller range are likely to be used."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-6", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 6, "text": "This measure will not change the values in the Live Statistics panel, but it has prevented timeouts in some cases nonetheless. (high-memory-complexity)= Dealing with high memory (or storage) complexity --- ## The memory complexity of each rule or parametric rule is displayed in the Live Statistics panel in the Certora Prover reports. If we would want to slim it down to graph size only, we could write this: Memory complexity is measured by the number of updates statistic. This statistic indicates how often an update to memory is performed anywhere in the rule. Note that any form of memory, i.e. EVM memory, EVM storage, ghost variables, or ghost functions, is counted here. This number gives a rough estimate of how much work the SMT solvers have to do to reason about (non-)aliasing of memory references. The Certora Prover performs a decompilation of bytecode in a way that all EVM primitives can ultimately be modeled as SMT constructs. This process introduces key-to-value mappings for EVM memory and EVM storage. Additionally, the CVL specification may introduce ghost mappings. The Prover runs static analyses to reduce the load on these mappings by splitting them into smaller pieces (smaller mappings or scalar variables), but this is not always possible and some mappings usually remain in the final SMT formula. Under this model, the \"#total updates\" is a measure of how many times we store into a key-value mapping such as memory, storage, or a ghost function. The \"longest update sequence\" statistic represents the length of the longest sequence of updates (i.e. store operations) performed on one of the mappings."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-7", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 7, "text": "In both cases, a smaller number indicates a less difficult problem for the Prover to solve. Entry in pe Live Statistics panel indicating memory complexity In the following, we consider common culprits for high memory complexity. Passing complex structs One common reason for high memory complexity are complex data structures that are passed from the specification to the program, or also inside the program. struct types that contain many dynamically-sized arrays are especially problematic. In this case, it can help to identify fields of the struct that are not relevant for the property of the program that is currently being reasoned about and comment out those fields. In our experience these fields exist relatively often especially in large structs. Naturally, the removal might be complicated by the fact that all usages of these fields also need some munging steps applied to them. Memory and storage in inline assembly The Certora Prover employs static analyses and simplifications in order to make the reasoning about Storage and Memory easier for the SMT solvers. These static analyses are sometimes thrown off by unusual code patterns (most often produced when using inline assembly), which can make the SMT formulas too hard to solve. CVT reports these failures of Storage or Memory analysis in the Global Problems pane of the reports, along with pointers to the offending source code positions (typically inline assembly containing sstore/sload/mstore/mload operations). To resolve such failures, the relevant code parts need to be summarized or munged. (Naturally, the Certora developers are working make such failures less frequent as well.) ## Modular verification --- Often it is useful to break a complex problem into simpler subproblems; this process is called modularization. You can modularize a verification problem by first proving a property about a complex piece of code (such as a library or a method) and then using that property to summarize the complex code. In the following we elaborate on modularization techniques that can help with timeout prevention. ## Library-based systems As mentioned here before, systems with libraries are a natural candidate for modularization. Alternatively to using the --summarizeExtLibraryCallsAsNonDetPreLinking true option mentioned before, one can summarize all the methods of a single library using a catch-all summary. For example, to use a NONDET summary for all functions of MyBigLibrary, one could add the following: |methods| | |---|---| |function MyBigLibrary._ external =&gt; NONDET;| | |function MyBigLibrary._ internal =&gt; NONDET;| | The above snippet has the effect of summarizing as NONDET all external calls to the library and internal ones as well. Only NONDET and HAVOC summaries can be applied."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-8", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 8, "text": "For more information on method summaries, see summaries. ## Command line options There are a number of command line options that influence specific parts of the Prover's pipeline. While their default values generally yield the best results, changing them is known to improve running time in certain cases. --prover_args '-calltraceFreeOpt true' This option allows for some rather aggressive simplifications. However, it possibly breaks call trace generation. ## Timeouts In the following, we will give a basic classification of timeouts, explain some candidate causes for timeouts, and show ways to sometimes prevent them. See timeouts-background for a glimpse into some of the theoretical background on verification timeouts. ## Classification of Timeouts For a first classification of timeouts in Certora Prover, we consider on where in the Prover's pipeline they occur. The pipeline starts by compiling a CVL rule and the linked EVM bytecode into an intermediate language (called TAC)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-9", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 9, "text": "This is followed by many static analyses and program transformations. Afterwards, the TAC program is iteratively split into parts and translated into logical formulas. The logical formulas are then sent to an SMT solver. For more details on how programs are split up see control-flow-splitting. For a more comprehensive overview of the Certora Prover, see the whitepaper-technical section of the Certora Technology White Paper. We classify Certora Prover timeouts as follows: 1. timeouts that happen before SMT solvers are running 2. timeouts where the SMT queries in sum lead to a global timeout 3. timeouts where a single SMT query could not be solved Types 1. and 2. are signified by a hard stop of the Prover. That means the Prover ran into the timeout of the cloud job, which is set at 2 hours, and was forcefully shut down from everything it was doing (it is possible to lower that timeout using the --- ## Identifying timeout causes As a first step towards resolving an SMT timeout, we need to diagnose its root causes. In our experience, the following are some of the most common reasons for SMT timeouts: - non-trivial amount of nonlinear arithmetic - very high path count - high Storage/Memory complexity The term nonlinear arithmetic refers to computations involving multiplications or divisions of variables. These are notoriously hard for solvers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-10", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 10, "text": "The path count is the number of paths from the initial location to the final location in the rule's control flow graph. In the worst case, this leads to a very high number of sub-cases that the solver needs to consider. Furthermore, a high number of updates to Storage or Memory can be challenging for the solver because it needs to reason about aliasing of Storage/Memory locations. This list is not exhaustive, but the majority of timeouts we have observed so far can be traced back to one or more of these causes. While these are not the only sources of complexity, they provide a good idea of the probable causes for a given timeout. ## Complexity feedback from Certora Prover Certora Prover provides help with diagnosing timeouts. We present these features in this section. ### Difficulty statistics Certora Prover provides statistics on the problem sizes it encounters. These statistics are available in the tac-reports that are generated in case of an SMT timeout. The statistics are structured according to the timeout reasons given above. Currently, the Prover tracks the following statistics: - nonlinear operations count - path count - memory/storage complexity measures For a very short summary, we give one summarizing number for each of the statistics, along with a LOW/MEDIUM/HIGH statement. --- ## Timeout TAC reports For each verification item, there is a TAC graph linked in the verification report. In case of a timeout this graph contains information on which parts of the program were part of the actual timeout, and which were already solved successfully. It also contains statistics on the above-described timeout causes. Find more documentation on TAC reports in general here. ## Finding timeout causes through modularization In addition to the other techniques described here, it can be insightful to remove parts of the code in order to isolate the timeout reason. If timeouts are eliminated through this, modular verification techniques can be employed in order to prove correctness of the parts separately. These techniques are a relatively blunt instrument, but can be necessary in particular with large or complex code bases. ## Sanity rules One way of isolating the timeout cause is by running with a trivial specification. This way, the specification is ruled out as the source of complexity. Thus, a timeout on such a rule hints towards some parts of the program code being challenging for the solver, rather than the program code in combination with another, less trivial, spec. Sanity rules are such trivial specifications. For documentation on them, see sanity and deep sanity. ## Library contracts Some systems are based on multiple library contracts which implement the business logic. They also forward storage updates to a single external contract holding the storage. In these systems, it can be appropriate to verify each library independently. If you encounter timeouts when trying to verify the main entry point contract to the system, check the impact of the libraries on the verification by summarizing all external library (delegate) calls as NONDET, using the option -summarizeExtLibraryCallsAsNonDetPreLinking as follows: sh certoraRun ... --prover_args '-summarizeExtLibraryCallsAsNonDetPreLinking true' --- ## {note} This option is only applied for delegatecalls and external library calls. Internal calls are automatically inlined by the Solidity compiler and are subject to summarizations specified in the spec file's methods block. ## Timeout prevention Timeout prevention approaches fall into these categories: 1. changing tool settings 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-11", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 11, "text": "changing specs 3. changing source code Changing tool settings is least invasive and easy to do, thus it is usually preferable to the other options. However, there are cases when parts of the input code that are very hard to reason about need to be worked around. Sometimes a combination of approaches is needed to resolve a timeout. In the following we will discuss some concrete approaches to timeout prevention. This collection will be extended over time based on user's experiences and tool improvements. ## {note} The old documentation has a section on troubleshooting that addresses timeouts, which might complement the information given here. There is also some helpful information in the section on summarization."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-12", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 12, "text": "Some of the information in these references is out of date. ## Running rules individually The Certora Prover works on the rules of the specification in parallel. Even if no rule is very expensive on its own, working on all of them in parallel can add up quickly and thereby exceed the timeout. Try running individual rules only via the -rule option, or split the specification into separate files. Keep in mind that a parametric rule, as well as an invariant, spawns a sub-rule for every contract method. This can further be reduced via the --method option. ## Detect candidates for summarization In a large codebase it can be hard to find all the functions that may be difficult for the Prover. A traditional approach would be to run a simple parametric rule to explore all functions in the relevant contracts, and studying resulting potential timeouts. However such an approach prolongs the feedback loop of working with the Prover. As an alternative approach, the Prover supports an overapproximating auto-summarization mode. It is based on the idea that internal view or pure functions (in Solidity) that are analyzed and found to be heuristically difficult for the Prover can be automatically summarized as NONDET, resulting in two positive outcomes: 1. The run is faster since complex code is summarized early in the Prover's pipeline. 2. The Prover emits the list of new summaries (i.e., for functions that were not summarized already in the given specification) it auto-generated, so that the user can then adapt the list and make the user-specified summaries more precise, or remove them altogether if the user wishes so. The Prover will not auto-summarize methods that were already summarized by the user. To enable this mode, add --auto_nondet_difficult_internal_funcs to the certoraRun command. The minimal difficulty threshold used for the auto-summarization can be adjusted using --auto_nondet_minimal_difficulty. ### Example usage Many DeFi protocols use the openzeppelin math libraries. One such library is MathUpgradeable, providing a mulDiv functionality: function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 --- result). The implementation is known to be difficult for the Prover due to applying numerous multiplication, division and mulmod operations, and thus is often summarized. However, it is sometimes easy to miss the library also contains a more generalized version of mulDiv that supports either rounding-up or rounding down: function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256). Sometimes it can be beneficial to summarize the generalized function as well."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-13", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 13, "text": "The auto-summarization will highlight the generalized function in its output: auto-summarizer-output-example The contents can be copy-pasted into the methods block directly for future runs. The \"Contracts Call Resolutions\" tab and the \"Rule Call Resolution\" bar also show the instrumented auto-summaries, and distinguishes between them and user-defined summaries. ## Dealing with different kinds of complexity % screenshots in this subsection are taken from this run: % https://vaas-stg.certora.com/output/80942/9101c7e51a27456eb51bd9d088949c92?anonymousKey=25cca030b7594b795d994e937b5a027812d9406d % and from the (usual) delvtech/element example In this section we list some hints for timeout prevention based on which of the statistics (path count, number of nonlinear operations, memory/storage complexity) is showing high severity on a given rule. The techniques described further down under modular verification are worth considering no matter which statistic is showing high severity. ## Dealing with a high path count The number of control flow paths is a major indication of how difficult a rule is to solve. Intuitively, in order to obtain a correctness proof for the rule, an argument for the correctness of each of its paths has to be found. The Certora Prover indicates the path count in the Live Statistics panel. The path count is given once for the whole rule and, separately on a per-call basis. The per-call path count always includes the paths of all deeper calls (the same holds for the count of nonlinear operations of the call). Path explosion The number of paths that are given in the path count statistic might seem very high to users. The essential reason for these high number is known as the path explosion problem: The path count is usually exponential in the number of nodes and edges in the control flow graph. For some intuition on how this happens, see the following illustration. Whenever there is a sequence of subgraphs that branch and then join again, the simplest variant of this being the diamond shapes in the picture, the path count of the whole graph is the product of these subgraph's path counts. Thus it is typical for the path count of a control flow graph to grow exponentially in its number of nodes (or edges). The path count statistic for a given rule is based on the control flow graph of the rule with all calls (and their calls and so forth) inlined. For example, if some method with 5 paths is called 10 times within the rule, its control flow graph will appear --- 10 times as a subgraph of the rule's control flow graph. If, for instance all these calls were made in sequence, and there was no further branching in the rule, the path count would be 5 10. A particular potential cause for path explosion are dispatcher. How much a DISPATCHER summary contributes to the path count depends on three factors: - how many potential call targets there are (how many known implementations) - how often the summarized function is called - whether the function is called in sequence or in parallel in the control flow (generally control flow branchings in sequence lead to an exponential path explosion) ## Mitigation approaches In order to reduce the path count of a rule, the usual modularization techniques, like method summarization, can be applied. (See also the section modular-verification below.) As pointed out in the previous sub-section, DISPATCHER summaries can lead to a path explosion, so replacing them for instance with AUTO summaries can have a significant impact. (See also auto-summary.) Furthermore, it can help to change the parameters of the control flow splitting feature of the Certora Prover. Control flow splitting is a natural area to consider when the path count of a rule is high. When applying this technique, the Certora Prover internally divides each verification condition into smaller subproblems and attempts to solve them separately. For a more detailed explanation, see control-flow-splitting. We list a few option combinations that can help in various settings. There is a tradeoff between spending time in different places: The Prover can either try to spend much time at a low splitting level in the hope that no further splitting will be needed, or it can split quickly in the hope that the subproblems will be much easier to solve. The options on control flow splitting are described in more detail in the corresponding section of the CLI documentation. In the following, we list some brief examples how they can be used to avoid timeouts in certain scenarios. When the relevant source code is very large, the shallow splits have a chance of being too large for the solvers, thus eager splitting might help: sh certoraRun ... --prover_args '-smt_initialSplitDepth 5 -depth 15' When there are very many subproblems that are of medium difficulty there is a chance that the Prover has to split too often (not being able to \"close\" any sub-splits). In that case, a lazier splitting strategy could help."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-14", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 14, "text": "We achieve lazier splitting by giving the solver more time to find a solution before we split a problem. sh certoraRun ... --prover_args '-mediumTimeout 30 -depth 5' It can also help to have splitting run in parallel (the splits are solved sequentially by default). sh certoraRun ... --prover_args '-splitParallel true' If the expectation is that the rule is violated (or not violated in case of a satisfy-style rule), the dontStopAtFirstSplitTimeout option can prove useful. sh certoraRun ... --prover_args '-dontStopAtFirstSplitTimeout true -depth 15 -mediumTimeout 5' -- smt_timeout 10 ## Dealing with nonlinear arithmetic Nonlinear integer arithmetic is often the hardest part of the formulas that the Certora Prover is solving. The Certora Prover displays the absolute number of nonlinear operations, as well as their number per external call, in the Live Statistics panel. In the per-call display, there is a warning-sign next to the call when there is a non-trivial number of nonlinear operations in the call or its sub-call. Currently, everything above and including two nonlinear operations is marked in this way. --- ## nonlinear ops field Field in the Live Statistics panel indicating the number of nonlinear operations in the selected rule ## Counting the number of nonlinear operations is a rather coarse statistic. There are formulas with 10 nonlinear operations that are out of reach of current SMT solvers, while in other cases formulas with 120 operations are solved. Nevertheless, reducing the number of nonlinear operations has often proven a successful measure in timeout prevention even if some remained. The main techniques in reducing these numbers are modularization and underapproximation. Modularization, typically by introducing method summaries, can help reduce the size of the rule, thus reducing the nonlinear operations. The per-call statistics in the Live Statistics panel (picture below) can help with identifying nonlinearity hot spots. Summarizing these hot spots in particular can help reduce the number of nonlinear operations, especially when a method is called multiple times. ## nonlinear ops call Entry in Live Statistics indicating how many nonlinear operations are made in a given call, including its sub-calls In some rules it is feasible to only consider an underapproximation of the actual behavior by fixing some value that is used very often in nonlinear computations to a concrete value. A typical example would be the decimal digits in fixed decimal arithmetic -- having this unconstrained can increase nonlinearity in the rule massively, although only a small range of values is actually feasible."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-15", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 15, "text": "Of course, great care has to be taken in choosing these underapproximations, since they lead to missed bugs otherwise. A weaker form of underapproximation would be to introduce an extra requirement on the range of some variable that contributes to nonlinearity. For example for the number of decimals in a fixed decimal computation only values between 0 and 256 make sense, and in practice values from an even smaller range are likely to be used. This measure will not change the values in the Live Statistics panel, but it has prevented timeouts in some cases nonetheless. ## Dealing with high memory (or storage) complexity The memory complexity of each rule or parametric rule is displayed in the Live Statistics panel in the Certora Prover reports. If we would want to slim it down to graph size only, we could write this: Memory complexity is measured by the number of updates statistic. This statistic indicates how often an update to memory is performed anywhere in the rule. Note that any form of memory, i.e. EVM memory, EVM storage, ghost variables, or ghost functions, is counted here. This number gives rough estimate of how much work the SMT solvers have to do to reason about (non-)aliasing of memory references. The Certora Prover performs a decompilation of bytecode in a way that all EVM primitives can ultimately be modeled as SMT constructs. This process introduces key-to-value mappings for EVM memory and EVM storage. Additionally the CVL specification may introduce ghost mappings. The Prover runs static analyses to reduce the load on these mappings by splitting them into smaller pieces, (smaller mappings or scalar variables), but this is not always possible and some mappings usually remain in the final SMT formula. Under this model, the \"#total updates\" is a measure of how many times we store into a key-value mapping such as memory, storage, or a ghost function. The \"longest update sequence\" statistic represents the length the longest sequence of updates (i.e. store operations) performed on one of the mappings."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-16", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 16, "text": "In both cases, a smaller number indicates a less difficult problem for the Prover to solve. ## memory complexity field Entry in the Live Statistics panel indicating memory complexity In the following we consider common culprits for high memory complexity. Passing complex structs --- ## One common reason for high memory complexity One common reason for high memory complexity are complex data structures that are passed from the specification to the program, or also inside the program. struct types that contain many dynamically-sized arrays are especially problematic. cvl rule myRule() { MyStruct x; foo(x); } solidity struct MyStruct { // several dynamically-sized arrays bytes b; string s; uint[] u1; uint8[] u2; } function foo(MyStruct x) public { ... } In this case, it can help to identify fields of the struct that are not relevant for the property of the program that is currently being reasoned about and comment out those fields. In our experience these fields exist relatively often especially in large structs. Naturally, the removal might be complicated by the fact that all usages of these fields also need some munging steps applied to them. ## Memory and storage in inline assembly The Certora Prover employs static analyses and simplifications in order to make the reasoning about Storage and Memory easier for the SMT solvers. These static analyses are sometimes thrown off by unusual code patterns (most often produced when using inline assembly), which can make the SMT formulas too hard to solve. CVT reports these failures of Storage or Memory analysis in the Global Problems pane of the reports, along with pointers to the offending source code positions (typically inline assembly containing sstore/sload/mstore/mload operations). To resolve such failures, the relevant code parts need to be summarized or munged. (Naturally, the Certora developers are working make such failures less frequent as well.) ## Modular verification Often it is useful to break a complex problem into simpler subproblems; this process is called modularization. You can modularize a verification problem by first proving a property about a complex piece of code (such as a library or a method) and then using that property to summarize the complex code. In the following we elaborate on modularization techniques that can help with timeout prevention. ## Library-based systems As mentioned here before, systems with libraries are a natural candidate for modularization. Alternatively to using the -summarizeExtLibraryCallsAsNonDetPreLinking true option mentioned before, one can summarize all the methods of a single library using a catch-all summary. For example, to use a NONDET summary for all functions of MyBigLibrary, one could add the following: methods { function MyBigLibrary._ external => NONDET; function MyBigLibrary._ internal => NONDET; } The above snippet has the effect of summarizing as NONDET all external calls to the library and internal ones as well. Only NONDET and HAVOC summaries can be applied."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout", "id": "6ea828ce9c50-17", "chunk-uid": "6ea828ce9c50", "chunk-page-index": 17, "text": "For more information on method summaries, see summaries. ## Command line options --- There are a number of command line options that influence specific parts of the Prover's pipeline. While their default values generally yield the best results, changing them is known to improve running time in certain cases. --prover_args '-calltraceFreeOpt true' This option allows for some rather aggressive simplifications. However, it possibly breaks call trace generation."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "prover_changelog", "id": "36f1812493d9-0", "chunk-uid": "36f1812493d9", "chunk-page-index": 0, "text": "## Prover Release Notes ### 7.3.0 (April 11, 2024) #### CVL |[feat] An option to make autofinders for internal functions less likely to cause compilation failures|use_memory_safe_autofinders| |---|---| |[feat] Dispatch-list summarization for calls with unresolved method identifiers|catch-unresolved-calls-entry| |[feat] Preliminary support for tload, tstore operations in inline-assembly Solidity and EVM, along with ALL_TLOAD and ALL_TSTORE hooks|see transient-storage and rawhooks| |[feat] Support direct access to immutables, including private immutables|direct-immutable-access| |[feat] Grounding of quantifiers supported with direct storage access expressions| | |[feat] Support asterisk (*) wildcard in --rule, and a new option for --exclude_rule|see --exclude_rule| |[feat] Support using requireInvariant with unused invariants from imported contracts| | |[feat] Support blobhash instruction and opcode hooks| | |[bugfix] Fix --address setting of fixed addresses to contracts to reflect in counterexamples properly| | |[bugfix] Fixes to internal function detection| | |[bugfix] Fix issue when dealing with contract-types| | |[bugfix] Support multiple havoc-assuming statements inside a rule, hook, or function| | |[bugfix] Support unary minus in quantifier expressions| | |[bugfix] A helper option for detecting internal functions with Yul-optimizations enabled|finder_friendly_optimizer| |[bugfix] A collection of fixes to internal function detection and summarization| | |[bugfix] Support of summarization in old code using patterns like MakerDAO’s note modifier, enabled with --prover_args '-rewriteMSizeAllocations true' (the Global Warnings tab will advise when it’s recommended to be enabled)| | #### Rule Report [feat] Improved presentation of arrays and arrays’ lengp in pe call trace [bugfix] Do not show rules as verified if pe sanity check timed-out [UX] Show internal functions pat could not be detected (and as a result, summarized) in pe global problems view [UX] Avoid showing redundant and irrelevant analysis failures #### Performance [bugfix] Better safe map optimization for multiplication by constants [bugfix] Fixes to new parallel splitter mode #### CLI |[feat] --compilation_steps_only option is exposed (runs only compilation and type checking)|see --compilation_steps_only| |---|---| |[feat] --precise_bitwise_ops to easily enable bit-vector theory solvers| | #### Mutation Testing [feat] Allow omitting pe --conf flag to perform collection only --- ## Bugfixes - Fix root directory issue for mutated files in subdirectories - Rules that failed sanity during the run on the original code but capture mutants will not be ignored when computing caught mutants ## Miscellaneous - Preliminary support for running the Prover on .yul contracts - Assume strictly monotonic increasing free memory pointer, to avoid counterexamples due to overflow in memory access ## 7.0.7 (March 15, 2024) ## CVL - If conditions in CVL must be wrapped with parenthesis. Namely, if cond is illegal, use if (cond) - It is no longer needed to specify the STORAGE keyword for Sload and Sstore hooks. Please find-replace in your current specs! - The default summarization policy for wildcard external functions (e.g. _.foo(..) =>) is UNRESOLVED, meaning that the summary will only apply to calls to foo whose target contract is unknown. If you wish to apply to all call sites of foo, including for properly linked contracts, write _.foo(..) => some_summary ALL; - Allow 'tuple like' syntax for assignments, e.g. (x,y) = foo(); - Support blobbasefee variable in environment variables - Auto-summarization mode for heuristically expensive internal functions - Support hooking on length of dynamic storage arrays - Support basic struct comparison - Wildcards properly constrained when assigned e.g. in summarization - Ensure cleanliness of CVL strings in the last word - Unlinked immutables are properly constrained to respect their types - Correct invariant handling of the base case rule for Vyper contracts - Fix to viewReentrancy builtin rule crash - Better type checking of quantified expressions with definitions - Fix direct storage access to an array of structs - Fix for internal summaries using user-defined value types ## Rule Report - Display array length in variables tab - Display array length in CVL to CVL function calls - No false match on Vyper constructors in invariants and parametric rules - Consistent rule ordering - Show message in report when --prover_args are incorrect ## Static Analysis and Performance - Automatic full unrolling of copy loops (no need to set -copyLoopUnroll option) - Proper deduplication of libraries imported by different scene-level contracts - Fix returns of static arrays - Make hashing of encodePacked bytes result deterministic when -enableCopyLoopRewrites is set to true - Source-based call resolution is disabled by default except for constructor methods. Can be re-enabled with --prover_args '-enableSolidityBasedInlining true' ## Mutation Testing - Instead of running with 2 conf files, one for the Prover and one for mutation, now the mutation settings are stored in the Prover conf under the key mutations --- ## CLI [feat] Instead of --prover_args '-optimisticFallback true' use --optimistic_fallback [feat] Instead of --prover_args '-contractRecursionLimit N' use --contract_recursion_limit N, and a new flag --optimistic_contract_recursion [feat] New option --compiler_map behaving exactly like --solc_map [bugfix] Fix to --address when given wipout 0x prefix ## 6.3.1 (February 2, 2024) ## CVL [feat] {ref}address-casting [feat] {ref}ecrecover builtin support [feat] Optimistically assume pe extcodesize is positive for calls pat are summarized and wip a non-HAVOC summary. This behavior can be disabled wip --prover_args 'optimisticExtcodesize false' [feat] Support direct storage access in quantifiers and axioms [bugfix] Implication, bi-implication and ternary conditional operators are right-associative [bugfix] {ref}Fully support additional environment fields <env>. Namely, for env e, one can access e.block.basefee, e.block.coinbase, e.block.difficulty, e.block.gaslimit and e.tx.origin [bugfix] Properly enforce bounds on enums accessed using direct storage access [bugfix] Fix a bug wip structs being passed to summaries and not preserving peir fields’ values [bugfix] Avoid hook inlining due to direct storage access [bugfix] Type checker will error in presence of non-boolean expressions in quantifiers' bodies [UX] Emit a global error in rule report if 0 rules are provided in pe spec [UX] Cast assertions in CVL are treated like regular user-provided assertions [UX] Warn about, and ignore, unused mepod arguments [UX] Prevent calling library functions from CVL ## Call Trace and Rule Report [feat] Add presentation of direct storage reads and direct storage havocs, including showing pe updates in pe Storage State [feat] When pe user provided no assertion message, show pe assert condition [bugfix] More refined handling of branch snippets wipin loop iterations [bugfix] Ensure we get pe correct TAC dump link [UX] Improved messages for assertions in builtin rules [UX] New presentation for invariants [UX] Branch snippets are now flattened, can be made hierarchical using --prover_args '-flattenBranchesInCallTrace false' ## Static analysis and Performance [feat] abi.encodeCall calls will be considered as copy-loops, pus will not require a higher --loop_iter if we enable pe following option: --prover_args '-enableCopyLoopRewrites true' [feat] Better performance on last assertions in a rule if --prover_args '-calltraceFreeOpt true' is enabled ## Misc [feat] Support Vyper v0.3.10 --- ## Bugfixes [bugfix] Various bug fixes to improve stability of pe Prover (crashes, static analysis, and SMT solving) [bugfix] Better support of importing user-defined types from Solidity imports even if pey are not given in a consistent fashion by solc ## 6.1.3 (January 11, 2024) ## CVL [feat] Rules can now use bop satisfy and assert statements togeper [feat] An option for checking satisfy statements one-by-one instead of depending on previous satisfy-s, enabled wip --independent_satisfy [feat] {ref}persistent-ghosts [feat] Support selector keyword in CALL-like hooks pat can be compared to function selectors [feat] New builtin function for hashing keccak256 in CVL [feat] Support mepod parameter filters when invariants are imported wip use [feat] New options {ref}--optimistic_summary_recursion and {ref}--summary_recursion_limit [bugfix] Improved error messages for hooks [bugfix] Fix compile time checks for ghosts mappings axioms and bad CVL function calls perein [bugfix] Make CONSTANT summaries of internal functions consistent [bugfix] Allow Solidity struct fields named hook [bugfix] Fix to_bytes in quantifiers [bugfix] Better error message on struct decode failures [bugfix] Proper typing of sub-expressions of bitwise shift operations wipin quantifiers [UX] Nicer error messages for invalid use of max_* constants and hex literals [UX] Sanity builtin rule now succeeds when pe sanity check succeeds (using satisfy under pe hood) (note pis can swap pe expected result if you use pe builtin sanity rule often, but you no longer have to interpret a “violated” result as pe good one) ## Performance [feat] New optimization analysis. It can be configured to be more or less aggressive wip pe option --prover_args '-intervals_rewriter INT' [feat] New flag for better performance: --prover_args '-enableCopyLoopRewrites true' - replaces copy loop code blocks wip a single copy command. Decreases problem size and obviates loop unrolling for copy loops (i.e., more sound) [feat] New flag for better performance: --prover_args '-enableAggressivePartitionPruning true' - for Solidity code pat often manipulates - dynamic objects in memory ## Call Trace [feat] Show branch source information (can be disabled wip --prover_args '-enableConditionalSnippets false') [bugfix] Fix return value display for ghost reads ## Mutation Testing [feat] Generate mutation configuration automatically [UX] Expose errors emitted by Gambit [UX] certoraMutate now uses .mconf files instead of .conf ## Misc [feat] enable pe max constant loop unroll factor inferred wip --prover_args '-loopUnrollBoundGuessUpperLimit INT [bugfix] Vyper fixes for static arrays, xor patterns, ABI fetching in old versions [bugfix] Support for some older versions of Vyper (0.3.7 and earlier) --- ## 5.0.5 (November 21, 2023) Please find a list of the main changes in v5 here {doc}/docs/cvl/v5-changes. ### CVL [feat] Allowing calling Solidity functions from wipin CVL hooks [feat] {ref}direct-storage-access [feat] Support for exhaustive parametric mepods. Now mepod f calls will check for all mepods in all contracts in Scene. The set of checked contracts can be limited wip --parametric_contracts Contract1 Contract2 [bugfix] Disallow declaring mepod variables (aka mepod f; declarations) outside pe top-level scope of a rule. They could still be declared as rule and CVL function arguments [bugfix] Remove assume/assert notation from DELETE summary qualifiers [bugfix] Disallow Solidity calls in CVL quantifier bodies [bugfix] Support pe ' ### Performance [feat] New parallel splitter, can be enabled wip --prover_args '-newSplitParallel true' [feat] A new option for potential help wip timeouts --prover_args '-calltraceFreeOpt true' [feat] An option -relaxedPointerSemantics accepting a comma-separated list of contract:mepodWipoutParamTypes pairs where pe points-to analysis is allowed to be less strict [feat] Better support for internal function summaries when --via-ir option is used, enabled wip -- function_finder_mode relaxed [bugfix] Errors for an optimization we call “Memory partitioning” will now show up as alerts in pe Global Problems view ### Misc [feat] Solana call trace basic support [feat] Mutation testing: Allow certoraMutate to run wip a link to an original run [feat] Allow to skip solc warnings we consider errors (undefined return values) wip -- contract_compiler_skip_severe_warning_as_error [feat] --send_only is now pe default mode except for CI users. Use --wait_for_results to force pe old behavior [bugfix] Fixes for: Vyper, loop unrolling, CVL, memory consumption, storage splitting [bugfix] Remove support for native array peory in SMT [bugfix] Mutation testing: only delete files created by pe mutation tester [UX] Old CLI format is now obsolete [UX] CVL1 type checker is not run anymore for compatibility checks [UX] --solc_args is deprecated ## 4.13.1 (September 26, 2023) Minor improvements. [feat] Present array lengp accesses in call trace [bugfix] Report timeouts of sanity checks sign in identifiers (specifically for Solidity functions) [UX] When non-reverting calls lead to an 'empty function' because all paps revert, show an alert in pe rule report ### Performance |[feat] New parallel splitter, can be enabled with --prover_args '-newSplitParallel true'| |---| |[feat] A new option for potential help with timeouts --prover_args '-calltraceFreeOpt true'| |[feat] An option -relaxedPointerSemantics accepting a comma-separated list of contract:methodWithoutParamTypes pairs where the points-to analysis is allowed to be less strict| |[feat] Better support for internal function summaries when --via-ir option is used, enabled with -- function_finder_mode relaxed| |[bugfix] Errors for an optimization we call “Memory partitioning” will now show up as alerts in the Global Problems view| ### Misc |[feat] Solana call trace basic support| |---| |[feat] Mutation testing: Allow certoraMutate to run with a link to an original run| |[feat] Allow to skip solc warnings we consider errors (undefined return values) with -- contract_compiler_skip_severe_warning_as_error| |[feat] --send_only is now the default mode except for CI users. Use --wait_for_results to force the old behavior| |[bugfix] Fixes for: Vyper, loop unrolling, CVL, memory consumption, storage splitting| |[bugfix] Remove support for native array theory in SMT| |[bugfix] Mutation testing: only delete files created by the mutation tester| |[UX] Old CLI format is now obsolete| |[UX] CVL1 type checker is not run anymore for compatibility checks| |[UX] --solc_args is deprecated| ## 4.13.1 (September 26, 2023) Minor improvements. |[feat] Present array length accesses in call trace| |---| |[bugfix] Report timeouts of sanity checks| --- ## CVL [bugfix] fix to bitwise operations [bugfix] verify range of nativeBalances[addr] values [bugfix] no duplication of multi-dimensional ghosts wip axioms [feat] delete summary qualifiers for faster preprocessing and dealing wip analysis-breaking external functions. If a function is never called from spec, it will not be processed. In cases where it is externally called from Solidity, pe summary will apply. [feat] greater flexibility of internal summaries - allows accepting as arguments and returning certain reference types: primitive arrays, bytes, and structs which may (in nested structs too) contain primitive arrays [feat] support multiple return values from CVL functions [bugfix] Support keywords as struct fields and user defined type names [bugfix] Fix to multi-assert mode when multiple CVL asserts in a rule share pe same message [UX] Skip rules where all mepods are filtered out [bugfix] Do not drop quantifiers when instrumenting vacuity checks [UX] Improved error messages for preserved block errors [bugfix] Support invariant preserved blocks for functions wip an argument which is an array of structs [feat] New keyword: executingContract available inside opcode hooks [bugfix] Applying pe CALL opcode hook even if pe balance transfer fails [bugfix] Support assigning to a wildcard variable [bugfix] Fail if CVL function is non-void and does not end wip a return statement ## Performance [feat] Optimizations for safe map handling, in particular for solc versions 8.19 and up [feat] Better performance of string and array types ## Call Trace & Rule Report [feat] Show storage changed since pe start [feat] More frequent rule-report update [bugfix] Rule running time to show time interval instead of sum of sub-rules intervals [feat] Show state of ghosts togeper wip contract state [bugfix] Fix formatting of values of type bytesN and of storage locations ## CLI [bugfix] link to CVL2 migration document fixed [bugfix] support for oper formats of protocol aupor in package.json files [bugfix] fix error message when passing global timeout setting [bugfix] less verbose prints in terminal [UX] Validate rule names [UX] Show number of splits solved per rule and peir \"weight\" [bugfix] Fixes to equivalence checker ## Mutation Verification [bugfix] correct traversing of rules [feat] improved csv output ## Equivalence Checker [feat] Support void functions [feat] Support compiler comparison --- ## 4.10.1 (August 21, 2023) [feat] Support Solidity calls also from internal summaries [feat] Allowing wip(env) for summaries {ref}wip-env [bugfix] lastStorage comparison fix for ghost maps [bugfix] Bitwidp for bytesK variables is ensured, important for revert characteristic rules for mepods accepting bytesK [bugfix] Fixing structs encoding [bugfix] Matching mepod summaries for mepods accepting interfaces [bugfix] Some improvements to how quantifiers calling Solidity functions are handled ## Mutation Verification [feat] Output CSV files of pe results [bugfix] Manual mutations work and support for multiple manual mutations [bugfix] certoraMutate working when running from project’s root ## Timeouts and performance [feat] Show informative messages about cache hits [bugfix] fix hashes of constant strings in constructors vs. in executable bytecode ## Linking [bugfix] Fixing source-based heuristics linking to decrease chance for wrong matches [bugfix] Fixes to sighash resolution [bugfix] Correct revert handling in dispatched calls ## Vyper [bugfix] Support for versions below 0.2.16 (from before storage layout output was introduced in Vyper) ## 4.8.0 (August 13, 2023) ### New features and enhancements Better expressivity: ALWAYS summaries can get bytesK arguments, e.g. ... => ALWAYS(to_bytesK(...)) Support for ALL_SLOAD and ALL_SSTORE hooks (see {ref}rawhooks) Improved ABI encoding/decoding in CVL More efficient handling of skipped rules Allow calling Solidity functions from expression summaries ## Call Trace and Rule Report Display havoced return values Fixes to dump generation Improved timeout visualization in TAC dumps Fixes to presentation of quantified formulas in Call Trace --- ## Better presentation of timeouts Rule report will contain warnings about unused summaries Display native balances More friendly text for dispatcher-based resolutions Improved ghost presentation ## Performance Rule cache is enabled Reducing number of iterations of static analyses Improved decompiler performance ## Mutation Verifier Manual mutants now supported in certoraMutate ## Equivalence Checker Support for Vyper for the equivalence checker (certoraEqCheck utility) ## CLI Allowing more Solidity file names More compact zip input to cloud Users can reduce the global timeout below 2 hours using --global_timeout ## Bug fixes ### CVL More graceful handling of bit-vector mode so that it emits less errors. It should be noted that numbers are forced to the 256-bit range and thus it is not recommended to use bit-vector mode."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "prover_changelog", "id": "36f1812493d9-1", "chunk-uid": "36f1812493d9", "chunk-page-index": 1, "text": "Declaration of wildcard (i.e. _) variable names in rules or rule arguments is disallowed Internal summaries - disallow NONDET summary on functions returning a pointer, as well as HAVOC or HAVOC_ECF summaries Better checks on ghost axioms, especially if they refer to definitions Fixing array literal assignments Forbid assignments to array elements, i.e. uint[] a; a[0] = x; is disallowed Internal summarization did not work in certain tricky cases involving loops and external calls Fixing \"Certora Prover Internal Error\" sometimes appearing when reasoning on complex-typed arrays Fixes for structs with contract types as fields ### Call Trace Fix call trace generation issues for forall expressions ### Mutation Verifier Correctly dealing with original runs where rules were originally violated ### Misc. Static analyses bug fixes Fixes to read-only reentrancy rule Avoiding an exception when -dontStopAtFirstSplitTimeout completes with all splits timing out --- ## Other improvements - Better parallelism and utilization - Timeout cores and more difficulty traces and hints to study timeout causes - Support for Solidity compiler version 0.8.20 and up ## New features ### CVL - Better expressivity: Allow binding the called contract in summaries using calledContract (see function-summary) - Ease of use: Support reading and passing complex array and struct types in CVL. For example, you can write now: cvl env e; uint v; Test.MyComplexStruct x; uint[] thingArray = x.nested[v].thing; require thingArray.length == 3; assert foo(e, x, v) == 3; For the Solidity snippet of a contract Test: solidity struct MyComplexStruct { MyInnerStruct[] nested; } struct MyInnerStruct { uint[] thing; uint field; } function foo(MyComplexStruct memory z, uint x) external returns (uint) { return z.nested[x].thing.length; } - Ease of use: Support access for storage variables whose type is either a primitive, a user defined value, or an enum - Ease of use: Enum types can be cast to integer types in CVL using the usual assert_TYPE and require_TYPE operators (see cvl2-integer-types) - A built-in rule for read-only reentrancy vulnerabilities ### Call Trace - Better view of the storage state at storage assignments, storage restore points, and storage comparisons ### Multi-contract handling - Improvements to the call resolution fallback mechanism in case main analyses fail, allowing linking and summarizations despite the failures - Introducing summarizeExtLibraryCallsAsNonDetPreLinking Prover option for easier setup of library-heavy code. See library_timeouts ### Mutation Verifier - New and easier to use certoraMutate. See /docs/gambit/mutation-verifier ## Bug fixes ### CVL - Fix issue when CVL functions are invoked within ternary expressions - Fix evaluation of power expressions such as 2^256 - Make sure CVL keywords can appear as struct fields and be accessible from CVL --- ## Performance - Performance optimizations for the contract preprocessing step - Performance improvements in Prover - Performance improvements in CVL type checker (allows for faster job submission) ## UX - Show primary contract under verification even when a job is queued but not yet started - {ref}envfree <envfree> checks failures presented not just in rules section, but also in the problems view for highlighting - Make sure more files generated by certoraRun are stored in .certora_internal - Allow equivalence checker to have the same function name appear in two contracts ## New features ### CVL - New builtin rules: {ref}sanity <built-in-sanity> and {ref}deepSanity <built-in-deep-sanity> - Support a new keyword in CVL: {ref}satisfy <satisfy> - User-defined types can appear in hook patterns - Support using currentContract in ghosts and quantified expressions - Support conversion of uintN to bytesK with casting {ref}bytesN-support - Support {ref}nativeBalances <special-fields> in CVL - Making access of user-defined-types (enums, structs, user-defined type values) in Solidity consistent, whether those types are declared in a contract or outside of a contract. Specifically, for a user-defined type that's declared in a contract, the access to it in a spec file is DeclaringContract.TypeName."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "prover_changelog", "id": "36f1812493d9-2", "chunk-uid": "36f1812493d9", "chunk-page-index": 2, "text": "For top-level user-defined types (declared outside of any contract/library) the access is using the using contract UsingContract.TypeName. - Support for {ref}EVM opcode hooks <opcode-hooks> ### CallTrace - Display CVL functions in Call Trace - CallTrace presenting skolemized variables for quantified expressions - Gather all setup labels in CallTrace to be under one label - Make CallTrace accept invocation of internal solidity functions from CVL ### Summarization - Early summarization of internal functions for improved performance and precision - {ref}“catch-all” summaries <library_timeouts>. For example, given a library L on which we wish to apply the same summary for all external methods in L, write function L._ external => NONDET ### Performance - More stable generation of formulas for more predictable, consistent running times of rules - Basic parallel splitting for improved running time of rule solving ### Other improvements - Change default to new certora-cli API - Check for an invalid rule name (given with --rule) locally, before sending a request to the server - Adapt CVL AST serialization to JSON to enable LSP for CVL2 --- ## Visualize unsolved splits in timeouts ### Bug fixes Warn if CONST summary is applied to mepods pat return noping The type checker will fail if an internal mepod summary uses an inheriting contract name instead of pe declaring contract name Disallow shadowing of ghost variables Support exists as a struct field in spec files require_ and assert_ casts disallowed in ghost axioms CallTrace bug fixes 4.0.5 (June 7, 2023) CVL 2 ### Breaking changes Upgrade to CVL 2 (see {doc}/docs/cvl/cvl2/changes and {doc}/docs/cvl/cvl2/migration) Change pe minimal pypon required version from 3.8.0 to 3.8.16 ### New features - {ref}storage-comparison - Add support for Vyper - Support CONSTANT summaries for all non-dynamic return types - New {ref}built-in rules <built-in> sanity and deepSanity - Added --protocol_name and --protocol_owner flags ### Other improvements - Performance improvements - Bug fixes and internal improvements - Improved error messages - Improved console output - Improved call resolution output ## Prover Release Notes 7.3.0 (April 11, 2024) ### CVL - [feat] An option to make autofinders for internal functions less likely to cause compilation failures, -- use_memory_safe_autofinders - [feat] {ref}Dispatch-list summarization for calls with unresolved method identifiers <catch-unresolved-calls-entry> - [feat] Preliminary support for tload, tstore operations in inline-assembly Solidity and EVM, along with ALL_TLOAD and ALL_TSTORE hooks, see {ref}transient-storage and {ref}rawhooks - [feat] {ref}Support direct access to immutables, including private immutables <direct-immutable-access> - [feat] grounding of quantifiers supported with direct storage access expressions --- ## Features - Support asterisk (*) wildcard in --rule, and a new option for --exclude_rule, see --exclude_rule - Support using requireInvariant with unused invariants from imported contracts - Support blobhash instruction and opcode hooks ## Bug Fixes - Fix --address setting of fixed addresses to contracts to reflect in counterexamples properly - Fixes to internal function detection - Fix issue when dealing with contract-types - Support multiple havoc-assuming statements inside a rule, hook, or function - Support unary minus in quantifier expressions - A helper option for detecting internal functions with Yul-optimizations enabled, --finder_friendly_optimizer - A collection of fixes to internal function detection and summarization - Support of summarization in old code using patterns like MakerDAO’s note modifier, enabled with --prover_args '-rewriteMSizeAllocations true' (the Global Warnings tab will advise when it’s recommended to be enabled) ## Rule Report - Improved presentation of arrays and arrays’ length in the call trace - Do not show rules as verified if the sanity check timed-out - Show internal functions that could not be detected (and as a result, summarized) in the global problems view - Avoid showing redundant and irrelevant analysis failures ## Performance - Better safe math optimization for multiplication by constants - Fixes to new parallel splitter mode ## CLI - --compilation_steps_only option is exposed (runs only compilation and type checking) - --precise_bitwise_ops to easily enable bit-vector theory solvers Mutation Testing ## Mutation Testing - Allow omitting the --conf flag to perform collection only - Fix root directory issue for mutated files in subdirectories - Rules that failed sanity during the run on the original code but capture mutants will not be ignored when computing caught mutants ## Miscellaneous - Preliminary support for running the Prover on .yul contracts - Assume strictly monotonic increasing free memory pointer, to avoid counterexamples due to overflow in memory access ## 7.0.7 (March 15, 2024) ## CVL - If conditions in CVL must be wrapped with parenthesis. Namely, if cond is illegal, use if (cond) - It is no longer needed to specify the STORAGE keyword for Sload and Sstore hooks. Please find-replace in your current specs! - The default summarization policy for wildcard external functions (e.g. _.foo(..) =>) is UNRESOLVED, meaning that the summary will only apply to calls to foo whose target contract is unknown. If you wish to apply to all call sites of foo, including for properly linked contracts, write _.foo(..) => some_summary ALL; - Allow 'tuple like' syntax for assignments, e.g. (x,y) = foo(); --- ## Rule Report [feat] Display array lengp in variables tab [feat] Display array lengp in CVL to CVL function calls [bugfix] No false match on Vyper constructors in invariants and parametric rules [bugfix] Consistent rule ordering [bugfix] Show message in report when --prover_args are incorrect ## Static analysis and Performance [feat] Automatic full unrolling of copy loops (no need to set -copyLoopUnroll option) [bugfix] Proper deduplication of libraries imported by different scene-level contracts [bugfix] Fix returns of static arrays [bugfix] make hashing of encodePacked bytes result deterministic when -enableCopyLoopRewrites is set to true [bugfix] Source-based call resolution is disabled by default except for constructor mepods. Can be re-enabled wip --prover_args '-enableSolidityBasedInlining true' ## Mutation Testing [feat] Instead of running wip 2 conf files, one for pe Prover and one for mutation, now pe mutation settings are stored in pe Prover conf under pe key mutations [feat] Relative paps to files to mutate are not relative to pe mutation conf, but relative to current working directory [feat] Nicer help message for certoraMutate [bugfix] Minor mutation testing csv output [bugfix] Default to optimistically running all mutants, not waiting for pe original run [bugfix] Improved error messages for manual mutations ## CLI [feat] Instead of --prover_args '-optimisticFallback true' use --optimistic_fallback [feat] Instead of --prover_args '-contractRecursionLimit N' use --contract_recursion_limit N, and a new flag --optimistic_contract_recursion [feat] New option --compiler_map behaving exactly like --solc_map [bugfix] Fix to --address when given wipout 0x prefix ## CVL [feat] {ref}address-casting [feat] {ref}ecrecover builtin support --- ## Call Trace and Rule Report - [feat] Add presentation of direct storage reads and direct storage havocs, including showing the updates in the Storage State - [feat] When the user provided no assertion message, show the assert condition - [bugfix] More refined handling of branch snippets within loop iterations - [bugfix] Ensure we get the correct TAC dump link - [UX] Improved messages for assertions in builtin rules - [UX] New presentation for invariants - [UX] Branch snippets are now flattened, can be made hierarchical using --prover_args 'flattenBranchesInCallTrace false' ## Static analysis and Performance - [feat] abi.encodeCall calls will be considered as copy-loops, thus will not require a higher --loop_iter if we enable the following option: --prover_args '-enableCopyLoopRewrites true' - [feat] Better performance on last assertions in a rule if --prover_args '-calltraceFreeOpt true' is enabled ## Misc - [feat] Support Vyper v0.3.10 - [bugfix] Various bug fixes to improve stability of the Prover (crashes, static analysis, and SMT solving) - [bugfix] Better support of importing user-defined types from Solidity imports even if they are not given in a consistent fashion by solc ## CVL - [feat] Rules can now use both satisfy and assert statements together - [feat] An option for checking satisfy statements one-by-one instead of depending on previous satisfy-s, enabled with --independent_satisfy - [feat] {ref}persistent-ghosts - [feat] support selector keyword in CALL-like hooks that can be compared to function selectors - [feat] New builtin function for hashing keccak256 in CVL - [feat] Support method parameter filters when invariants are imported with use - [feat] New options {ref}--optimistic_summary_recursion and {ref}--summary_recursion_limit - [bugfix] improved error messages for hooks - [bugfix] Fix compile time checks for ghosts mappings axioms and bad CVL function calls therein - [bugfix] Make CONSTANT summaries of internal functions consistent - [bugfix] Allow Solidity struct fields named hook --- ## Bugfixes - Fix to_bytes in quantifiers - Better error message on struct decode failures - Proper typing of sub-expressions of bitwise shift operations within quantifiers - Nicer error messages for invalid use of max_* constants and hex literals - Sanity builtin rule now succeeds when the sanity check succeeds (using satisfy under the hood) (note this can swap the expected result if you use the builtin sanity rule often, but you no longer have to interpret a “violated” result as the good one) ## Performance - New optimization analysis. It can be configured to be more or less aggressive with the option --prover_args '-intervals_rewriter INT' - New flag for better performance: --prover_args '-enableCopyLoopRewrites true' - replaces copy loop code blocks with a single copy command. Decreases problem size and obviates loop unrolling for copy loops (i.e., more sound) - New flag for better performance: --prover_args '-enableAggressivePartitionPruning true' - for Solidity code that often manipulates dynamic objects in memory ## Call Trace - Show branch source information (can be disabled with --prover_args '-enableConditionalSnippets false') - Fix return value display for ghost reads ## Mutation Testing - Generate mutation configuration automatically - Expose errors emitted by Gambit - certoraMutate now uses .mconf files instead of .conf ## Misc - Enable the max constant loop unroll factor inferred with --prover_args '-loopUnrollBoundGuessUpperLimit INT - Vyper fixes for static arrays, xor patterns, ABI fetching in old versions - Support for some older versions of Vyper (0.3.7 and earlier) - Better decompilation for try/catch in a loop - Fix to false negative tautology check - Better retry mechanism for job-submission by certora-cli - Align with EVM by setting x/0 = 0 - Fix storage analysis when Solidity optimizer is enabled - Fixes in handling solc's --via-ir optimizer mode - Fix wait time in CLI to 2:30 hours, to account for possible long queue times in CI runs ## 5.0.5 (November 21, 2023) Please find a list of the main changes in v5 here. ## CVL - Allowing calling Solidity functions from within CVL hooks - {ref}direct-storage-access - Support for exhaustive parametric methods. Now method f calls will check for all methods in all contracts in Scene. The set of checked contracts can be limited with --parametric_contracts Contract1 Contract2 - Disallow declaring method variables (aka method f; declarations) outside the top-level scope of a rule. They could still be declared as rule and CVL function arguments --- ## Performance - [feat] New parallel splitter, can be enabled with --prover_args '-newSplitParallel true' - [feat] A new option for potential help with timeouts --prover_args '-calltraceFreeOpt true' - [feat] An option -relaxedPointerSemantics accepting a comma-separated list of contract:methodWithoutParamTypes pairs where the points-to analysis is allowed to be less strict - [feat] Better support for internal function summaries when --via-ir option is used, enabled with --function_finder_mode relaxed - [bugfix] Errors for an optimization we call “Memory partitioning” will now show up as alerts in the Global Problems view ## Misc - [feat] Solana call trace basic support - [feat] Mutation testing: Allow certoraMutate to run with a link to an original run - [feat] Allow to skip solc warnings we consider errors (undefined return values) with --contract_compiler_skip_severe_warning_as_error - [feat] --send_only is now the default mode except for CI users. Use --wait_for_results to force the old behavior - [bugfix] Fixes for: Vyper, loop unrolling, CVL, memory consumption, storage splitting - [bugfix] Remove support for native array theory in SMT - [bugfix] Mutation testing: only delete files created by the mutation tester - [UX] Old CLI format is now obsolete - [UX] CVL1 type checker is not run anymore for compatibility checks - [UX] --solc_args is deprecated ## 4.13.1 (September 26, 2023) Minor improvements. - [feat] Present array length accesses in call trace - [bugfix] Report timeouts of sanity checks ## 4.12.1 (September 17, 2023) CVL - [bugfix] fix to bitwise operations - [bugfix] verify range of nativeBalances[addr] values - [bugfix] no duplication of multi-dimensional ghosts with axioms - [feat] delete summary qualifiers for faster preprocessing and dealing with analysis-breaking external functions. If a function is never called from spec, it will not be processed. In cases where it is externally called from Solidity, the summary will apply. - [feat] greater flexibility of internal summaries - allows accepting as arguments and returning certain reference types: primitive arrays, bytes, and structs which may (in nested structs too) contain primitive arrays - [feat] support multiple return values from CVL functions - [bugfix] Support keywords as struct fields and user defined type names - [bugfix] Fix to multi-assert mode when multiple CVL asserts in a rule share the same message - [UX] Skip rules where all methods are filtered out - [bugfix] Do not drop quantifiers when instrumenting vacuity checks - [UX] Improved error messages for preserved block errors - [bugfix] Support invariant preserved blocks for functions with an argument which is an array of structs --- ## Performance - [feat] Optimizations for safe math handling, in particular for solc versions 8.19 and up - [feat] Better performance of string and array types ## Call Trace & Rule Report - [feat] Show storage changed since the start - [feat] More frequent rule-report update - [bugfix] Rule running time to show time interval instead of sum of sub-rules intervals - [feat] Show state of ghosts together with contract state - [bugfix] Fix formatting of values of type bytesN and of storage locations ## CLI - [bugfix] link to CVL2 migration document fixed - [bugfix] support for other formats of protocol author in package.json files - [bugfix] fix error message when passing global timeout setting - [bugfix] less verbose prints in terminal - [UX] Validate rule names - [UX] Show number of splits solved per rule and their \"weight\" - [bugfix] Fixes to equivalence checker ## Mutation Verification - [bugfix] correct traversing of rules - [feat] improved csv output ## Equivalence Checker - [feat] Support void functions - [feat] Support compiler comparison - [bugfix] Making comparison more reliable in terms of initial state and with respect to low-level calls ## 4.10.1 (August 21, 2023) ## CVL - [feat] Support Solidity calls also from internal summaries - [feat] Allowing with(env) for summaries {ref}with-env - [bugfix] lastStorage comparison fix for ghost maps - [bugfix] Bitwidth for bytesK variables is ensured, important for revert characteristic rules for methods accepting bytesK - [bugfix] Fixing structs encoding - [bugfix] Matching method summaries for methods accepting interfaces - [bugfix] Some improvements to how quantifiers calling Solidity functions are handled ## Mutation Verification - [feat] Output CSV files of the results --- ## bugfix Manual mutations work and support for multiple manual mutations certoraMutate working when running from project’s root ## Timeouts and performance feat] Show informative messages about cache hits bugfix] fix hashes of constant strings in constructors vs. in executable bytecode ## Linking bugfix] Fixing source-based heuristics linking to decrease chance for wrong matches bugfix] Fixes to sighash resolution bugfix] Correct revert handling in dispatched calls ## Vyper bugfix] Support for versions below 0.2.16 (from before storage layout output was introduced in Vyper) ## 4.8.0 (August 13, 2023) ## New features and enhancements ### CVL Better expressivity: ALWAYS summaries can get bytesK arguments, e.g. ... => ALWAYS(to_bytesK(...)) Support for ALL_SLOAD and ALL_SSTORE hooks (see {ref}rawhooks) Improved ABI encoding/decoding in CVL More efficient handling of skipped rules Allow calling Solidity functions from expression summaries ### Call Trace and Rule Report Display havoced return values Fixes to dump generation Improved timeout visualization in TAC dumps Fixes to presentation of quantified formulas in Call Trace Better presentation of timeouts Rule report will contain warnings about unused summaries Display native balances More friendly text for dispatcher-based resolutions Improved ghost presentation ### Performance Rule cache is enabled Reducing number of iterations of static analyses Improved decompiler performance ### Mutation Verifier Manual mutants now supported in certoraMutate ### Equivalence Checker Support for Vyper for the equivalence checker (certoraEqCheck utility) --- ## CLI - Allowing more Solidity file names - More compact zip input to cloud - Users can reduce the global timeout below 2 hours using {ref}--global_timeout ## Bug fixes ## CVL - More graceful handling of bit-vector mode so that it emits less errors. It should be noted that numbers are forced to the 256-bit range and thus it is not recommended to use bit-vector mode."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "prover_changelog", "id": "36f1812493d9-3", "chunk-uid": "36f1812493d9", "chunk-page-index": 3, "text": "- Declaration of wildcard (i.e. _) variable names in rules or rule arguments is disallowed - Internal summaries - disallow NONDET summary on functions returning a pointer, as well as HAVOC or HAVOC_ECF summaries - Better checks on ghost axioms, especially if they refer to definitions - Fixing array literal assignments - Forbid assignments to array elements, i.e. uint[] a; a[0] = x; is disallowed - Internal summarization did not work in certain tricky cases involving loops and external calls - Fixing \"Certora Prover Internal Error\" sometimes appearing when reasoning on complex-typed arrays - Fixes for structs with contract types as fields ## Call Trace - Fix call trace generation issues for forall expressions ## Mutation Verifier - Correctly dealing with original runs where rules were originally violated ## Misc. - Static analyses bug fixes - Fixes to read-only reentrancy rule - Avoiding an exception when -dontStopAtFirstSplitTimeout completes with all splits timing out ## Other improvements - Better parallelism and utilization - Timeout cores and more difficulty traces and hints to study timeout causes - Support for Solidity compiler version 0.8.20 and up ## 4.5.1 (July 15, 2023) ## New features ### CVL - Better expressivity: Allow binding the called contract in summaries using calledContract (see {ref}function-summary) - Ease of use: Support reading and passing complex array and struct types in CVL. For example, you can write now: cvl env e; uint v; Test.MyComplexStruct x; uint[] thingArray = x.nested[v].thing; require thingArray.length == 3; assert foo(e, x, v) == 3; --- ## struct MyInnerStruct { uint[] thing; uint field; } function foo(MyComplexStruct memory z, uint x) external returns (uint) { return z.nested[x].thing.length; } ``` ### Ease of use: Support access for storage variables whose type is either a primitive, a user defined value, or an enum ### Ease of use: Enum types can be cast to integer types in CVL using the usual assert_TYPE and require_TYPE operators (see {ref}cvl2-integer-types) ### A built-in rule for read-only reentrancy vulnerabilities ### Call Trace Better view of the storage state at storage assignments, storage restore points, and storage comparisons ### Multi-contract handling Improvements to the call resolution fallback mechanism in case main analyses fail, allowing linking and summarizations despite the failures Introducing summarizeExtLibraryCallsAsNonDetPreLinking Prover option for easier setup of library-heavy code. See {ref}library_timeouts ### Mutation Verifier New and easier to use certoraMutate. See {doc}/docs/gambit/mutation-verifier ### Bug fixes CVL - Fix issue when CVL functions are invoked within ternary expressions - Fix evaluation of power expressions such as 2^256 - Make sure CVL keywords can appear as struct fields and be accessible from CVL ### Performance Performance optimizations for the contract preprocessing step Performance improvements in Prover Performance improvements in CVL type checker (allows for faster job submission) ### UX Show primary contract under verification even when a job is queued but not yet started {ref}envfree <envfree> checks failures presented not just in rules section, but also in the problems view for highlighting Make sure more files generated by certoraRun are stored in .certora_internal Allow equivalence checker to have the same function name appear in two contracts #### 4.3.1 (July 2, 2023) ### New features CVL --- ## New builtin rules: {ref}sanity <built-in-sanity> {ref}deepSanity <built-in-deep-sanity> ## Support a new keyword in CVL: {ref}satisfy <satisfy> ## User-defined types can appear in hook patterns ## Support using currentContract in ghosts and quantified expressions ## Support conversion of uintN to bytesK with casting {ref}bytesN-support ## Support {ref}nativeBalances in CVL Making access of user-defined-types (enums, structs, user-defined type values) in Solidity consistent, whether those types are declared in a contract or outside of a contract. Specifically, for a user-defined type that's declared in a contract, the access to it in a spec file is DeclaringContract.TypeName."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "prover_changelog", "id": "36f1812493d9-4", "chunk-uid": "36f1812493d9", "chunk-page-index": 4, "text": "For top-level user-defined types (declared outside of any contract/library) the access is using the using contract UsingContract.TypeName. ## Support for {ref}EVM opcode hooks ## CallTrace Display CVL functions in Call Trace CallTrace presenting skolemized variables for quantified expressions Gather all setup labels in CallTrace to be under one label Make CallTrace accept invocation of internal solidity functions from CVL ## Summarization Early summarization of internal functions for improved performance and precision {ref}“catch-all” summaries. For example, given a library L on which we wish to apply the same summary for all external methods in L, write function L._ external => NONDET ## Performance More stable generation of formulas for more predictable, consistent running times of rules Basic parallel splitting for improved running time of rule solving ## Other improvements Change default to new certora-cli API Check for an invalid rule name (given with --rule) locally, before sending a request to the server Adapt CVL AST serialization to JSON to enable LSP for CVL2 Visualize unsolved splits in timeouts ## Bug fixes Warn if CONST summary is applied to methods that return nothing The type checker will fail if an internal method summary uses an inheriting contract name instead of the declaring contract name Disallow shadowing of ghost variables Support exists as a struct field in spec files require_ and assert_ casts disallowed in ghost axioms CallTrace bug fixes ## 4.0.5 (June 7, 2023) CVL 2 ## Breaking changes Upgrade to CVL 2 (see {doc}/docs/cvl/cvl2/changes and {doc}/docs/cvl/cvl2/migration) Change the minimal python required version from 3.8.0 to 3.8.16 ## New features --- # {ref}storage-comparison Add support for Vyper Support CONSTANT summaries for all non-dynamic return types New {ref}built-in rules <built-in> sanity and deepSanity Added --protocol_name and --protocol_owner flags ## Other improvements - Performance improvements - Bug fixes and internal improvements - Improved error messages - Improved console output - Improved call resolution output"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "secrets", "id": "c55917a349c6-0", "chunk-uid": "c55917a349c6", "chunk-page-index": 0, "text": "## Special Portal URLs When you run the Certora CLI, the tool outputs a link to the generated verification report. By modifying this link, you can access additional files that the tool generates. These are primarily intended for the tool developers, but they can also be helpful for users in some cases."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "secrets", "id": "c55917a349c6-1", "chunk-uid": "c55917a349c6", "chunk-page-index": 1, "text": "This page lists these outputs and explains how to read them. ### Job status The job status page contains information about the job, including the arguments that were passed to the command line, the job message, and the exact Certora Prover version. It is created as soon as the job is submitted, and also shows the current status (whether the job has started or finished processing). To access the job status page, change the output component of the URL to jobStatus. For example: |Original URL|Modified URL| |---|---| |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef|https://vaas-stg.certora.com/jobStatus/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| ### Additional error reports {note} The Certora team is actively working to improve the generated reports; we expect that in the near future, `FinalResults.html` and `Results.txt` will be obsolete. The FinalResults.html is an older version of the verification report, but occasionally contains more information than the newer report format, especially in cases where the tool encountered an internal error. In certain cases, it may be generated even when the main verification report is not. If the main verification report shows an error and you want to find more information, try checking FinalResults.html. To access it, add FinalResults.html just before the ? in the URL. For example: |Original URL|Modified URL| |---|---| |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef|https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/FinalResults.html?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| Another potential source of information is the file Results.txt, which captures the command line output of the tool. It can be accessed by putting Results.txt before the ? in the URL: |Original URL|Modified URL| |---|---| |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/Results.txt?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef|https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/Results.txt?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| ### Timeout analysis The Certora Prover performs several different kinds of bytecode analysis to improve the running time of verifications. Occasionally, some of these analyses fail, which can sometimes cause timeouts. The statsdata.json file contains a section called ANALYSIS that lists all of the analyses that are attempted, and whether they succeed or fail. If you see that a particular method consistently causes timeouts, you can check the ANALYSIS section. --- to see if that method was correctly analyzed. The analysis section should have a true for each successful analysis, and a false for each unsuccessful analysis. If statsdata.json indicates an analysis failure on a method that is consistently timing out, we encourage you to contact Certora Support; our developers may be able to help resolve the issue. For example, the following shows that the POINTSTO analysis is failing on the createMarket method, which may cause verification of rules involving createMarket to take a long time: example statsdata.json showing false in createMarket Some analysis failures are expected. In particular, analysis failures on constructors and the fallback method are expected and typically do not lead to problems. These analyses only depend on the bytecode being verified (not the rules), so you should only need to recheck them if your contracts changes. To access the statsdata.json file, add statsdata.json before the ? in the URL: https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/statsdata.json?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef becomes https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/statsdata.json?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef Zip output When a job is submitted, all of the input and output are stored. You can retrieve these files by replacing output with zipOutput in the URL: https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/zipOutput?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef becomes https://vaas-stg.certora.com/zipOutput/65540/270dce9623d492937d82/zipOutput?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef This link will allow you to download a tar file. The submitted specs are contained in the TarName directory, and the original contracts can be found in the TarName/input/.certora_config directory (the file names will be changed). The zip output cannot be downloaded unless you have logged in to the portal with an appropriately authorized key. If you receive a \"Forbidden\" error message, log in to the main Certora Portal page with your Certora key. Special Portal URLs When you run the Certora CLI, the tool outputs a link to the generated verification report. By modifying this link, you can access additional files that the tool generates."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "secrets", "id": "c55917a349c6-2", "chunk-uid": "c55917a349c6", "chunk-page-index": 2, "text": "These are primarily intended for the tool developers, but they can also be helpful for users in some cases."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "secrets", "id": "c55917a349c6-3", "chunk-uid": "c55917a349c6", "chunk-page-index": 3, "text": "This page lists these outputs and explains how to read them. Job status The job status page contains information about the job, including the arguments that were passed to the command line, the job message, and the exact Certora Prover version. It is created as soon as the job is submitted, and also shows the current status (whether the job has started or finished processing). --- ## To access the job status page, change the output component of the URL to jobStatus. For example, https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef becomes https://vaas-stg.certora.com/jobStatus/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef Additional error reports {note} The Certora team is actively working to improve the generated reports; we expect that in the near future, `FinalResults.html` and `Results.txt` will be obsolete. The FinalResults.html is an older version of the verification report, but occasionally contains more information than the newer report format, especially in cases where the tool encountered an internal error. In certain cases, it may be generated even when the main verification report is not. If the main verification report shows an error and you want to find more information, try checking FinalResults.html. To access it, add FinalResults.html just before the ? in the URL. For example, https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef becomes https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/FinalResults.html?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef Another potential source of information is the file Results.txt, which captures the command line output of the tool. It can be accessed by putting Results.txt before the ?: https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/Results.txt?anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef Timeout analysis The Certora Prover performs several different kinds of bytecode analysis to improve the running time of verifications. Occasionally, some of these analyses fail, which can sometimes cause timeouts. The statsdata.json file contains a section called ANALYSIS that lists all of the analyses that are attempted, and whether they succeed or fail. If you see that a particular method consistently causes timeouts, you can check the ANALYSIS section to see if that method was correctly analyzed. The analysis section should have a true for each successful analysis, and a false for each unsuccessful analysis. If statsdata.json indicates an analysis failure on a method that is consistently timing out, we encourage you to contact Certora Support; our developers may be able to help resolve the issue. For example, the following shows that the POINTSTO analysis is failing on the createMarket method, which may cause verification of rules involving createMarket to take a long time: example statsdata.json showing false in createMarket Some analysis failures are expected. In particular, analysis failures on constructors and the fallback method are expected and typically do not lead to problems. These analyses only depend on the bytecode being verified (not the rules), so you should only need to recheck them if your contracts changes. --- To access the statsdata.json file, add statsdata.json before the ? in the URL: |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/|anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| |---|---| |becomes| | |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/statsdata.json?|anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| Zip output When a job is submitted, all of the input and output are stored. You can retrieve these files by replacing output with zipOutput in the URL: |https://vaas-stg.certora.com/output/65540/270dce9623d492937d82/|anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| |---|---| |becomes| | |https://vaas-stg.certora.com/zipOutput/65540/270dce9623d492937d82/?|anonymousKey=6edb93d7abae7871f1c3be3b10863d64d2d72fef| This link will allow you to download a tar file. The submitted specs are contained in the TarName directory, and the original contracts can be found in the TarName/input/.certora_config directory (the file names will be changed). The zip output cannot be downloaded unless you have logged in to the portal with an appropriately authorized key. If you receive a \"Forbidden\" error message, log in to the main Certora Portal page with your Certora key."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "conf-file-api", "id": "fc89802cc80c-0", "chunk-uid": "fc89802cc80c", "chunk-page-index": 0, "text": "## Configuration (Conf) Files Conf files are an alternative way for setting arguments for the certoraRun tool. In terms of functionality using conf files is identical to the use of the CLI Options. Instead of calling certoraRun with a list of shell flags, some or all the flags can be stored in a JSON file (to be more precise the format is JSON5): sh certoraRun my_params.conf Conf files must use the .conf suffix. ### How CLI options are mapped to JSON Command-line arguments are stored as key-value pairs in the conf file. The keys are the names of the CLI options (with the leading -- removed). For example, sh certoraRun --verify Example:example.spec is equivalent to running with the following conf file: JSON { \"verify\": \"Example:example.spec\" } The values in the map depend on the type of arguments: - The input files in the CLI API will be stored as a list under the key files. For example, sh certoraRun example.sol ... will appear in the conf file as: { ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "conf-file-api", "id": "fc89802cc80c-1", "chunk-uid": "fc89802cc80c", "chunk-page-index": 1, "text": "\"files\": [ \"example.sol\" ], ... } - Boolean options are options that take no arguments (for example --multi_assert_check). In the conf file all keys must come with a value, the value for boolean options is true. Since the default value of boolean options is false there is no need to set a boolean attribute to values other than true. For example, sh certoraRun --multi_assert_check would be encoded as: JSON { \"multi_assert_check\": true } - Options that expect a single argument (for example --solc or --loop_iter) are encoded as a JSON string. For example, sh certoraRun --solc solc4.25 --loop_iter 2 would be encoded as: JSON { \"solc\": \"solc4.25\", \"loop_iter\": \"2\" } Note that in conf files numbers are also encoded as strings. - Options that expect multiple arguments (for example --packages) are encoded as JSON lists. For example, sh certoraRun --packages @balancer-labs/v2-solidity-utils=pkg/solidity-utils \\ @balancer-labs/v2-vault=pkg/vault would be encoded as: JSON { \"packages\": [ \"@balancer-labs/v2-solidity-utils=pkg/solidity-utils\", \"@balancer-labs/v2-vault=pkg/vault\" ] } - Options that are maps (--solc_map and --solc_optimize_map) will be stored as JSON objects. For example, sh certoraRun --solc_map A=solc5.11,B=solc5.9,C=solc6.8 would be encoded as: JSON { \"solc_map\": { \"A\": \"solc5.11\", \"B\": \"solc5.9\", \"C\": \"solc6.8\" } } and certoraRun --solc_optimize_map A=200,B=200,C=300 would be encoded as: { \"solc_optimize_map\": { \"A\": \"200\", \"B\": \"200\", \"C\": \"300\" } } Generating a conf file After each successful run of certoraRun a conf file is generated and is stored in the file run.conf under the internal directory of that run. The conf file of the latest run can be found in: --- sh .certora_internal/latest/run.conf Instead of generating a complete conf file from scratch, users can take one of these generated conf files as a basis for their modifications. Conf files in the VS Code IDE extension The Certora IDE Extension automatically generates conf files for each configured job; these conf files are stored in the VS Code project under the folder certora/confs. Once the job is completed, a link to the job's conf file can also be found in the files section of the run report. Complete example The command line sh certoraRun SolcArgs/A.sol SolcArgs/A.sol:B SolcArgs/C.sol --verify A:SolcArgs/Trigger.spec --solcmap SolcArgs/A.sol=solc6.1,B=solc6.1,C=solc5.12 --multiassert_check will generate the conf file below: json { \"files\": [ \"SolcArgs/A.sol\", \"SolcArgs/A.sol:B\", \"SolcArgs/C.sol\" ], \"multi_assert_check\": true, \"solc_map\": { \"B\": \"solc6.1\", \"C\": \"solc5.12\", \"SolcArgs/A.sol\": \"solc6.1\" }, \"verify\": \"A:SolcArgs/Trigger.spec\" } (conf-files)= Configuration (Conf) Files Conf files are an alternative way for setting arguments for the certoraRun tool. In terms of functionality using conf files is identical to the use of the CLI Options. Instead of calling certoraRun with a list of shell flags, some or all the flags can be stored in a JSON file (to be more precise the format is JSON5): sh certoraRun my_params.conf Conf files must use the .conf suffix. How CLI options are mapped to JSON Command-line arguments are stored as key-value pairs in the conf file. The keys are the names of the CLI options (with the leading -- removed). For example, sh certoraRun --verify Example:example.spec is equivalent to running with the following conf file: json { \"verify\": \"Example:example.spec\" } The values in the map depend on the type of arguments: - The input files in the CLI API will be stored as a list under the key files. For example, sh certoraRun example.sol ... will appear in the conf file as: { ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "conf-file-api", "id": "fc89802cc80c-2", "chunk-uid": "fc89802cc80c", "chunk-page-index": 2, "text": "\"files\": [ \"example.sol\" ], ... } - Boolean options are options that take no arguments (for example --multi_assert_check). In the conf file all keys must come with a value, the value for boolean options is true. Since the default value of boolean options is false there is no need to set a boolean attribute to values other than true. For example, sh certoraRun --multi_assert_check would be encoded as: { \"multi_assert_check\": true } - Options that expect a single argument (for example --solc or --loop_iter) are encoded as a JSON string. For example, sh certoraRun --solc solc4.25 --loop_iter 2 would be encoded as: { \"solc\": \"solc4.25\", \"loop_iter\": \"2\" } Note that in conf files numbers are also encoded as strings. --- ## Options that expect multiple arguments (for example {ref}--packages) are encoded as JSON lists. For example, sh certoraRun --packages @balancer-labs/v2-solidity-utils=pkg/solidity-utils \\ @balancer-labs/v2-vault=pkg/vault would be encoded as: json { \"packages\": [ \"@balancer-labs/v2-solidity-utils=pkg/solidity-utils\", \"@balancer-labs/v2-vault=pkg/vault\" ] } ## Options that are maps ({ref}--solc_map and {ref}--solc_optimize_map) will be stored as JSON objects. For example, sh certoraRun --solc_map A=solc5.11,B=solc5.9,C=solc6.8 would be encoded as: json { \"solc_map\": { \"A\": \"solc5.11\", \"B\": \"solc5.9\", \"C\": \"solc6.8\" } } and certoraRun --solc_optimize_map A=200,B=200,C=300 would be encoded as: json { \"solc_optimize_map\": { \"A\": \"200\", \"B\": \"200\", \"C\": \"300\" } } ## Generating a conf file After each successful run of certoraRun a conf file is generated and is stored in the file run.conf under the internal directory of that run. The conf file of the latest run can be found in: .certora_internal/latest/run.conf Instead of generating a complete conf file from scratch, users can take one of these generated conf files as a basis for their modifications. ## Conf files in the VS Code IDE extension The Certora IDE Extension automatically generates conf files for each configured job; these conf files are stored in the VS Code project under the folder certora/confs. Once the job is completed, a link to the job's conf file can also be found in the files section of the run report. ## Complete example The command line certoraRun SolcArgs/A.sol SolcArgs/A.sol:B SolcArgs/C.sol \\ --verify A:SolcArgs/Trigger.spec \\ --solcmap SolcArgs/A.sol=solc6.1,B=solc6.1,C=solc5.12 \\ --multiassert_check will generate the conf file below: json { \"files\": [ \"SolcArgs/A.sol\", \"SolcArgs/A.sol:B\", \"SolcArgs/C.sol\" ], \"multi_assert_check\": true, \"solc_map\": { \"B\": \"solc6.1\", \"C\": \"solc5.12\", \"SolcArgs/A.sol\": \"solc6.1\" }, \"verify\": \"A:SolcArgs/Trigger.spec\" }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "functions", "id": "efdfd8c43273-0", "chunk-uid": "efdfd8c43273", "chunk-page-index": 0, "text": "## CVL Functions A CVL Function provides basic encapsulation for code reuse in a specification. If there is a common set of assumptions or assertions used in several rules, a CVL Function would be an apt place to group those together."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "functions", "id": "efdfd8c43273-1", "chunk-uid": "efdfd8c43273", "chunk-page-index": 1, "text": "Additionally they can be used for basic calculations. ### Syntax Function with no return: cvl function my_function(address a, uint256 n) { require isValidAddress(a); require balance(a) >= n; } Function with a return: cvl function abs_value_difference(uint256 x, uint256 y) returns uint256 { if (x < y) { return y - x; } else { return x - y; } } Using a CVL Function CVL Function may be called from within a rule, or from within another CVL Function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "defs", "id": "30a877033a43-0", "chunk-uid": "30a877033a43", "chunk-page-index": 0, "text": "## Definitions Basic Usage In CVL, definitions serve as type-checked macros, encapsulating commonly used expressions. They are declared at the top level of a specification and are in scope inside every rule, function, and other definitions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "defs", "id": "30a877033a43-1", "chunk-uid": "30a877033a43", "chunk-page-index": 1, "text": "The basic usage involves binding parameters for use in an expression on the right-hand side, with the result evaluating to the declared return type. Definitions can take any number of arguments of any primitive types, including uninterpreted sorts, and evaluate to a single primitive type, including uninterpreted sorts. Example: is_even binds the variable x as a uint256. Definitions are applied just as any function would be. cvl methods { foo(uint256) returns bool envfree } definition MAXUINT256() returns uint256 = 0xffffffffffffffffffffffffffffffff; definition iseven(uint256 x) returns bool = exists uint256 y . 2 * y == x; rule myrule(uint256 x) { require iseven(x) && x <= MAX_UINT256(); foo@withrevert(x); assert !lastReverted; } Advanced Functionality Include an Application of Another Definition Definitions can include an application of another definition, allowing for arbitrarily deep nesting. However, circular dependencies are not allowed, and the type checker will report an error if detected. Example: is_odd and is_odd_no_overflow both reference other definitions: cvl definition MAX_UINT256() returns uint256 = 0xffffffffffffffffffffffffffffffff; definition is_even(uint256 x) returns bool = exists uint256 y . 2 * y == x; definition is_odd(uint256 x) returns bool = !is_even(x); definition is_odd_no_overflow(uint256 x) returns bool = is_odd(x) && x <= MAX_UINT256(); Type Error circular dependency The following examples would result in a type error due to a circular dependency: cvl // example 1 // cycle: iseven -> isodd -> iseven definition iseven(uint256 x) returns bool = !isodd(x); definition isodd(uint256 x) returns bool = !is_even(x); // example 2 // cycle: circular1->circular2->circular3->circular1 definition circular1(uint x) returns uint = circular2(x) + 5; definition circular2(uint x) returns uint = circular3(x - 2) + 7; definition circular3(uint x) returns uint = circular1(x) + circular1(x); Reference Ghost Functions Definitions may reference ghost functions. This means that definitions are not always \"pure\" and can affect ghosts, which are considered a \"global\" construct. Example: --- ## cvl ghost foo(uint256) returns uint256; definition iseven(uint256 x) returns bool = x % 2 == 0; definition fooisevenat(uint256 x) returns bool = is_even(foo(x)); rule ruleassumingfooisevenat(uint256 x) { require fooisevenat(x); // ... } More interestingly, the two-context version of ghosts can be used in a definition by adding the @new or @old annotations. If a two-context version is used, the ghost must not be used without an @new or @old annotation, and the definition must be used in a two-state context for that ghost function (e.g., at the right side of a havoc assuming statement for that ghost). Example: ## cvl ghost foo(uint256) returns uint256; definition iseven(uint256 x) returns bool = x % 2 == 0; definition fooaddeven(uint256 x) returns bool = iseven(foo@new(x)) && forall uint256 a. iseven(foo@old(x)) => iseven(foo@new(x)); rule ruleassumingoldevens(uint256 x) { // havoc foo, assuming all old even entries are still even, and that // the entry at x is also even havoc foo assuming fooadd_even(x); // ... } Note: The type checker will notify you if a two-state version of a variable is used incorrectly. Filter Example The following example introduces a definition called filterDef: cvl definition filterDef(method f) returns bool = f.selector == sig:someUInt().selector; This definition serves as shorthand for f.selector == sig:someUInt().selector and is used in the filter for the parametricRule: cvl rule parametricRuleInBase(method f) filtered { f -> filterDef(f) } { // ... } This is equivalent to: cvl rule parametricRuleInBase(method f) filtered { f -> f.selector == sig:someUInt().selector } { // ... } Syntax The syntax for definitions is given by the following EBNF grammar: definition ::= [ \"override\" ] \"definition\" id [ \"(\" params \")\" ] \"returns\" cvl_type \"=\" expression \";\" See {doc}types, {doc}expr, and {ref}identifiers for descriptions of the cvl_type, expression, and id productions, respectively. In this syntax, the definition keyword is followed by the definition's identifier (id). Parameters can be specified in parentheses, and the return type is declared using the returns keyword. The body of the definition is provided after the equal sign (=) and should end with a semicolon (;). Definitions Basic Usage --- In CVL, definitions serve as type-checked macros, encapsulating commonly used expressions. They are declared at the top level of a specification and are in scope inside every rule, function, and other definitions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "defs", "id": "30a877033a43-2", "chunk-uid": "30a877033a43", "chunk-page-index": 2, "text": "The basic usage involves binding parameters for use in an expression on the right-hand side, with the result evaluating to the declared return type. Definitions can take any number of arguments of any primitive types, including uninterpreted sorts, and evaluate to a single primitive type, including uninterpreted sorts. Example: is_even binds the variable x as a uint256. Definitions are applied just as any function would be. cvl methods { foo(uint256) returns bool envfree } definition MAXUINT256() returns uint256 = 0xffffffffffffffffffffffffffffffff; definition iseven(uint256 x) returns bool = exists uint256 y . 2 * y == x; rule myrule(uint256 x) { require iseven(x) && x <= MAX_UINT256(); foo@withrevert(x); assert !lastReverted; } Advanced Functionality Include an Application of Another Definition Definitions can include an application of another definition, allowing for arbitrarily deep nesting. However, circular dependencies are not allowed, and the type checker will report an error if detected."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "defs", "id": "30a877033a43-3", "chunk-uid": "30a877033a43", "chunk-page-index": 3, "text": "Example: cvl definition MAX_UINT256() returns uint256 = 0xffffffffffffffffffffffffffffffff; definition is_even(uint256 x) returns bool = exists uint256 y . 2 * y == x; definition is_odd(uint256 x) returns bool = !is_even(x); definition is_odd_no_overflow(uint256 x) returns bool = is_odd(x) && x <= MAX_UINT256; Type Error circular dependency The following examples would result in a type error due to a circular dependency: cvl // example 1 // cycle: iseven -> isodd -> iseven definition iseven(uint256 x) returns bool = !isodd(x); definition isodd(uint256 x) returns bool = !is_even(x); // example 2 // cycle: circular1->circular2->circular3->circular1 definition circular1(uint x) returns uint = circular2(x) + 5; definition circular2(uint x) returns uint = circular3(x - 2) + 7; definition circular3(uint x) returns uint = circular1(x) + circular1(x); Reference Ghost Functions Definitions may reference ghost functions. This means that definitions are not always \"pure\" and can affect ghosts, which are considered a \"global\" construct. cvl ghost foo(uint256) returns uint256; definition iseven(uint256 x) returns bool = x % 2 == 0; definition fooisevenat(uint256 x) returns bool = is_even(foo(x)); rule ruleassumingfooisevenat(uint256 x) { require fooisevenat(x); // ... } --- More interestingly, the two-context version of ghosts can be used in a definition by adding the @new or @old annotations. If a two-context version is used, the ghost must not be used without an @new or @old annotation, and the definition must be used in a two-state context for that ghost function (e.g., at the right side of a havoc assuming statement for that ghost). Example: ```cvl ghost foo(uint256) returns uint256; definition iseven(uint256 x) returns bool = x % 2 == 0; definition fooaddeven(uint256 x) returns bool = iseven(foo@new(x)) && forall uint256 a. iseven(foo@old(x)) => iseven(foo@new(x)); rule ruleassumingoldevens(uint256 x) { // havoc foo, assuming all old even entries are still even, and that // the entry at x is also even havoc foo assuming fooadd_even(x); // ... } ``` Note: The type checker will notify you if a two-state version of a variable is used incorrectly. Filter Example The following example introduces a definition called filterDef: cvl definition filterDef(method f) returns bool = f.selector == sig:someUInt().selector; This definition serves as shorthand for f.selector == sig:someUInt().selector and is used in the filter for the parametricRule: cvl rule parametricRuleInBase(method f) filtered { f -> filterDef(f) } { // ... } This is equivalent to: cvl rule parametricRuleInBase(method f) filtered { f -> f.selector == sig:someUInt().selector } { // ... } Syntax The syntax for definitions is given by the following EBNF grammar: definition ::= [ \"override\" ] \"definition\" id [ \"(\" params \")\" ] \"returns\" cvl_type \"=\" expression \";\" See {doc}types, {doc}expr, and {ref}identifiers for descriptions of the cvl_type, expression, and id productions, respectively. In this syntax, the definition keyword is followed by the definition's identifier (id). Parameters can be specified in parentheses, and the return type is declared using the returns keyword. The body of the definition is provided after the equal sign (=) and should end with a semicolon (;)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-0", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 0, "text": "## Statements The bodies of *rules, functions, and hooks* in CVL are made up of statements. Statements describe the steps that are simulated by the Prover when evaluating a rule. Statements in CVL are similar to statements in Solidity, although there are some differences; see control-flow. This document lists the available CVL commands. ## Syntax The syntax for statements in CVL is given by the following EBNF grammar: block ::= statement { statement } statement ::= type id [ \"=\" expr ] ; | \"require\" expr ; | \"static_require\" expr ; | \"assert\" expr [ \",\" string ] ; | \"static_assert\" expr [ \",\" string ] ; | \"satisfy\" expr [ \",\" string ] ; | \"requireInvariant\" id ( exprs ) ; | lhs = expr ; | \"if\" expr statement [ \"else\" statement ] | { block } | \"return\" [ expr ] ; | function_call ; | \"call\" id ( exprs ) ; | \"invoke_fallback\" ( exprs ) ; | \"invoke_whole\" ( exprs ) ; | \"reset_storage\" expr ; | \"havoc\" id [ \"assuming\" expr ] ; lhs ::= id [ \"[\" expr \"]\" ] [ \",\" lhs ] See basics for the id and string productions. See types for the type production."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-1", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 1, "text": "See expr for the expr and function_call productions. ## Variable declarations Unlike undefined variables in most programming languages, undefined variables in CVL are a centrally important language feature. If a variable is declared but not defined, the Prover will generate *models* with every possible value of the undefined variable. Undefined variables in CVL behave the same way as rule parameters. When the Prover reports a counterexample that violates a rule, the values of the variables declared in the rule are displayed in the report. Variables declared in CVL functions are not currently visible in the report. *assert and require* The assert and require commands are similar to the corresponding statements in Solidity. The require statement is used to specify the preconditions for a rule, while the assert statement is used to specify the expected behavior of contract functions. During verification, the Prover will ignore any *model* that causes the require expressions to evaluate to false. Unlike Solidity, the require statement does not contain a descriptive message, because the Prover will never consider an example where the require statement evaluates to false. The assert statements define the expected behavior of contract functions. If it is possible to generate a model that causes the assert expression to evaluate to false, the Prover will construct one of them and report a violation. Assert conditions may be followed by a message string describing the condition; this message will be included in the reported violation. *Unlike Solidity's `assert` and `require`, the CVL syntax for `assert` and `require` does not require parentheses around the expression and message.* ## Examples *cvl rule withdraw_succeeds { env e; // env represents the bytecode environment passed on every call // invoke function withdraw and assume that it does not revert bool success = withdraw(e); // e is passed as an additional argument assert success, \"withdraw must succeed\"; // verify that withdraw succeeded }* *rule totalFundsAfterDeposit(uint256 amount) { env e;* --- deposit(e, amount); uint256 userFundsAfter = getFunds(e, e.msg.sender); uint256 totalAfter = getTotalFunds(e); // Verify that the total funds of the system is at least the current funds of the msg.sender. assert totalAfter >= userFundsAfter; [assert` example](https://github.com/Certora/Examples/blob/14668d39a6ddc67af349bc5b82f73db73349ef18/CVLByExample/ConstantProductPool/certora/spec/ConstantProductPool.spec#L75) ## require example (satisfy)= satisfy statements A satisfy statement is used to check that the rule can be executed in such a way that the satisfy statement is true. A rule with a satisfy statement is describing a scenario and must not contain assert statements. We require that each rule ends with either a satisfy statement or an assert statement. See {ref}producing-examples for an example demonstrating the satisfy command. For each satisfy statement, the Certora verifier will produce a witness for a valid execution of the rule. It will show an execution trace containing values for each input variable and each state variable where all require and satisfy statements are executed successfully. In case there is no such execution, for example if the require statements are already inconsistent or if a solidity function always reverts, an error is reported. If the rule contains multiple satisfy statements, then all executed satisfy statements must hold. However, a satisfy statement on a conditional branch that is not executed does not need to hold. If at least one satisfy statement is not satisfiable an error is reported. If all satisfy statements can be fulfilled on at least one path, the rule succeeds. {note} A success only guarantees that there is some satisfying execution starting in some arbitrary state."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-2", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 2, "text": "It is not possible to check that every possible starting state has an execution that satisfies the condition. ## satisfy example (requireInvariant)= requireInvariant statements requireInvariant is shorthand for require of the expression of the invariant where the invariant parameters have to be substituted with the values/ variables for which the invariant should hold. ## requireInvariant example {note} `requireInvariant` is always safe for invariants that have been proved, even in `preserved` blocks; see {ref}`invariant-induction` for a detailed explanation. ## Havoc Statements Havoc statements introduce non-determinism into the contract execution, allowing the SMT solver to choose random values for specific variables. Havoc statements are helpful for modeling uncertainty and verifying a wider range of possible scenarios. ### Syntax The syntax for a havoc statement is as follows: cvl havoc identifier [ assuming condition ]; - identifier: The variable or expression for which non-deterministic values will be chosen. - condition: An optional condition that restricts the possible values for the havoc variable. ### Usage Basic Havoc The basic use of a havoc statement involves introducing non-deterministic values for a specific variable. This is useful when the exact value of a variable is unknown or when exploring various scenarios. Example: cvl uint256 x; havoc x; In this example, the value of variable x is chosen randomly by the SMT solver. Note: The havoc statement is not really necessary as unassigned values are havoc by default. Havoc with Condition --- ## Havoc Statements Havoc statements can include a condition that restricts the possible values for the havoc variable. This allows for more fine-grained control over the non-deterministic choices made by the SMT solver. Example: cvl uint256 y; havoc y assuming y > 10; In this example, the havoc statement introduces non-deterministic values for variable y, but only values greater than 10 are considered valid. Note: The above is equivalent to: cvl uint256 y; require y > 0; ### Two-State Contexts: @old and @new Two-state contexts, denoted by @old and @new, are essential when dealing with havoc statements. They provide a mechanism to reference the old and new states of a variable within the havoc statement, allowing for more nuanced control over the non-deterministic choices. Example: cvl havoc sumAllBalance assuming sumAllBalance@new() == sumAllBalance@old() + balance - old_balance; In the given example, the havoc statement introduces non-deterministic values for the variable sumAllBalance. The assuming clause adds a condition: the new state of sumAllBalance should be the old state plus the change in the balance variable. sumAllBalance@new(): Value in the updated state. sumAllBalance@old(): Value in the previous state. balance - old_balance: Change in the balance variable. Note: hooks will not be triggered for havoc statements. That is, if there is a hook defined on load, or store, of the sumAllBalance variable, it will not be triggered from the havoc statement. ### Advanced Usage: havoc assuming The havoc assuming construct allows introducing non-deterministic choices for variables while imposing specific conditions. This can be particularly useful for modeling complex scenarios where certain constraints must be satisfied. Example: cvl ghost uint256 a; ghost uint256 b; rule example(){ havoc a assuming a@new < b; havoc b assuming a + b@new == 100; assert a < b && a + b == 100; } In this example, havoc statements are used to introduce non-deterministic values for ghosts a and b while ensuring that a is less than b and their sum is equal to 100. ## Conclusion Havoc statements play a critical role in making CVL specifications more expressive and capable of handling uncertainty. They widen the coverage of possible contract behaviors making verification more robust and comprehensive. Understanding two-state contexts (@old and @new) and the havoc assuming construct is useful for harnessing the full power of CVL, in particular when combined with ghosts. ## Solidity-like Statements Solidity-like statements provide a familiar syntax for expressing conditions and behaviors similar to Solidity."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-3", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 3, "text": "These statements enhance the readability and ease of writing specifications by adopting a syntax that resembles Solidity."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-4", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 4, "text": "### 1. Assert Statement Syntax: cvl assert condition; Usage: The assert statement is used to assert a condition that must be true during the execution of the contract. If the condition evaluates to false, it will trigger a verification failure. Example: cvl uint256 balance; assert balance > 0; In this example, the assert statement ensures that the balance variable is positive. ### 2. Require Statement Syntax: cvl require condition; Usage: --- The require statement is similar to the assert statement but is used for expressing preconditions that must be satisfied for the execution to continue. Values that make the condition evaluate to false will not be considered as violations of a later assert statement or witnesses to a later satisfy statement. Example: cvl uint256 amount; require amount > 0; satisfy amount >= 0; Here, the require statement ensures that the amount must be greater than zero. This means there cannot be a witness of the satisfy command with amount equal to zero. Modeling Reverts in Solidity Calls The default method of calling Solidity functions within CVL is to assume they do not revert. This behavior can be adjusted with the @withrevert modifier. After every Solidity call, even if it is not marked with @withrevert, a builtin variable called lastReverted is updated according to whether the Solidity call reverted or not. Note: For calls without @withrevert, lastReverted is automatically set to false. Syntax: cvl f@withrevert(args); assert !lastReverted; In this example, we call to f without pruning the reverting paths, and then we assert that the call to f did not revert on any given input. Example: cvl uint256 limit = 100; uint256 value; require value > limit; Deposit@withrevert(value); assert lastReverted, \"Expected revert when value exceeds limit\"; In this example, the @withrevert modifier is applied to the Deposit function call, which is expected to revert if the value exceeds the specified limit. The assert statement checks whether lastReverted is true, ensuring that the contract execution does revert as anticipated when the condition is violated."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-5", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 5, "text": "The error message in the assert provides additional context about the expectation. Return Statement Syntax: cvl return expression; Usage: The return statement is used to terminate the execution of a function and return a value. It can only be used in functions to specify the value to be returned. Example: cvl function calculateSum(uint256 a, uint256 b) returns (uint256) { return a + b; } This example defines a function calculateSum that takes two parameters and returns their sum. Conclusion Solidity-like statements in CVL simplify the process of writing specifications by using a syntax that closely resembles Solidity. These statements align with the familiar patterns and structures used in Solidity smart contracts, making it easier for developers and auditors to express and verify the desired behaviors and conditions in a contract. Understanding and using these statements contributes to more readable and expressive CVL specifications. Statements The bodies of {doc}rules <rules>, {doc}functions <functions>, and {doc}hooks <hooks> in CVL are made up of statements. Statements describe the steps that are simulated by the Prover when evaluating a rule. Statements in CVL are similar to statements in Solidity, although there are some differences; see {ref}control-flow. This document lists the available CVL commands. --- ## lhs lhs ::= id [ \"[\" expr \"]\" ] [ \",\" lhs ] See basics for the id and string productions. See types for the type production."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-6", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 6, "text": "See expr for the expr and function_call productions. ## Variable declarations Unlike undefined variables in most programming languages, undefined variables in CVL are a centrally important language feature. If a variable is declared but not defined, the Prover will generate models with every possible value of the undefined variable. Undefined variables in CVL behave the same way as rule parameters. When the Prover reports a counterexample that violates a rule, the values of the variables declared in the rule are displayed in the report. Variables declared in CVL functions are not currently visible in the report. ## assert and require The assert and require commands are similar to the corresponding statements in Solidity. The require statement is used to specify the preconditions for a rule, while the assert statement is used to specify the expected behavior of contract functions. During verification, the Prover will ignore any model that causes the require expressions to evaluate to false. Unlike Solidity, the require statement does not contain a descriptive message, because the Prover will never consider an example where the require statement evaluates to false. The assert statements define the expected behavior of contract functions. If it is possible to generate a model that causes the assert expression to evaluate to false, the Prover will construct one of them and report a violation. Assert conditions may be followed by a message string describing the condition; this message will be included in the reported violation. Note: Unlike Solidity's assert and require, the CVL syntax for assert and require does not require parentheses around the expression and message. ## Examples cvl rule withdraw_succeeds { env e; // env represents the bytecode environment passed on every call // invoke function withdraw and assume that it does not revert bool success = withdraw(e); // e is passed as an additional argument assert success, \"withdraw must succeed\"; // verify that withdraw succeeded } rule totalFundsAfterDeposit(uint256 amount) { env e; deposit(e, amount); uint256 userFundsAfter = getFunds(e, e.msg.sender); uint256 totalAfter = getTotalFunds(e); // Verify that the total funds of the system is at least the current funds of the msg.sender. assert totalAfter >= userFundsAfter; } - assert example ## require example ## satisfy statements A satisfy statement is used to check that the rule can be executed in such a way that the satisfy statement is true. A rule with a satisfy statement is describing a scenario and must not contain assert statements. We require that each rule ends with either a satisfy statement or an assert statement. See producing-examples for an example demonstrating the satisfy command. For each satisfy statement, the Certora verifier will produce a witness for a valid execution of the rule. It will show an execution trace containing values for each input variable and each state variable where all require and satisfy statements are executed successfully. In case there is no such execution, for example if the require statements are already inconsistent or if a solidity function always reverts, an error is reported. --- ## If the rule contains multiple satisfy statements then all executed satisfy statements must hold. However, a satisfy statement on a conditional branch that is not executed does not need to hold. ## If at least one satisfy statement is not satisfiable an error is reported. If all satisfy statements can be fulfilled on at least one path, the rule succeeds. Note: A success only guarantees that there is some satisfying execution starting in some arbitrary state."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-7", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 7, "text": "It is not possible to check that every possible starting state has an execution that satisfies the condition. ## satisfy example requireInvariant requireInvariant statements requireInvariant is shorthand for require of the expression of the invariant where the invariant parameters have to be substituted with the values/variables for which the invariant should hold. ## requireInvariant example Note: requireInvariant is always safe for invariants that have been proved, even in preserved blocks; see invariant-induction for a detailed explanation. ## Havoc Statements Havoc statements introduce non-determinism into the contract execution, allowing the SMT solver to choose random values for specific variables. Havoc statements are helpful for modeling uncertainty and verifying a wider range of possible scenarios. ### Syntax The syntax for a havoc statement is as follows: cvl havoc identifier [ assuming condition ]; identifier: The variable or expression for which non-deterministic values will be chosen. condition: An optional condition pat restricts pe possible values for pe havoc variable. ### Usage Basic Havoc The basic use of a havoc statement involves introducing non-deterministic values for a specific variable. This is useful when the exact value of a variable is unknown or when exploring various scenarios. Example: cvl uint256 x; havoc x; In this example, the value of variable x is chosen randomly by the SMT solver. Note: The havoc statement is not really necessary as unassigned values are havoc by default. Havoc with Condition Havoc statements can include a condition that restricts the possible values for the havoc variable. This allows for more fine-grained control over the non-deterministic choices made by the SMT solver. Example: cvl uint256 y; havoc y assuming y > 10; In this example, the havoc statement introduces non-deterministic values for variable y, but only values greater than 10 are considered valid. Note: The above is equivalent to: cvl uint256 y; require y > 0; Two-State Contexts: @old and @new Two-state contexts, denoted by @old and @new, are essential when dealing with havoc statements. They provide a mechanism to reference the old and new states of a variable within the havoc statement, allowing for more nuanced control over the non-deterministic choices. Example: cvl havoc sumAllBalance assuming sumAllBalance@new() == sumAllBalance@old() + balance - old_balance; In the given example, the havoc statement introduces non-deterministic values for the variable sumAllBalance. The assuming clause adds a condition: the new state of sumAllBalance should be the old state plus the change in the balance variable. sumAllBalance@new(): Value in the updated state. sumAllBalance@old(): Value in the previous state. balance - old_balance: Change in the balance variable. --- {note} {doc}`hooks` will not be triggered for havoc statements. That is, if there is a hook defined on load, or store, of the `sumAllBalance` variable, it will not be triggered from the havoc statement. Advanced Usage: havoc assuming The havoc assuming construct allows introducing non-deterministic choices for variables while imposing specific conditions. This can be particularly useful for modeling complex scenarios where certain constraints must be satisfied. Example: cvl ghost uint256 a; ghost uint256 b; rule example(){ havoc a assuming a@new < b; havoc b assuming a + b@new == 100; assert a < b && a + b == 100; } In this example, havoc statements are used to introduce non-deterministic values for ghosts a and b while ensuring that a is less than b and their sum is equal to 100. Conclusion Havoc statements play a critical role in making CVL specifications more expressive and capable of handling uncertainty. They widen the coverage of possible contract behaviors making verification more robust and comprehensive. Understanding two-state contexts (@old and @new) and the havoc assuming construct is useful for harnessing the full power of CVL, in particular when combined with ghosts. ## (control-flow)= Solidity-like Statements Solidity-like statements provide a familiar syntax for expressing conditions and behaviors similar to Solidity, These statements enhance the readability and ease of writing specifications by adopting a syntax that resembles Solidity. 1. Assert Statement Syntax: cvl assert condition; Usage: The assert statement is used to assert a condition that must be true during the execution of the contract. If the condition evaluates to false, it will trigger a verification failure. Example: cvl uint256 balance; assert balance > 0; In this example, the assert statement ensures that the balance variable is positive. 2. Require Statement Syntax: cvl require condition; Usage: The require statement is similar to the assert statement but is used for expressing preconditions that must be satisfied for the execution to continue. Values that make the condition evaluate to false will not be considered as violations of a later assert statement or witnesses to a later satisfy statement. Example: cvl uint256 amount; require amount > 0; satisfy amount >= 0; Here, the require statement ensures that the amount must be greater than zero. This means there cannot be a witness of the satisfy command with amount equal to zero. 3."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-8", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 8, "text": "Modeling Reverts in Solidity Calls The default method of calling Solidity functions within CVL is to assume they do not revert. This behavior can be adjusted with the @withrevert modifier. After every Solidity call, even if it is not marked with @withrevert, a builtin variable called lastReverted is updated according to whether the Solidity call reverted or not. Note: For calls without @withrevert, lastReverted is automatically set to to false. Syntax: cvl f@withrevert(args); assert !lastReverted; In this example, we call to f without pruning the reverting paths, and then we assert that the call to f did not revert on any given input. Example: cvl uint256 limit = 100; uint256 value; require value > limit; Deposit@wiprevert(value); assert lastReverted, \"Expected revert when value exceeds limit\"; --- In this example, the @withrevert modifier is applied to the Deposit function call, which is expected to revert if the value exceeds the specified limit. The assert statement checks whether lastReverted is true, ensuring that the contract execution does revert as anticipated when the condition is violated."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "statements", "id": "6f0ce8f93522-9", "chunk-uid": "6f0ce8f93522", "chunk-page-index": 9, "text": "The error message in the assert provides additional context about the expectation. Return Statement Syntax: cvl return expression; Usage: The return statement is used to terminate the execution of a function and return a value. It can only be used in functions to specify the value to be returned. Example: cvl function calculateSum(uint256 a, uint256 b) returns (uint256) { return a + b; } This example defines a function calculateSum that takes two parameters and returns their sum. Conclusion Solidity-like statements in CVL simplify the process of writing specifications by using a syntax that closely resembles Solidity. These statements align with the familiar patterns and structures used in Solidity smart contracts, making it easier for developers and auditors to express and verify the desired behaviors and conditions in a contract. Understanding and using these statements contributes to more readable and expressive CVL specifications."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-0", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 0, "text": "## Expressions A CVL expression is anything that represents a value. This page documents all possible expressions in CVL and explains how they are evaluated. {contents} ### Syntax The syntax for CVL expressions is given by the following EBNF grammar: |expr ::=|literal | unop expr | expr binop expr | \"(\" exprs \")\" | expr \"?\" expr \":\" expr | [ \"forall\" | \"exists\" ] type id \".\" expr| |---|---| | || expr \".\" id| | || id [ \"[\" expr \"]\" { \"[\" expr \"]\" } ]| | || id \"(\" types \")\"| | || function_call| | || expr \"in\" id| function_call ::= [ id \".\" ] id [ \"@\" ( \"norevert\" \"withrevert\" \"dontsummarize\" ) ] \"(\" exprs \")\" [ \"at\" id ] literal ::= \"true\" \"false\" number string unop ::= \"~\" \"!\" \"-\" |binop ::=|\"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"^\" | \">\" | \"<\" | \"==\" | \"!=\" | \">=\" | \"<=\" | \"&\" | \"|\" | \"<<\" | \">>\" | \"&&\" | \"||\" | \"=>\" | \"<=>\"| |---|---| | || \"xor\" | \">>>\"| |specials_fields ::=|\"block\" \".\" [ \"number\" | \"timestamp\" ] | \"msg\" \".\" [ \"address\" | \"sender\" | \"value\" ] | \"tx\" \".\" [ \"origin\" ] || |---|---| | |\"length\" | \"selector\" | \"isPure\" | \"isView\" | \"numberOfArguments\" | \"isFallback\"| |specialvars ::=|\"lastReverted\" | \"lastHasThrown\" | \"lastStorage\" | \"allContracts\" | \"lastMsgSig\" | \"\" | \"maxuint\" || |---|---| | |\"maxaddress\" | \"maxuint8\" | ... | \"maxuint256\" | \"nativeBalances\" | \"calledContract\" | \"executingContract\"| castfunctions ::= requirefunctions tofunctions assertfunctions requirefunctions ::= \"requireuint8\" ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-1", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 1, "text": "\"requireuint256\" \"requireint8\" ... \"requireint256\" \"requireaddress\" tofunctions ::= \"tomathint\" \"tobytes1\" ... \"tobytes32\" assertfunctions ::= \"assertuint8\" ... \"assertuint256\" \"assertint8\" ... \"assertint256\" \"assertaddress\" contract ::= id \"currentContract\" See {doc}basics for the id, number, and string productions. See {doc}types for the type production. ### Basic operations CVL provides the same basic arithmetic, comparison, bitwise, and logical operations for basic types that solidity does, with a few differences listed in this section and the next. The precedence and associativity rules are standard. {caution} One significant difference between CVL and Solidity is that in Solidity, `^` denotes bitwise exclusive or and `**` denotes exponentiation, whereas in CVL, `^` denotes exponentiation and `xor` --- ## denotes exclusive or. % TODO: migrate this information here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-2", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 2, "text": "See {ref}cvl2-integer-types for more information about the interaction between mathematical types and the meaning of mathematical operations. ## Struct Comparison CVL supports equality comparison of structs under the following restrictions: - The structs must be of the same type. - The structs (or any nested structs) don't contain dynamic types (dynamic arrays, string, bytes). - There's no support for comparison for structs fetched using direct-storage-access. Two structs will be evaluated as equal if and only if all the fields are equal. For example: cvl rule example(MyContract.MyStruct s) { env e; assert s == currentContract.myStructGetter(e); } ## Extended logical operations CVL also adds several useful logical operations: - Like && or ||, an implication expression expr1 => expr2 requires expr1 and expr2 to be boolean expressions and is itself a boolean expression. expr1 => expr2 evaluates to false if and only if expr1 evaluates to true and expr2 evaluates to false. expr1 => expr2 is equivalent to !expr1 || expr2. - For example, the statement assert initialized => x > 0; will only report counterexamples where initialized is true but x is not positive. - The short-circuiting behavior of implications (=>) and other boolean connectors in CVL mirrors the short-circuiting behavior seen in standard logical operators (&& and ||). In practical terms, this implies that the evaluation process is terminated as soon as the final result can be determined without necessitating further computation. For example, when dealing with an implication expression like expr1 => expr2, if the evaluation of expr1 results in false, there is no need to proceed with evaluating expr2 since the overall result is already known. This aligns with the common short- circuiting behavior found in traditional logical operators. - Similarly, an if and only if expression (also called a bidirectional implication) expr1 <=> expr2 requires expr1 and expr2 to be boolean expressions and is itself a boolean expression. expr1 <=> expr2 evaluates to true if expr1 and expr2 evaluate to the same boolean value. - For example, the statement assert balanceA > 0 <=> balanceB > 0; will report a violation if exactly one of balanceA and balanceB is positive. - An if-then-else (ITE) expression of the form cond ? expr1 : expr2 requires cond to be a boolean expression and requires expr1 and expr2 to have the same type; the entire if-then-else expression has the same type as expr1 and expr2. The expression cond ? expr1 : expr2 should be read \"if cond then expr1 else expr2. If cond evaluates to true then the entire expression evaluates to expr1; otherwise the entire expression evaluates to expr2. - For example, the expression cvl uint balance = address == owner ? ownerBalance() : userBalance(address); will set balance to ownerBalance() if address is owner, and will set it to userBalance(address) otherwise. --- Conditional expressions are short-circuiting: if expr1 or expr2 have side-effects (such as updating a ghost variable), only the side-effects of the expression that is chosen are performed. Regarding the logical operator precedence, => has higher precedence than <=>, and unlike math operators both are right associative, so expr1 => expr2 => expr3 is equivalent to expr1 => (expr2 => expr3). A universal expression of the form forall t v . expr requires t to be a type (such as uint256 or address) and v to be a variable name; expr should be a boolean expression and may refer to the identifier v. The expression evaluates to true if every possible value of the variable v causes expr to evaluate to true. For example, the statement cvl require (forall address user . balance(user) <= balance(biggestUser)); will ensure that every other user has a balance that is less than or equal to the balance of biggestUser. Like a universal expression, an existential expression of the form exists t v . expr requires t to be a type and v to be a variable name; expr should be a boolean expression and may refer to the variable v. The expression evaluates to true if there is any possible value of the variable v that causes expr to evaluate to true. For example, the statement cvl require (exists uint t . priceAtTime(t) != 0); will ensure that there is some time for which the price is nonzero. Note: The symbols forall and exist are sometimes referred to as quantifiers, and expressions of the form forall type v . e and exist type v . e are referred to as quantified expressions. Caution: forall and exists expressions are powerful and elegant ways to express rules and invariants, but they require the Prover to consider all possible values of a given type. In some cases they can cause significant slowdowns for the Prover. If you have rules or invariants using exists that are running slowly or timing out, you can remove the exists by manually computing the value that exists. For example, you might replace cvl require (exists uint t . priceAtTime(t) != 0); with cvl require priceAtTime(startTime) != 0; Caution: Calling contract functions within the body of a quantified expression is an experimental feature and may not work as intended. Note: The Prover uses approximations that may cause spurious counterexamples in rules that use quantifiers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-3", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 3, "text": "For example, a rule that requires a quantified statement may produce a counterexample that doesn't satisfy the requirement. The approximation is sound: it won't cause violations to be hidden."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-4", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 4, "text": "See grounding for more detail. Accessing fields and arrays One can access the special fields of built-in types, fields of user-defined struct types, and members of user-defined enum types using the normal expr.field notation. Note that as described in user-types, access to user-defined types must be qualified by a contract name. Access to arrays also uses the same syntax as Solidity. Contracts, method signatures and their properties Writing the ABI signature for a contract method produces a method object, which can be used to access the method fields. For example, cvl method m; require m.selector == sig:balanceOf(address).selector || m.selector == sig:transfer(address, uint256).selector; will constrain m to be either the balanceOf or the transfer method. --- ## Special variables and fields Several of the CVL types have special fields; see types (particularly env, method-type, and arrays). There are also several built-in variables: - **address currentContract** always refers to the main contract being verified (that is, the contract named in the -verify option). - **bool lastReverted and bool lastHasThrown** are boolean values that indicate whether the most recent contract function reverted or threw an exception. - **lastStorage** refers to the most recent state of the EVM storage. See storage-type for more details."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-5", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 5, "text": "- You can use the variable _ as a placeholder for a value you are not interested in. - The maximum values for the different integer types are available as the variables max_uint, max_address, max_uint8, max_uint16 etc. - **nativeBalances** is a mapping of the native token balances, i.e. ETH for Ethereum. The balance of an address a can be expressed using nativeBalances[a]. - **calledContract** is only available in function summaries. It refers to the receiver contract of a summarized method call. - **executingContract** is only available in hooks. It refers to the contract that is executing when the hook is triggered. CVL also has several built-in functions for converting between numeric types. See math-ops for details. ## Calling contract functions There are many kinds of function-like things that can be called from CVL: - Contract functions - Method variables - Ghost-functions - functions - defs There are several additional features that can be used when calling contract functions (including calling them through method variables). --- The method name can optionally be prefixed by a contract name. If a contract is not explicitly named, the method will be called with currentContract as the receiver. It is possible for multiple contract methods to match the method call. This can happen in two ways: 1. The method to be called is a method variable <method-type> 2. The method to be called is overloaded in the contract (i.e. there are two methods of the same name), and the method is called with a calldataarg <calldataarg> argument. In either case, the Prover will consider every possible resolution of the method while verifying the rule, and will provide a separate verification report for each checked method. Rules that use this feature are referred to as parametric rules. (with-revert)= After the function name, but before the arguments, you can write an optional method tag, one of @norevert or @withrevert. - @norevert indicates that examples where the method revert should not be considered. This is the default behavior if no tag is provided - @withrevert indicates that examples that would revert should still be considered. In this case, the method will set the lastReverted and lastHasThrown variables to true in case the called method reverts or throws an exception. withrevert example After the method tag, the method arguments are provided. Unless the method is declared envfree, the first argument must be an environment value. The remaining arguments must either be a single calldataarg value, or the same types of arguments that would normally be passed to the contract method. After the method arguments, a method invocation can optionally include at s where s is a storage variable. This indicates that before the method is executed, the EVM state should be restored to the saved state s. Type restrictions When calling a contract function, the Prover must convert the arguments and return values from their Solidity types to their CVL types and vice-versa. There are some restrictions on the types that can be converted. See type-conversions for more details. (storage-comparison)= Comparing storage As described in the documentation on storage types, CVL represents the entirety of the EVM and its ghost state in variables with storage type. Variables of this type can be checked for equality and inequality. The basic form of this expression is s1 == s2, where s1 and s2 are variables of type storage. This expression compares the states represented by s1 and s2; that is, it checks equality of the following: 1. The values in storage for all contracts, 2. The balances of all contracts, 3. The state of all ghost variables and functions Thus, if any field in any contract's storage differs between s1 and s2, the expression will return false. The expression s1 != s2 is shorthand for !(s1 == s2). Storage comparisons also support narrowing the scope of comparison to specific components of the global state represented by storage variables. This syntax is s1[r] == s2[r] or s1[r] != s2[r], where r is a \"storage comparison basis\", and s1 and s2 are variables of type storage. The valid bases of comparison are: 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-6", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 6, "text": "The name of a contract imported with a using statement, 2. The keyword nativeBalances, or 3. The name of a ghost variable or function It is an error to use different bases on different sides of the comparison operator, and it is also an error to use a comparison basis on one side and not the other. The application of the basis restricts the comparison to only consider the portion of --- global state identified by the basis. If the qualifier is a contract identifier imported via using, then the comparison operation will only consider the storage fields of that contract. For example: |CVL|using MyContract as c; using OtherContract as o;| |---|---| |rule comparestateof_c(env e) { storage init = lastStorage; o.mutateOtherState(e); // changes o but not c assert lastStorage[c] == init[c]; }| | will pass verification whereas: |CVL|using MyContract as c; using OtherContract as o;| |---|---| |rule comparestateof_c(env e) { storage init = lastStorage; c.mutateContractState(e); // changes c assert lastStorage[c] == init[c]; }| | will not. {note} Comparing contract's state using this method will not compare the balance of the contract between the two states. If the qualifier is the identifier nativeBalances, then the account balances of all contracts are compared between the two storage states. Finally, if the basis is the name of a ghost function or variable, the values of that function/variable are compared between storage states. Two ghost functions are considered equal if they have the same outputs for all input arguments. {warning} The default behavior of the Prover on unresolved external calls is to pessimistically havoc contract state and balances. This behavior will render most storage comparisons that incorporate such state useless. Care should be taken (using summarization) to ensure that rules that compare storage do not encounter this behavior. {warning} The grammar admits storage comparisons for both equality and inequality that occur arbitrarily nested within expressions. However, support within the Prover for these comparisons is primarily aimed at assertions of storage equality, e.g., assert s1 == s2. Support for storage inequality as well as nesting comparisons within other expressions is considered experimental. {warning} The storage comparison checks for exact equality between every single slot of storage which can lead to surprising failures of storage equality assertions. In particular, these failures can happen if an uninitialized storage slot is written and then later cleared by Solidity (via the pop() function or the delete keyword). After the clear operation the slot will definitely hold 0, but the Prover will not make any assumptions about the value of the uninitialized slot which means they can be considered different. Direct storage access The value of contract state variables can be directly accessed from CVL. These direct storage accesses are written using the state variable names and struct fields defined in the contract. For example, to access the state variable uint x defined in the currentContract, one can simply write currentContract.x. More complex structs can be accessed by chaining field selects and array/map dereference operations together. For example, if the current contract has the following type definitions and state variables: solidity contract Example { struct Foo { mapping (address => uint[]) bar; } Foo[3] myState; uint32 luckyNumber; address[] public addresses; } one can write currentContract.myState[0].bar[addr][0], where addr is a CVL variable of type address. --- The storage of contracts other than the currentContract can be accessed by writing the contract identifier bound with a {ref}using statement &lt;using-stmt&gt;. For example, if the myState definition above appeared in a contract called Test and the current CVL file included using Test as t; one could write t.myState[0].bar[addr][0]. {note} A contract identifier (or `currentContract`) *must* be included in the direct storage access. In other words, writing just `myState[0].bar[addr][0]` will not work, even if `myState` is declared in the current contract. Currently only primitive values (e.g., uint, bytes3, bool, enums, and user defined value types) can be directly accessed. Attempting to access more complex types will yield a type checking error. For example, attempting to access an entire array with currentContract.myState[0].bar[addr] will fail. {note} Although entire arrays cannot be accessed, the _length_ or the _number of elements_ of the dynamic arrays can be accessed with `.length`, e.g., `currentContract.myState[0].bar[addr].length`. {warning} Direct storage access is an experimental feature, and relies on several internal program analyses which can sometimes fail. For example, attempts to use direct storage access to refer to variable which is actually unused or inaccessible in the contract. If these internal static analyses fail, any rules that use direct storage access will fail during processing. If this occurs, check the \"Global Problems\" view of the web report and contact Certora for assistance. Direct storage havoc The same direct storage syntax can also be used in havoc statements. With the previously-mentioned Example contract and using Example as ex, you can write havoc ex.luckyNumber or havoc addresses[10] or even havoc addresses.length. While you may use a havoc assuming statement, unlike ghosts, you cannot directly refer to the havoced storage path in the assuming expression using the @old and @new syntax. This generally means assuming expressions are not as useful with direct storage access, so consider using and unconditional havoc statements instead of havoc assuming. {warning} As with direct storage access in general, direct storage havoc is experimental and limited to primitive types. In particular, this mean you _cannot_ currently havoc * entire arrays or entire mappings (only arrays at a specific index, or mappings at a specific key) * user-defined types such as structs, or arrays/mappings of such types * enums (direct-immutable-access)= Direct immutable access The Certora Prover allows to access immutable variables in a contract, in a similar way to direct storage access. For example, given a contract: solidity contract WithImmutables { address private immutable myImmutAddr; bool public immutable myImmutBool; constructor() { ... } function publicGetterForPrivateImmutableAddr() external returns (address) { return myImmutAddr; } } We can access both myImmutAddr and myImmutBool directly from CVL like this: cvl using WithImmutables as withImmutables; methods { function publicGetterForPrivateImmutableAddr() external returns (address) envfree; function myImmutBool() external returns (bool) envfree; } rule accessPrivateImmut { assert withImmutables.myImmutAddr == publicGetterForPrivateImmutableAddr(); } rule accessPublicImmut { assert withImmutables.myImmutBool == withImmutables.myImmutBool(); } The advantages of direct immutable access is that there is no need to declare envfree methods for the public immutables, and even more importantly, nor is there a need to harness contracts in order to expose the private immutables. --- ## Built-in Functions Hashing CVL allows to use Solidity's keccak256 hashing function directly in spec. Below are two usage examples: one using a bytes array, another using primitives. As bytes32 is the return type of keccak256 and is a primitive type, calls to keccak256 can be nested. (Currently, only the keccak256 hash is supported in CVL as a built-in.) Example Given the following Solidity snippet: solidity contract HashingExample { struct SignedMessage { address sender; uint256 nonce; bytes signature; } mapping (bytes32 => uint256) messageToValue; function hashingScheme1(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce)); } function hashingScheme2(SignedMessage memory s) public pure returns (bytes32) { return keccak256(s.signature); } function hashingScheme3(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce, keccak256(s.signature))); } function hashingScheme4(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce, s.signature)); } } The hashing schemes described by hashingScheme1, hashingScheme2, and hashingScheme3 can be replicated in CVL as follows: function hashingScheme1CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.sender, s.nonce); } function hashingScheme2CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.signature); } function hashingScheme3CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.sender, s.nonce, keccak256(s.signature)); } The scheme implemented in hashingScheme4 is not supported at the moment, as it combines a bytes type with primitives. The keccak256 built-in function supports two kinds of inputs: - a single bytes parameter - a list of primitive (e.g., uint256, uint8, addresss) parameters {note} keccak256 is currently unsupported in quantified expressions. ECRecover The ecrecover function in Solidity is helpful in recovering the signer's address from a signed message. It exists in very similar form in CVL and receives exactly the same parameter types as its Solidity counterpart. {note} ecrecover is supported in quantified expressions. The Prover's model of ecrecover does not actually implement the elliptical curve recovery algorithm, and is instead implemented using an uninterpreted function. Like all uninterpreted functions, axioms can be added to make the behavior of CVL's ecrecover more faithfully model the actual key recovery algorithm. --- There is a useful set of axioms that can be encoded in CVL to make the modeled behavior of ecrecover more precise and less likely to create false counterexamples: CVL function ecrecoverAxioms() // zero value: require (forall uint8 v. forall bytes32 r. forall bytes32 s. ecrecover(to_bytes32(0), v, r, s) == 0); // uniqueness of signature require (forall uint8 v. forall bytes32 r. forall bytes32 s. forall bytes32 h1. forall bytes32 h2. h1 != h2 => ecrecover(h1, v, r, s) != 0 => ecrecover(h2, v, r, s) == 0); // dependency on r and s require (forall bytes32 h. forall uint8 v."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-7", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 7, "text": "forall bytes32 s. forall bytes32 r1. forall bytes32 r2. r1 != r2 => ecrecover(h, v, r1, s) != 0 => ecrecover(h, v, r2, s) == 0); require (forall bytes32 h. forall uint8 v. forall bytes32 r. forall bytes32 s1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-8", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 8, "text": "forall bytes32 s2. s1 != s2 => ecrecover(h, v, r, s1) != 0 => ecrecover(h, v, r, s2) == 0); Example Given the following Solidity snippet: solidity contract ECExample { function wrap_ecrecover(bytes32 digest, uint8 v, bytes32 r, bytes32 s) public pure returns (address) { return ecrecover(digest,v,r,s); } } The following CVL function is equivalent to the wrap_ecrecover function in the Solidity snippet: cvl function wrap_ecrecoverCVL(bytes32 digest, uint8 v, bytes32 r, bytes32 s) returns address { return ecrecover(digest,v,r,s); } Expressions A CVL expression is anything that represents a value. This page documents all possible expressions in CVL and explains how they are evaluated. {contents} Syntax The syntax for CVL expressions is given by the following EBNF grammar: expr ::= literal | unop expr | expr binop expr | \"(\" exprs \")\" | expr \"?\" expr \":\" expr | [ \"forall\" | \"exists\" ] type id \".\" expr | expr \".\" id | id [ \"[\" expr \"]\" { \"[\" expr \"]\" } ] | id \"(\" types \")\" | function_call | expr \"in\" id function_call ::= | [ id \".\" ] id [ \"@\" ( \"norevert\" | \"withrevert\" | \"dontsummarize\" ) ] \"(\" exprs \")\" [ \"at\" id ] literal ::= \"true\" | \"false\" | number | string unop ::= \"~\" | \"!\" | \"-\" binop ::= \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"^\" | \">\" | \"<\" | \"==\" | \"!=\" | \">=\" | \"<=\" | \"&\" | \"|\" | \"<<\" | \">>\" | \"&&\" | \"||\" | \"=>\" | \"<=>\" | \"xor\" | \">>>\" --- ## requirefunctions \"requireuint8\" ... \"requireuint256\" \"requireint8\" ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-9", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 9, "text": "\"requireint256\" \"requireaddress\" ## tofunctions \"tomapint\" \"tobytes1\" ... \"tobytes32\" ## assertfunctions \"assertuint8\" ... \"assertuint256\" \"assertint8\" ... \"assertint256\" \"assertaddress\" ## contract id | \"currentContract\" ``` See {doc}basics for the id, number, and string productions. See {doc}types for the type production. ## Basic operations CVL provides the same basic arithmetic, comparison, bitwise, and logical operations for basic types that solidity does, with a few differences listed in this section and the next. The precedence and associativity rules are standard. Caution: One significant difference between CVL and Solidity is that in Solidity, `^` denotes bitwise exclusive or and `**` denotes exponentiation, whereas in CVL, `^` denotes exponentiation and `xor` denotes exclusive or. % TODO: migrate this information here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-10", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 10, "text": "See {ref}cvl2-integer-types for more information about the interaction between mathematical types and the meaning of mathematical operations. ## Struct Comparison CVL supports equality comparison of structs under the following restrictions: - The structs must be of the same type. - The structs (or any nested structs) don't contain dynamic types (dynamic arrays, string, bytes). - There's no support for comparison for structs fetched using direct-storage-access. Two structs will be evaluated as equal if and only if all the fields are equal. For example: cvl rule example(MyContract.MyStruct s) { env e; assert s == currentContract.myStructGetter(e); } ## Extended logical operations CVL also adds several useful logical operations: - Like && or ||, an implication expression expr1 => expr2 requires expr1 and expr2 to be boolean expressions and is itself a boolean expression. expr1 => expr2 evaluates to false if and only if expr1 evaluates to true and expr2 evaluates to false. expr1 => expr2 is equivalent to !expr1 || expr2. - For example, the statement assert initialized => x > 0; will only report counterexamples where initialized is true but x is not positive. - The short-circuiting behavior of implications (=>) and other boolean connectors in CVL mirrors the short-circuiting behavior seen in standard logical operators (&& and ||). In practical terms, this implies that the evaluation process is terminated as soon as the final result can be determined without necessitating further computation. For example, when dealing with an implication expression like expr1 => expr2, if the evaluation of expr1 results in false, there is no --- need to proceed with evaluating expr2 since the overall result is already known. This aligns with the common short-circuiting behavior found in traditional logical operators. Similarly, an if and only if expression (also called a bidirectional implication) expr1 <=> expr2 requires expr1 and expr2 to be boolean expressions and is itself a boolean expression. expr1 <=> expr2 evaluates to true if expr1 and expr2 evaluate to the same boolean value. For example, the statement assert balanceA > 0 <=> balanceB > 0; will report a violation if exactly one of balanceA and balanceB is positive. An if-then-else (ITE) expression of the form cond ? expr1 : expr2 requires cond to be a boolean expression and requires expr1 and expr2 to have the same type; the entire if-then-else expression has the same type as expr1 and expr2. The expression cond ? expr1 : expr2 should be read \"if cond then expr1 else expr2. If cond evaluates to true then the entire expression evaluates to expr1; otherwise the entire expression evaluates to expr2. For example, the expression cvl uint balance = address == owner ? ownerBalance() : userBalance(address); will set balance to ownerBalance() if address is owner, and will set it to userBalance(address) otherwise. Conditional expressions are short-circuiting: if expr1 or expr2 have side-effects (such as updating a ghost variable), only the side-effects of the expression that is chosen are performed. Regarding the logical operator precedence, => has higher precedence than <=>, and unlike math operators both are right associative, so expr1 => expr2 => expr3 is equivalent to expr1 => (expr2 => expr3). A universal expression of the form forall t v . expr requires t to be a type (such as uint256 or address) and v to be a variable name; expr should be a boolean expression and may refer to the identifier v. The expression evaluates to true if every possible value of the variable v causes expr to evaluate to true. For example, the statement cvl require (forall address user . balance(user) <= balance(biggestUser)); will ensure that every other user has a balance that is less than or equal to the balance of biggestUser. Like a universal expression, an existential expression of the form exists t v . expr requires t to be a type and v to be a variable name; expr should be a boolean expression and may refer to the variable v. The expression evaluates to true if there is any possible value of the variable v that causes expr to evaluate to true. For example, the statement cvl require (exists uint t . priceAtTime(t) != 0); will ensure that there is some time for which the price is nonzero. The symbols `forall` and `exist` are sometimes referred to as quantifiers, and expressions of the form `forall type v . e` and `exist type v . e` are referred to as quantified expressions. Caution: forall and exists expressions are powerful and elegant ways to express rules and invariants, but they require the Prover to consider all possible values of a given type. In some cases they can cause significant slowdowns for the Prover. If you have rules or invariants using exists that are running slowly or timing out, you can remove the exists by manually computing the value that exists. For example, you might replace cvl require (exists uint t . priceAtTime(t) != 0); with cvl require priceAtTime(startTime) != 0; Caution: Calling contract functions within the body of a quantified expression is an experimental feature and may not work as intended. Note: The Prover uses approximations that may cause spurious counterexamples in rules that use quantifiers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-11", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 11, "text": "For example, a rule that requires a quantified statement may produce a counterexample that doesn't satisfy the requirement. The approximation is sound: it won't cause violations to be hidden."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-12", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 12, "text": "See grounding for more detail. --- ## Accessing fields and arrays One can access the special fields of built-in types, fields of user-defined struct types, and members of user-defined enum types using the normal expr.field notation. Note that as described in user-types, access to user-defined types must be qualified by a contract name. Access to arrays also uses the same syntax as Solidity. ## Contracts, method signatures and their properties Writing the ABI signature for a contract method produces a method object, which can be used to access the method fields. For example, cvl method m; require m.selector == sig:balanceOf(address).selector || m.selector == sig:transfer(address, uint256).selector; will constrain m to be either the balanceOf or the transfer method. One can determine whether a contract has a particular method using the s in c where s is a method selector and c is a contract (either currentContract or a contract introduced with a using statement. For example, the statement cvl if (burnFrom(address,uint256).selector in currentContract) { ... } will check that the current contract supports the optional burnFrom method. ## Special variables and fields Several of the CVL types have special fields; see types (particularly env, method-type, and arrays). There are also several built-in variables: - address currentContract always refers to the main contract being verified (that is, the contract named in the verify option). - bool lastReverted and bool lastHasThrown are boolean values that indicate whether the most recent contract function reverted or threw an exception. - The variables lastReverted and lastHasThrown are updated after each contract call, even those called without @withrevert (see call-expr). This is a common source of errors. For example, the following rule is vacuous: cvl rule revertifpaused() { withdraw@withrevert(); assert isPaused() => lastReverted; } - In this rule, the call to isPaused will update lastReverted to true, overwriting the value set by withdraw. - lastStorage refers to the most recent state of the EVM storage."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-13", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 13, "text": "See storage-type for more details."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-14", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 14, "text": "- You can use the variable _ as a placeholder for a value you are not interested in. - The maximum values for the different integer types are available as the variables max_uint, max_address, max_uint8, max_uint16 etc. - nativeBalances is a mapping of the native token balances, i.e."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-15", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 15, "text": "ETH for Ethereum. The balance of an address a can be expressed using nativeBalances[a]. - calledContract is only available in function summaries."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-16", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 16, "text": "It refers to the receiver contract of a summarized method call. - executingContract is only available in hooks. It refers to the contract that is executing when the hook is triggered. --- ## Calling contract functions There are many kinds of function-like things that can be called from CVL: - Contract functions - Method variables - Ghost functions - Functions - Defs There are several additional features that can be used when calling contract functions (including calling them through method variables). The method name can optionally be prefixed by a contract name. If a contract is not explicitly named, the method will be called with currentContract as the receiver. It is possible for multiple contract methods to match the method call. This can happen in two ways: 1. The method to be called is a method variable 2. The method to be called is overloaded in the contract (i.e. there are two methods of the same name), and the method is called with a calldataarg argument. In either case, the Prover will consider every possible resolution of the method while verifying the rule, and will provide a separate verification report for each checked method. Rules that use this feature are referred to as parametric rules. ## After the function name, but before the arguments, you can write an optional method tag, one of @norevert or @withrevert. @norevert indicates that examples where the method revert should not be considered. This is the default behavior if no tag is provided. @withrevert indicates that examples that would revert should still be considered. In this case, the method will set the lastReverted and lastHasThrown variables to true in case the called method reverts or throws an exception. withrevert example After the method tag, the method arguments are provided. Unless the method is declared envfree, the first argument must be an environment value. The remaining arguments must either be a single calldataarg value, or the same types of arguments that would normally be passed to the contract method. After the method arguments, a method invocation can optionally include at s where s is a storage variable. This indicates that before the method is executed, the EVM state should be restored to the saved state s. ## Type restrictions When calling a contract function, the Prover must convert the arguments and return values from their Solidity types to their CVL types and vice-versa. There are some restrictions on the types that can be converted. See type-conversions for more details. ## Comparing storage As described in the documentation on storage types, CVL represents the entirety of the EVM and its ghost state in variables with storage type. Variables of this type can be checked for equality and inequality. The basic form of this expression is s1 == s2, where s1 and s2 are variables of type storage. This expression compares the states represented by s1 and s2; that is, it checks equality of the following: --- The values in storage for all contracts, The balances of all contracts, The state of all ghost variables and functions Thus, if any field in any contract's storage differs between s1 and s2, the expression will return false. The expression s1 != s2 is shorthand for !(s1 == s2). Storage comparisons also support narrowing the scope of comparison to specific components of the global state represented by storage variables. This syntax is s1[r] == s2[r] or s1[r] != s2[r], where r is a \"storage comparison basis\", and s1 and s2 are variables of type storage. The valid bases of comparison are: - The name of a contract imported with a using statement &lt;using-stmt&gt;, - The keyword nativeBalances, or - The name of a ghost variable or function It is an error to use different bases on different sides of the comparison operator, and it is also an error to use a comparison basis on one side and not the other. The application of the basis restricts the comparison to only consider the portion of global state identified by the basis. If the qualifier is a contract identifier imported via using, then the comparison operation will only consider the storage fields of that contract. For example: cvl using MyContract as c; using OperContract as o; rule comparestateof_c(env e) { storage init = lastStorage; o.mutateOperState(e); // changes o but not c assert lastStorage[c] == init[c]; } will pass verification whereas: cvl using MyContract as c; using OperContract as o; rule comparestateof_c(env e) { storage init = lastStorage; c.mutateContractState(e); // changes c assert lastStorage[c] == init[c]; } will not. Comparing contract's state using this method will not compare the balance of the contract between the two states. If the qualifier is the identifier nativeBalances, then the account balances of all contracts are compared between the two storage states. Finally, if the basis is the name of a ghost function or variable, the values of that function/variable are compared between storage states. Two ghost functions are considered equal if they have the same outputs for all input arguments. The default behavior of the Prover on unresolved external calls is to pessimistically havoc contract state and balances. This behavior will render most storage comparisons that incorporate such state useless."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-17", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 17, "text": "Care should be taken (using summarization) to ensure that rules that compare storage do not encounter this behavior. The grammar admits storage comparisons for both equality and inequality that occur arbitrarily nested within expressions. However, support within the Prover for these comparisons is primarily aimed at assertions of storage equality, e.g., assert s1 == s2. Support for storage inequality as well as nesting comparisons within other expressions is considered experimental. The storage comparison checks for exact equality between every single slot of storage which can lead to surprising failures of storage equality assertions. In particular, these failures can happen if an uninitialized storage slot is written and then later cleared by Solidity (via the pop() function or the delete keyword). After the clear operation the slot will definitely hold 0, but the --- ## Direct storage access The value of contract state variables can be directly accessed from CVL. These direct storage accesses are written using the state variable names and struct fields defined in the contract. For example, to access the state variable uint x defined in the currentContract, one can simply write currentContract.x. More complex structs can be accessed by chaining field selects and array/map dereference operations together. For example, if the current contract has the following type definitions and state variables: solidity contract Example struct Foo { mapping (address => uint[]) bar; } Foo[3] myState; uint32 luckyNumber; address[] public addresses; One can write currentContract.myState[0].bar[addr][0], where addr is a CVL variable of type address. The storage of contracts other than the currentContract can be accessed by writing the contract identifier bound with a using statement. For example, if the myState definition above appeared in a contract called Test and the current CVL file included using Test as t; one could write t.myState[0].bar[addr][0]. Note: A contract identifier (or currentContract) must be included in the direct storage access. In other words, writing just myState[0].bar[addr][0] will not work, even if myState is declared in the current contract. Currently only primitive values (e.g., uint, bytes3, bool, enums, and user defined value types) can be directly accessed. Attempting to access more complex types will yield a type checking error. For example, attempting to access an entire array with currentContract.myState[0].bar[addr] will fail. Note: Although entire arrays cannot be accessed, the length or the number of elements of the dynamic arrays can be accessed with .length, e.g., currentContract.myState[0].bar[addr].length. Warning: Direct storage access is an experimental feature, and relies on several internal program analyses which can sometimes fail. For example, attempts to use direct storage access to refer to variable which is actually unused or inaccessible in the contract. If these internal static analyses fail, any rules that use direct storage access will fail during processing. If this occurs, check the \"Global Problems\" view of the web report and contact Certora for assistance. ## Direct storage havoc The same direct storage syntax can also be used in havoc statements. With the previously-mentioned Example contract and using Example as ex, you can write havoc ex.luckyNumber or havoc addresses[10] or even havoc addresses.length. While you may use a havoc assuming statement, unlike ghosts, you cannot directly refer to the havoced storage path in the assuming expression using the @old and @new syntax. This generally means assuming expressions are not as useful with direct storage access, so consider using and unconditional havoc statements instead of havoc assuming. Warning: As with direct storage access in general, direct storage havoc is experimental and limited to primitive types. In particular, this mean you cannot currently havoc * entire arrays or entire mappings (only arrays at a specific index, or mappings at a specific key) * user-defined types such as structs, or arrays/mappings of such types * enums ## Direct immutable access --- The Certora Prover allows to access immutable variables in a contract, in a similar way to direct storage access. For example, given a contract: ```solidity contract WithImmutables { address private immutable myImmutAddr; bool public immutable myImmutBool; constructor() { ... } function publicGetterForPrivateImmutableAddr() external returns (address) { return myImmutAddr; } } ``` We can access both myImmutAddr and myImmutBool directly from CVL like this: ```cvl using WithImmutables as withImmutables; methods { function publicGetterForPrivateImmutableAddr() external returns (address) envfree; function myImmutBool() external returns (bool) envfree; } rule accessPrivateImmut { assert withImmutables.myImmutAddr == publicGetterForPrivateImmutableAddr(); } rule accessPublicImmut { assert withImmutables.myImmutBool == withImmutables.myImmutBool(); } ``` The advantages of direct immutable access is that there is no need to declare envfree methods for the public immutables, and even more importantly, nor is there a need to harness contracts in order to expose the private immutables. Built-in Functions Hashing CVL allows to use Solidity's keccak256 hashing function directly in spec. Below are two usage examples: one using a bytes array, another using primitives. As bytes32 is the return type of keccak256 and is a primitive type, calls to keccak256 can be nested. (Currently, only the keccak256 hash is supported in CVL as a built-in.) Example Given the following Solidity snippet: ```solidity contract HashingExample { struct SignedMessage { address sender; uint256 nonce; bytes signature; } mapping (bytes32 => uint256) messageToValue; function hashingScheme1(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce)); } function hashingScheme2(SignedMessage memory s) public pure returns (bytes32) { return keccak256(s.signature); } function hashingScheme3(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce, keccak256(s.signature))); } function hashingScheme4(SignedMessage memory s) public pure returns (bytes32) { return keccak256(abi.encode(s.sender, s.nonce, s.signature)); } } ``` The hashing schemes described by hashingScheme1, hashingScheme2, and hashingScheme3 can be replicated in CVL as follows: ``` function hashingScheme1CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.sender, s.nonce); } function hashingScheme2CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.signature); } function hashingScheme3CVL(HashingExample.SignedMessage s) returns bytes32 { return keccak256(s.sender, s.nonce, keccak256(s.signature)); } ``` The scheme implemented in hashingScheme4 is not supported at the moment, as it combines a bytes type with primitives. The keccak256 built-in function supports two kinds of inputs: - a single bytes parameter - a list of primitive (e.g., uint256) --- uint8, addresss) parameters {note} keccak256 is currently unsupported in quantified expressions. (ecrecover)= ECRecover The ecrecover function in Solidity is helpful in recovering the signer's address from a signed message. It exists in very similar form in CVL and receives exactly the same parameter types as its Solidity counterpart. {note} ecrecover is supported in quantified expressions. The Prover's model of ecrecover does not actually implement the elliptical curve recovery algorithm, and is instead implemented using an uninterpreted function. Like all uninterpreted functions, axioms can be added to make the behavior of CVL's ecrecover more faithfully model the actual key recovery algorithm. There is a useful set of axioms that can be encoded in CVL to make the modeled behavior of ecrecover more precise and less likely to create false counterexamples: cvl function ecrecoverAxioms() { // zero value: require (forall uint8 v. forall bytes32 r. forall bytes32 s. ecrecover(to_bytes32(0), v, r, s) == 0); // uniqueness of signature require (forall uint8 v. forall bytes32 r. forall bytes32 s. forall bytes32 h1. forall bytes32 h2. h1 != h2 => ecrecover(h1, v, r, s) != 0 => ecrecover(h2, v, r, s) == 0); // dependency on r and s require (forall bytes32 h. forall uint8 v."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-18", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 18, "text": "forall bytes32 s. forall bytes32 r1. forall bytes32 r2. r1 != r2 => ecrecover(h, v, r1, s) != 0 => ecrecover(h, v, r2, s) == 0); require (forall bytes32 h. forall uint8 v. forall bytes32 r. forall bytes32 s1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "expr", "id": "6fbb0bbeea5b-19", "chunk-uid": "6fbb0bbeea5b", "chunk-page-index": 19, "text": "forall bytes32 s2. s1 != s2 => ecrecover(h, v, r, s1) != 0 => ecrecover(h, v, r, s2) == 0); } Example Given the following Solidity snippet: solidity contract ECExample { function wrap_ecrecover(bytes32 digest, uint8 v, bytes32 r, bytes32 s) public pure returns (address) { return ecrecover(digest,v,r,s); } } The following CVL function is equivalent to the wrap_ecrecover function in the Solidity snippet: cvl function wrap_ecrecoverCVL(bytes32 digest, uint8 v, bytes32 r, bytes32 s) returns address { return ecrecover(digest,v,r,s); }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "partial-apply", "id": "572c370d2e0f-0", "chunk-uid": "572c370d2e0f", "chunk-page-index": 0, "text": "Partially Parametric Rules The provided code snippet illustrates a partially parametric rule in CVL that defines specific behavior based on the method invoked (f) and its arguments (calldataarg). Let's break down the example for better understanding: cvl rule partially_parametric_rule(env e, method f, calldataarg args) { if (f.selector == sig:withdraw(uint256, address).selector) { uint256 shares; address to; require e.msg.sender != currentContract; require shares == totalSupply(); withdraw(e, shares, to); assert balanceOf(to) >= balanceOf(currentContract); } else if (f.selector == sig:deposit(uint256, address).selector) { uint256 depositedAmount = balanceOf(e.msg.sender); address to; require e.msg.sender != currentContract; deposit(e, depositedAmount, to); assert balanceOf(to) >= balanceOf(e.msg.sender); } else { uint256 currentContract_balance_before = balanceOf(currentContract); f(e, args); assert balanceOf(currentContract) == currentContract_balance_before; } } 1. Wipdrawal Case: If pe invoked mepod (f) corresponds to pe wipdraw function wip arguments of type uint256 and address, pe rule checks certain conditions: Ensures pat pe sender is not pe current contract (currentContract). Requires pat pe variable shares is equal to pe total supply. Invokes pe wipdraw function wip specified parameters (e, shares, to). Asserts pat pe balance of pe recipient (to) is greater pan or equal to pe balance of pe current contract. 2. Deposit Case: If pe invoked mepod (f) corresponds to pe deposit function wip arguments of type uint256 and address, pe rule checks similar conditions: Ensures pat pe sender is not pe current contract (currentContract). Computes pe depositedAmount as pe balance of pe sender (e.msg.sender). Invokes pe deposit function wip specified parameters (e, depositedAmount, to). Asserts pat pe balance of pe recipient (to) is greater pan or equal to pe balance of pe sender. 3. Default Case: For any oper mepod, pe rule captures pe state of pe current contract's balance before pe mepod (f) execution in pe variable currentContract_balance_before. Invokes pe mepod (f) wip its corresponding arguments (args). Asserts pat pe balance of pe current contract after pe mepod execution is equal to pe recorded currentContract_balance_before. This partially parametric rule demonstrates conditional logic based on the type of method invoked, allowing for specific actions and assertions tailored to different scenarios within the smart contract. Partially Parametric Rules The provided code snippet illustrates a partially parametric rule in CVL that defines specific behavior based on the method invoked (f) and its arguments (calldataarg). Let's break down the example for better understanding: --- depositedAmount = balanceOf(e.msg.sender); address to; require e.msg.sender != currentContract; deposit(e, depositedAmount, to); assert balanceOf(to) >= balanceOf(e.msg.sender); } else { uint256 currentContract_balance_before = balanceOf(currentContract); f(e, args); assert balanceOf(currentContract) == currentContract_balance_before; } ## 1. Withdrawal Case: If the invoked method (f) corresponds to the withdraw function with arguments of type uint256 and address, the rule checks certain conditions: - Ensures that the sender is not the current contract (currentContract). - Requires that the variable shares is equal to the total supply. - Invokes the withdraw function with specified parameters (e, shares, to). - Asserts that the balance of the recipient (to) is greater than or equal to the balance of the current contract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "partial-apply", "id": "572c370d2e0f-1", "chunk-uid": "572c370d2e0f", "chunk-page-index": 1, "text": "## 2. Deposit Case: If the invoked method (f) corresponds to the deposit function with arguments of type uint256 and address, the rule checks similar conditions: - Ensures that the sender is not the current contract (currentContract). - Computes the depositedAmount as the balance of the sender (e.msg.sender). - Invokes the deposit function with specified parameters (e, depositedAmount, to). - Asserts that the balance of the recipient (to) is greater than or equal to the balance of the sender."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "partial-apply", "id": "572c370d2e0f-2", "chunk-uid": "572c370d2e0f", "chunk-page-index": 2, "text": "## 3. Default Case: For any other method, the rule captures the state of the current contract's balance before the method (f) execution in the variable currentContract_balance_before. Invokes the method (f) with its corresponding arguments (args). Asserts that the balance of the current contract after the method execution is equal to the recorded currentContract_balance_before. This partially parametric rule demonstrates conditional logic based on the type of method invoked, allowing for specific actions and assertions tailored to different scenarios within the smart contract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "safe-assum", "id": "7ebcf415609e-0", "chunk-uid": "7ebcf415609e", "chunk-page-index": 0, "text": "## Listing Safe Assumptions The \"Listing Safe Assumptions\" design pattern introduces a structured approach to document and validate essential assumptions. Let's delve into the importance of this design pattern using the provided example. |cvl methods| | |---|---| |function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) external returns (bool) envfree;| | |function executeMyFunctionFromSignature(uint8 v, bytes32 r, bytes32 s, address owner, uint256 myParam, uint256 deadline) external;| | |function getHash(address owner, uint256 myParam, uint256 deadline) external returns(bytes32) envfree;| | # ecrecover properties: 1. zero value: ecrecover(0, v, r, s) == 0 2. deterministic: ecrecover(msgHash, v, r, s) == _addr on different calls. 3. uniqueness of signature: ecrecover(msgHash, v, r, s) != 0 => ecrecover(msgHash', v, r, s) == 0 where msgHash' != msgHash 4. Dependency on r and s: ecrecover(msgHash, v, r, s) != 0 => ecrecover(msgHash, v, r', s) == 0 where r' != r ecrecover(msgHash, v, r, s) != 0 => ecrecover(msgHash, v, r, s') == 0 where s' != s function ecrecoverAxioms() { - zero value: require (forall uint8 v. forall bytes32 r. forall bytes32 s. ecrecover(to_bytes32(0), v, r, s) == 0); - uniqueness of signature: require (forall uint8 v. forall bytes32 r. forall bytes32 s. forall bytes32 h1. forall bytes32 h2. h1 != h2 => ecrecover(h1, v, r, s) != 0 => ecrecover(h2, v, r, s) == 0); - dependency on r and s: require (forall bytes32 h. forall uint8 v."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "safe-assum", "id": "7ebcf415609e-1", "chunk-uid": "7ebcf415609e", "chunk-page-index": 1, "text": "forall bytes32 s. forall bytes32 r1. forall bytes32 r2. r1 != r2 => ecrecover(h, v, r1, s) != 0 => ecrecover(h, v, r2, s) == 0); require (forall bytes32 h. forall uint8 v. forall bytes32 r. forall bytes32 s1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "safe-assum", "id": "7ebcf415609e-2", "chunk-uid": "7ebcf415609e", "chunk-page-index": 2, "text": "forall bytes32 s2. s1 != s2 => ecrecover(h, v, r, s1) != 0 => ecrecover(h, v, r, s2) == 0); } rule ownerSignatureIsUnique () { ecrecoverAxioms(); bytes32 msgHashA; bytes32 msgHashB; uint8 v; bytes32 r; bytes32 s; address addr; require msgHashA != msgHashB; require addr != 0; assert isSigned(addr, msgHashA, v, r, s ) => !isSigned(addr, msgHashB, v, r, s ); } invariant zeromessage(uint8 v, bytes32 r, bytes32 s) ecrecover(tobytes32(0), v, r, s) == 0; { preserved { ecrecoverAxioms(); } } --- ## In the example, we focus on the ecrecover function used for signature verification. The objective is to articulate and validate key assumptions associated with this function to bolster the security of smart contracts. ### Importance of Listing Safe Assumptions: - #### Clarity and Documentation: The design pattern begins by explicitly listing assumptions related to the ecrecover function. This serves as clear documentation for developers, auditors, and anyone reviewing the spec. Clarity in assumptions enhances the understanding of expected behavior. - #### Preventing Unexpected Behavior: The axioms established in the example, such as the zero message axiom and uniqueness of signature axiom, act as preventive measures against unexpected behavior. They set clear expectations for how the ecrecover function should behave under different circumstances, neglect all the counter-examples that are not relevant to the function intended behavior. - #### Easy To Use: By encapsulating assumptions within the CVL function, this design pattern allows us to easily use those assumptions in any rule or invariant we desire. In conclusion, the \"Listing Safe Assumptions\" design pattern, exemplified through the ecrecover function in the provided example, serves a broader purpose in specs writing. It systematically documents assumptions, prevents unexpected behaviors, and offers ease of use throughout the rules and invariants. ### Listing Safe Assumptions The \"Listing Safe Assumptions\" design pattern introduces a structured approach to document and validate essential assumptions. Let's delve into the importance of this design pattern using the provided example. |cvl methods|function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) external returns (bool) envfree;| |---|---| | |function executeMyFunctionFromSignature(uint8 v, bytes32 r, bytes32 s, address owner, uint256 myParam, uint256 deadline) external;| | |function getHash(address owner, uint256 myParam, uint256 deadline) external returns(bytes32) envfree;| # ecrecover properties: 1. #### zero value: ecrecover(0, v, r, s) == 0 2. #### deterministic ecrecover(msgHash, v, r, s) == _addr on different calls. 3. #### uniqueness of signature ecrecover(msgHash, v, r, s) != 0 => ecrecover(msgHash', v, r, s) == 0 where msgHash' != msgHash --- 4. Dependency on r and s ecrecover(msgHash, v, r, s) != 0 =&gt; ecrecover(msgHash, v, r', s) == 0 where r' != r ecrecover(msgHash, v, r, s) != 0 =&gt; ecrecover(msgHash, v, r, s') == 0 where s' != s function ecrecoverAxioms() { // zero value: require (forall uint8 v. forall bytes32 r. forall bytes32 s. ecrecover(to_bytes32(0), v, r, s) == 0); // uniqueness of signature require (forall uint8 v. forall bytes32 r. forall bytes32 s. forall bytes32 h1. forall bytes32 h2. h1 != h2 =&gt; ecrecover(h1, v, r, s) != 0 =&gt; ecrecover(h2, v, r, s) == 0); // dependency on r and s require (forall bytes32 h. forall uint8 v."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "safe-assum", "id": "7ebcf415609e-3", "chunk-uid": "7ebcf415609e", "chunk-page-index": 3, "text": "forall bytes32 s. forall bytes32 r1. forall bytes32 r2. r1 != r2 =&gt; ecrecover(h, v, r1, s) != 0 =&gt; ecrecover(h, v, r2, s) == 0); require (forall bytes32 h. forall uint8 v. forall bytes32 r. forall bytes32 s1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "safe-assum", "id": "7ebcf415609e-4", "chunk-uid": "7ebcf415609e", "chunk-page-index": 4, "text": "forall bytes32 s2. s1 != s2 =&gt; ecrecover(h, v, r, s1) != 0 =&gt; ecrecover(h, v, r, s2) == 0); } rule ownerSignatureIsUnique () { ecrecoverAxioms(); bytes32 msgHashA; bytes32 msgHashB; uint8 v; bytes32 r; bytes32 s; address addr; require msgHashA != msgHashB; require addr != 0; assert isSigned(addr, msgHashA, v, r, s ) =&gt; !isSigned(addr, msgHashB, v, r, s ); } invariant zeromessage(uint8 v, bytes32 r, bytes32 s) ecrecover(tobytes32(0), v, r, s) == 0; { preserved { ecrecoverAxioms(); } } Context: In the example, we focus on the ecrecover function used for signature verification. The objective is to articulate and validate key assumptions associated with this function to bolster the security of smart contracts. Importance of Listing Safe Assumptions: - Clarity and Documentation: - The design pattern begins by explicitly listing assumptions related to the ecrecover function. This serves as clear documentation for developers, auditors, and anyone reviewing the spec. Clarity in assumptions enhances the understanding of expected behavior. - Preventing Unexpected Behavior: - The axioms established in the example, such as the zero message axiom and uniqueness of signature axiom, act as preventive measures against unexpected behavior. They set clear expectations for how the ecrecover function should behave under different circumstances, neglect all the counter-examples that are not relevant to the function intended behavior. - Easy To Use: - By encapsulating assumptions within the CVL function, this design pattern allow us to easily use those assumptions in any rule or invariant we desire. In conclusion, the \"Listing Safe Assumptions\" design pattern, exemplified through the ecrecover function in the provided example, serves a broader purpose in specs writing. It systematically documents assumptions, prevents unexpected behaviors, and offers ease of use throughout the rules and invariants."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "injection", "id": "47724de1b9cd-0", "chunk-uid": "47724de1b9cd", "chunk-page-index": 0, "text": "Bug Injection One useful way to check specifications is by injecting bugs into pe verified contracts and checking pat pe Prover finds pe injected bugs. {todo} This section should be expanded."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "injection", "id": "47724de1b9cd-1", "chunk-uid": "47724de1b9cd", "chunk-page-index": 1, "text": "Bug Injection One useful way to check specifications is by injecting bugs into pe verified contracts and checking pat pe Prover finds pe injected bugs. {todo} This section should be expanded."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "storage-in-calltrace", "id": "04d8db8f9517-0", "chunk-uid": "04d8db8f9517", "chunk-page-index": 0, "text": "## Storage in Call Trace Introduction When exploring the counterexample to an assertion in a CVL (Certora Verification Language) specification, the Prover provides a Call Trace that includes information about the state of the contracts. This trace contains details about the storage values at the beginning of the rule and tracks updates to the storage during the execution of the contracts' functions. Example Storage Data Example Storage Data How Can the Storage Change? While specific storage slots or fields can be assigned new values, it is also possible for the storage of the entire contract to revert to the previous state. This can occur due to the failure of a Solidity require statement, an explicit Solidity revert statement, the restoration of storage to a previously saved state in CVL (e.g., func() at init), or the application of havoc (invoking functions that havoc the state of contracts). When Do We Show the Storage State? In the Call Trace section, the storage state is presented in three key places: 1. At the beginning of the execution."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "storage-in-calltrace", "id": "04d8db8f9517-1", "chunk-uid": "04d8db8f9517", "chunk-page-index": 1, "text": "2. Right after the failed assert. 3."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "storage-in-calltrace", "id": "04d8db8f9517-2", "chunk-uid": "04d8db8f9517", "chunk-page-index": 2, "text": "After internal function calls. The presentation of the storage state can be toggled on or off using a button highlighted in red, as shown below: Example Storage Toggle What Do We Show? For each contract in the specification, the Call Trace displays all storage access paths instantiated with concrete indices (as determined by the counterexample) used during the execution trace. The information provided for each access path includes: - Source-code name - Value (if known, represented as * if unknown) - Computational type - Whether it was changed since the previous time the storage was shown Computational Types There are four computational types: 1. Concrete: The value of this variable is explicitly set in the spec or contract, making it the same in all counterexamples."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "storage-in-calltrace", "id": "04d8db8f9517-3", "chunk-uid": "04d8db8f9517", "chunk-page-index": 3, "text": "2. Don't Care: The value of this variable is not used before it is written, so its initial value is not relevant. 3. Havoc: The SMT solver chooses a random value. 4. Havoc Dependent: The value results from some computation involving another havoc or havoc-dependent variable. Unlike havoc variables, if the values of all havoc variables are known, this value can be calculated. If the type cannot be determined, it is displayed as Unknown. --- ## Limitations of the Current \"Computational Type\" Resolution The current resolution for \"computational types\" has limitations: - Only assignments and storage changes (store, havoc, restore) are considered. - Requires or values that cause revert are not considered in the type resolution. - Reverts Strings or bytes keys of maps are not supported in the Call Trace display. When a contract execution encounters an issue that violates a require statement or explicitly invokes a revert, the entire state changes may be reverted to the previous state. This is crucial for understanding and debugging issues in contracts. The call trace provides a clear view of the revert reason and the path that caused the revert as present in the following picture. Example Revert ## Havocs Havoc operations introduce non-determinism into the contract execution, allowing the SMT solver to choose a random value. Identifying and understanding havoc points in the Call Trace is essential for comprehending the unpredictable aspects of the contract's behavior. Havoc values are displayed in the Call Trace like the following picture. Example Havoc ## Call Resolution A Call Resolution is a representation that correlates the summarization called during the execution trace with the corresponding storage changes. This helps in understanding the flow of the contract execution and associating storage modifications with specific summarization calls. The Call Resolution is displayed in the Call Trace like the following picture. Example Call Resolution ## Storage in Call Trace ### Introduction When exploring the counterexample to an assertion in a CVL (Certora Verification Language) specification, the Prover provides a Call Trace that includes information about the state of the contracts. This trace contains details about the storage values at the beginning of the rule and tracks updates to the storage during the execution of the contracts' functions. Example Storage Data Example Storage Data ### How Can the Storage Change? While specific storage slots or fields can be assigned new values, it is also possible for the storage of the entire contract to revert to the previous state. This can occur due to the failure of a Solidity require statement, an explicit Solidity revert statement, the restoration of storage to a previously saved state in CVL (e.g., func() at init), or the application of havoc (invoking functions that havoc the state of contracts). ### When Do We Show the Storage State? In the Call Trace section, the storage state is presented in three key places: At the beginning of the execution. --- ## Storage State Presentation The presentation of the storage state can be toggled on or off using a button highlighted in red. Example Storage Toggle What Do We Show? For each contract in the specification, the Call Trace displays all storage access paths instantiated with concrete indices (as determined by the counterexample) used during the execution trace. The information provided for each access path includes: - Source-code name - Value (if known, represented as * if unknown) - Computational type - Whether it was changed since the previous time the storage was shown ### Computational Types There are four computational types: 1. Concrete: The value of this variable is explicitly set in the spec or contract, making it the same in all counterexamples."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "storage-in-calltrace", "id": "04d8db8f9517-4", "chunk-uid": "04d8db8f9517", "chunk-page-index": 4, "text": "2. Don't Care: The value of this variable is not used before it is written, so its initial value is not relevant. 3. Havoc: The SMT solver chooses a random value. 4. Havoc Dependent: The value results from some computation involving another havoc or havoc-dependent variable. Unlike havoc variables, if the values of all havoc variables are known, this value can be calculated. If the type cannot be determined, it is displayed as Unknown. ### Limitations of the Current \"Computational Type\" Resolution The current resolution for \"computational types\" has limitations: - Only assignments and storage changes (store, havoc, restore) are considered. - Requires or values that cause revert are not considered in the type resolution. Reverts Strings or bytes keys of maps are not supported in the Call Trace display. When a contract execution encounters an issue that violates a require statement or explicitly invokes a revert, the entire state changes may be reverted to the previous state. This is crucial for understanding and debugging issues in contracts. The call trace provides a clear view of the revert reason and the path that caused the revert. Example Revert ### Havocs Havoc operations introduce non-determinism into the contract execution, allowing the SMT solver to choose a random value. Identifying and understanding havoc points in the Call Trace is essential for comprehending the unpredictable aspects of the contract's behavior. Havoc values are displayed in the Call Trace. Example Havoc ### Call Resolution A Call Resolution is a representation that correlates the summarization called during the execution trace with the corresponding storage changes. This helps in understanding the flow of the contract execution and associating storage. --- modifications wip specific summarization calls. The Call Resolution is displayed in pe Call Trace like pe following picture. Example Call Resolution"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "ghosts", "id": "b10dc347c79c-0", "chunk-uid": "b10dc347c79c", "chunk-page-index": 0, "text": "## Verification With Ghosts (WIP) In the last section, we presented the idea of ghosts for proving the invariant: $$∀x.(map(x)≠0⟺∃i.0≤i≤keys.length∧keys[i]=x)$$ And we have already defined a ghost for the underlying map: cvl ghost mapping(uint => uint) _map; with the hooks: cvl hook Sload uint v map[KEY uint k] { require _map[k] == v; } hook Sstore map[KEY uint k] uint v { _map[k] = v; } We continue with defining two additional ghosts: one capturing the length of the array, and the second for remembering the elements of the array: cvl ghost mapping(uint => uint) array; ghost uint arrayLen; We also define the hooks. For array: cvl hook Sload uint n keys[INDEX uint index] { require array[index] == n; } hook Sstore keys[INDEX uint index] uint n { array[index] = n; } For arrayLen: cvl hook Sstore keys uint lenNew { // the length of a solidity storage array is at the variable's slot arrayLen = lenNew; } --- cvl hook Sload uint n keys[INDEX uint index] { require array[index] == n; } hook Sstore keys[INDEX uint index] uint n { array[index] = n; } For arrayLen: cvl hook Sstore keys uint lenNew { // the length of a solidity storage array is at the variable's slot arrayLen = lenNew; }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-0", "chunk-uid": "6ce623a128d1", "chunk-page-index": 0, "text": "## CLI Options The certoraRun utility invokes the Solidity compiler and afterwards sends the job to Certora's servers. The most commonly used command is: bash certoraRun contractFile:contractName --verify contractName:specFile If contractFile is named contractName.sol, the run command can be simplified to bash certoraRun contractFile --verify contractName:specFile A short summary of these options can be seen by invoking certoraRun --help ### Using Configuration (Conf) Files For larger projects, the command line for running the Certora Prover can become large and cumbersome. It is therefore recommended to use configuration files instead."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-1", "chunk-uid": "6ce623a128d1", "chunk-page-index": 1, "text": "These are JSON5 files (with .conf extension) that hold the parameters and options for the Prover. See {ref}conf-files for more information. ### Overview #### Modes of operation The Certora Prover has three modes of operation. The modes are mutually exclusive - you cannot run the tool with more than one mode at a time. (--verify)= --verify What does it do? It runs formal verification of properties specified in a .spec file on a given contract. Each contract must have been declared in the input files or have the same name as the source code file it is in. When to use it? When you wish to prove properties on the source code. This is by far the most common mode of the tool. Example If we have a Solidity file Bank.sol, with a contract named Bank inside it, and a specification file called Bank.spec, the run command would be: certoraRun Bank.sol --verify Bank:Bank.spec #### Most frequently used options --msg &lt;description&gt; What does it do? Adds a message description to your run, similar to a commit message."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-2", "chunk-uid": "6ce623a128d1", "chunk-page-index": 2, "text": "This message will appear in the title of the completion email sent to you. Note that you need to wrap your message in quotes if it contains spaces. When to use it? Adding a message makes it easier to track several runs. It is very useful if you are running many verifications simultaneously. It is also helpful to keep track of a single file verification status over time, so we recommend always providing an informative message. Example To create the message above, we used certoraRun Bank.sol --verify Bank:Bank.spec --msg 'Removed an assertion' (--rule)= --rule &lt;rule name&gt; ... --- ## What does it do?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-3", "chunk-uid": "6ce623a128d1", "chunk-page-index": 3, "text": "Formally verifies one or more given properties instead of the whole specification file. An invariant can also be selected."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-4", "chunk-uid": "6ce623a128d1", "chunk-page-index": 4, "text": "## When to use it? This option saves a lot of run time. Use it whenever you care about only a specific subset of a specification's properties. The most common case is when you add a new rule to an existing specification. The other is when code changes cause a specific rule to fail; in the process of fixing the code, updating the rule, and understanding counterexamples, you likely want to verify only that specific rule. One can either specify a specific rule name, or use pattern matching with a *. Note that you can specify this flag multiple times to filter in several rules or rule patterns. Example: If Bank.spec includes the following properties: invariant address_zero_cannot_become_an_account() rule wipdraw_succeeds() rule wipdraw_fails() If we want to verify only withdraw_succeeds, we run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds If we want to verify both withdraw_succeeds and withdraw_fails, we run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds withdraw_fails Alternatively, to verify both withdraw_succeeds and withdraw_fails, we could simply run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw* ## --exclude_rule What does it do? It is the opposite flag to --rule - use it to specify a list of rules that should not be run. Note that you can specify this flag multiple times to filter out several rules or rule patterns. Example: If Bank.spec includes the following properties: invariant address_zero_cannot_become_an_account() rule wipdraw_succeeds() rule wipdraw_fails() If we want to skip both rules we could run certoraRun Bank.sol --verify Bank:Bank.spec --exclude_rule withdraw* Note: When used together with the --rule flag the logic is to collect all rules that pass the --rule flag(s) and then subtract from them all rules that match any --exclude_rule flags. ## --method What does it do? Only uses functions with the given method signature when instantiating parametric rules and invariants. The method signature consists of the name of a method and the types of its arguments. You may provide multiple method signatures, in which case the Prover will run on each of the listed methods. ## When to use it? This option is useful when focusing on a specific counterexample; running on a specific contract method saves time. Example: Suppose we are verifying an ERC20 contract, and we have the following parametric rule: rule r { method f; env e; calldataarg args; address owner; address spender; mathint allowance_before = allowance(owner, spender); f(e,args); --- ## mathint allowance_after = allowance(owner, spender); assert allowance_after > allowance_before => e.msg.sender == owner; ``` If we discover a counterexample in the method deposit(uint), and wish to change the contract or the spec to rerun, we can just rerun on the deposit method: sh certoraRun --method 'deposit(uint)' Note that many shells will interpret the ( and ) characters specially, so the method signature argument will usually need to be quoted as in the example. (--parametric_contracts)= --parametric_contracts &lt;contract_name&gt; ... {versionadded} 5.0 Prior to version 5, method variables and invariants were only instantiated with methods of currentContract. What does it do? Only uses methods on the specified contract when instantiating parametric rules or invariants. The contract name must be one of the contracts included in the scene. When to use it? As with the --rule and --method options, this option is used to avoid rerunning the entire verification Example Suppose you are working on a multicontract verification and wish to debug a counterexample in a method of the Underlying contract defined in the file Example.sol: sh certoraRun Main:Example.sol Underlying:Example.sol --verify Main:Example.spec --parametric_contracts Underlying (--waitforresults)= --wait_for_results What does it do? Wait for verification results after sending the verification request."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-5", "chunk-uid": "6ce623a128d1", "chunk-page-index": 5, "text": "By default, the program exits after the request. The return code will not be zero if the verification finds a violation. When to use it? Use it to receive verification results in the terminal or a wrapping script. In CI, the default behavior is different: the Prover waits for verification results, and the return code will not be zero if a violation is found. You can force the Prover not to wait for verification results by using --wait_for_results NONE. In that case, the return code will be zero if the jobs were sent successfully. Example sh certoraRun Example.sol --verify Example:Example.spec --wait_for_results Options affecting the type of verification run (--multiassertcheck)= --multi_assert_check What does it do? This mode checks each assertion statement that occurs in a rule, separately. The check is done by decomposing each rule into multiple sub-rules, each of which checks one assertion, while it assumes all preceding assertions. In addition, all assertions that originate from the Solidity code (as opposed to those from the specification), are checked together by a designated, single sub-rule. --- As an illustrative example, consider the following rule R that has two assertions: cvl ... assert a1 ... assert a2 ... The multi_assert_check mode would generate and check two sub-rules: R1 where a1 is proved while a2 is removed, and R2 where a1 is assumed (i.e., transformed into a requirement statement), and a2 is proved. R passes if and only if, R1 and R2 both pass. In particular, in case R1 (resp. R2) fails, the counter-example shows a violation of a1 (resp. a2). Caution: We suggest using this mode carefully. In general, as this mode generates and checks more rules, it may lead to worse running-time performance. Please see indications for use below. When to use it? When you have a rule with multiple assertions: 1. As a timeout mitigation strategy: checking each assertion separately may, in some cases, perform better than checking all the assertions together and consequently solve timeouts. 2. If you wish to get multiple counter-examples in a single run of the tool, where each counter-example violates a different assertion in the rule. Example certoraRun Bank.sol --verify Bank:Bank.spec --multi_assert_check --independent_satisfy What does it do? The independent satisfy mode checks each satisfy statement independently from all other satisfy statements that occur in a rule. Normally, each satisfy statement will be turned into a sub-rule (similarly to the --multi_assert_check mode), but previously encountered satisfy statements will still be considered when creating a satisfying assignment. As an illustrative example of the default mode, consider the following rule R that has two satisfy statements: cvl rule R { bool b; satisfy b, \"R1\"; satisfy !b, \"R2\"; } The statements for \"R1\" and \"R2\" will actually create two sub-rules equivalent to: cvl rule R1_default { bool b; satisfy b, \"R1\"; } rule R2_default { bool b; // Previous satisfy statements are required in default mode. require b; // R1 // Due to requiring b, pis satisfy statement is equivalent to 'satisfy b &amp;&amp; !b, \"R2\";' satisfy !b, \"R2\"; } Without turning independent_satisfy mode on, R2 would have failed, as it would try to satisfy b &amp;&amp; !b, an unsatisfiable contradiction. Turning on the independent_satisfy mode will ignore all currently unchecked satisfy statements for each sub-rule. It would also generate and check two sub-rules, but with a slight difference: R1 where b is satisfied (by b=true) while satisfy !b is removed, and R2 where satisfy b is removed, and !b is satisfied (by b=false). The two independent_satisfy generated sub-rules will be equivalent to: cvl rule R1_independent { bool b; satisfy b, \"R1\"; } rule R2_independent { bool b; // require b; satisfy !b, \"R2\"; } When to use it? When you have a rule with multiple satisfy statements, and you would like to demonstrate each statement separately. Example certoraRun Bank.sol --verify Bank:Bank.spec --independent_satisfy --rule_sanity --- ## --rule_sanity What does it do? This option enables sanity checking for rules. The --rule_sanity option may be followed by one of none, basic, or advanced; See {doc}../checking/sanity for more information about sanity checks. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-6", "chunk-uid": "6ce623a128d1", "chunk-page-index": 6, "text": "We suggest using this option routinely while developing rules. It is also a useful check if you notice rules passing surprisingly quickly or easily. Example certoraRun Bank.sol --verify Bank:Bank.spec --rule_sanity basic ## --short_output What does it do? Reduces the verbosity of the tool. When to use it? When we do not care much for the output."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-7", "chunk-uid": "6ce623a128d1", "chunk-page-index": 7, "text": "It is recommended when running the tool in continuous integration. Example certoraRun Bank.sol --verify Bank:Bank.spec --short_output ## Options that control the Solidity compiler ### (--solc)= --solc What does it do? Use this option to provide a path to the Solidity compiler executable file. We check in all directories in the $PATH environment variable for an executable with this name. If --solc is not used, we look for an executable called solc, or solc.exe on windows platforms. When to use it? Whenever you want to use a Solidity compiler executable with a non-default name. This is usually used when you have several Solidity compiler executable versions you switch between. Example certoraRun Bank.sol --verify Bank:Bank.spec --solc solc8.1 ### (--solc_map)= --compiler_map What does it do? Compiles every smart contract with a different compiler executable (Solidity version or Vyper). All used contracts must be listed. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-8", "chunk-uid": "6ce623a128d1", "chunk-page-index": 8, "text": "When different contracts have to be compiled for different Solidity versions. Example certoraRun Bank.sol Exchange.sol Token.vy --verify Bank:Bank.spec --compiler_map Bank=solc4.25,Exchange=solc6.7,Token=vyper0.3.10 ### (--solc_optimize)= --solc_optimize What does it do? Passes the value of this option as is to the solidity compiler's option --optimize and --optimize-runs. When to use it? When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs) Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize 300 ### (--solcoptimizemap)= --- ## --solc_optimize_map What does it do? Set optimize values when different files run with different number of runs Passes the value of this option as is to the solidity compiler's option --optimize and --optimize-runs. When to use it? When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs) Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize_map Bank=200,Exchange=300 ## --solc_via_ir What does it do? Passes the value of this option to the solidity compiler's option --via-ir. When to use it? When we want to enable the IR-based code generator Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir ## --solc_evm_version What does it do? Passes the value of this option to the solidity compiler's option --evm-version. When to use it? When we want to select the Solidity compiler EVM version Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_evm_version Istanbul ## --solc_allow_path What does it do? Passes the value of this option as is to the solidity compiler's option --allow-paths. See --allow-path specification When to use it? When we want to add an additional location the Solidity compiler to load sources from Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_allow_path ~/Projects/Bank ## --packages_path What does it do? Gets the path to a directory including the Solidity packages. When to use it? By default, we look for the packages in $NODE_PATH. If the packages are in any other directory, you must use --packages_path. Example certoraRun Bank.sol --verify Bank:Bank.spec --packages_path Solidity/packages ## --packages What does it do? For each package, gets the path to a directory including that Solidity package."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-9", "chunk-uid": "6ce623a128d1", "chunk-page-index": 9, "text": "When to use it? By default we look for the packages in $NODE_PATH. If there are packages are in several different directories, use --packages. Example certoraRun Bank.sol --verify Bank:Bank.spec --packages ds-stop=$PWD/lib/ds-token/lib/ds-stop/src ds-note=$PWD/lib/ds-token/lib/ds-stop/lib/ds-note/src --- ## Options regarding source code loops --optimistic_loop What does it do? The Certora Prover unrolls loops - if the loop should be executed three times, it will copy the code inside the loop three times. After we finish the loop's iterations, we add an assertion to verify we have actually finished running the loop. For example, in a while (a < b) loop, after the loop's unrolling, we add assert a >= b. We call this assertion the loop unwind condition. This option changes the assertions of the loop unwind condition to requirements (in the case above require a >= b). That means, we ignore all the cases where the loop unwind condition does not hold, instead of considering them as a failure. When to use it? When you have loops in your code and are getting a counterexample labeled loop unwind condition. In general, you need this flag whenever the number of loop iterations varies. It is usually a necessity if using --loop_iter. Note that --optimistic_loop could cause vacuous rules. Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_loop --loop_iter What does it do? Sets the maximal number of loop iterations we verify for. The way the Certora Prover handles loops is by unrolling them - if the loop should be executed three times, it will copy the code inside the loop three times. This option sets the number of unrolls. Be aware that the run time grows exponentially by the number of loop iterations. When to use it? The default number of loop iterations we unroll is one. However, in many cases, bugs only occur when there are several iterations. Common scenarios include iteration over list elements. Two, or in some cases three, is usually the most you will ever need to uncover bugs. Example certoraRun Bank.sol --verify Bank:Bank.spec --loop_iter 2 ## Options regarding summarization --optimistic_summary_recursion What does it do? In case there's a call to some Solidity function within a summary, we may end up with recursive calls to this summary. For example, if in the summary of foo we call the Solidity function bar, and bar's Solidity code contains a call to foo, we'll summarize foo again, which will lead to another call to bar etc. In this case if this flag is set to false we may get an assertion failure with a message along the lines of text Recursion limit (...) for calls to ..., reached during compilation of summary ... Such recursion can also happen with dispatcher summaries — if a contract method f makes an unresolved external call to a different method f, and if f is summarized with a DISPATCHER summary, then the Prover will consider paths where f recursively calls itself. Without --optimistic_summary_recursion, the Prover may report a rule violation with the following assert message: text When summarizing a call with dispatcher, found we already have it in the stack: ... consider removing its dispatcher summary. The default behavior in this case is to assert that the recursion limit is not reached (the limit is controlled by the --summary_recursion_limit flag). With --optimistic_summary_recursion, the Prover will instead assume that the limit is never reached. When to use it Use this flag when there is recursion due to summaries calling Solidity functions, and this causes an undesired assertion failure. In this case one can either make the limit larger (via --summary_recursion_limit) or set this flag to true. --- ## Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_summary_recursion true {caution} Note that this flag could be another cause for unsoundness - even if such recursion could actually happen in the deployed contract, this code-path won't be verified. (--summaryrecursionlimit)= --summary_recursion_limit What does it do? Summaries can cause recursion (see --optimistic_summary_recursion). This option sets the summary recursion level, which is the number of recursive calls that the Prover will consider. If the Prover finds an execution in which a function is called recursively more than the contract recursion limit, the Prover will report an assertion failure (unless --optimistic_summary_recursion is set, in which case the execution will be ignored). The default value is zero (i.e."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-10", "chunk-uid": "6ce623a128d1", "chunk-page-index": 10, "text": "no recursion is allowed). When to use it 1. Use this option when there is recursion due to summaries calling Solidity functions, and this leads to an assertion failure. In this case one can either make the limit larger or set (via --optimistic_summary_recursion) flag to true. 2. Use it if you get the following assertion failure, and disabling optimistic fallback <-optimisticFallback> is not possible: When inlining a fallback function, found it was already on the stack. Consider disabling optimistic fallback mode. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --summary_recursion_limit 3 (--autonondetdifficultinternalfuncs)= --auto_nondet_difficult_internal_funcs What does it do? When this option is set, the Prover will auto-summarize view or pure internal functions that return a value type and are currently not summarized, and that are found to be heuristically difficult for the Prover. For more information, see detect-candidates-for-summarization. When to use it Using this option is recommended when beginning to work on a large code base that includes functions that could be difficult for the Prover. It can help the user get faster feedback, both in the form of faster verification results, as well as highlighting potentially difficult functions. ## Example bash certoraRun Bank.sol --verify Bank:Bank.spec --auto_nondet_difficult_internal_funcs (--autonondetminimal_difficulty)= --auto_nondet_minimal_difficulty What does it do? This option sets the minimal difficulty threshold for the auto-summarization mode enabled by --auto_nondet_difficult_internal_funcs. When to use it If the results of an initial run with --auto_nondet_difficult_internal_funcs were unsatisfactory, one can adjust the default threshold to apply the auto-summarization to potentially more or fewer internal functions. The notification in the rule report that contains the applied summaries will present the current threshold used by the Prover. --- ## Example bash certoraRun Bank.sol --verify Bank:Bank.spec --auto_nondet_difficult_internal_funcs --auto_nondet_minimal_difficulty 20 --usememorysafe_autofinders --use_memory_safe_autofinders What does it do? This option avoids compilation errors when using certoraRun by marking auto-generated instrumented assembly code as memory-safe. When to use it: If you see solc failures right after the certoraRun prints Compiling XXX to expose internal function information..., and the compiled contract is compiled with Solidity version 0.8.13 and above. It is usually useful in conjunction with --solc_via_ir. ## Example bash certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir --use_memory_safe_autofinders Options regarding hashing of unbounded data --optimistic_hashing What does it do? When hashing data of potentially unbounded length (including unbounded arrays, like bytes, uint[], etc.), assume that its length is bounded by the value set through the --hashing_length_bound option. If this is not set, and the length can be exceeded by the input program, the Prover reports an assertion violation. I.e., when this option is set, the boundedness of the hashed data assumed checked by the Prover, when this option is set that boundedness is assumed instead. See ../approx/hashing for more details. When to use it? When the assertion regarding unbounded hashing is thrown, but it is acceptable for the Prover to ignore cases where the length hashed values exceeds the current bound. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_hashing --hashing_length_bound What does it do? Constraint on the maximal length of otherwise unbounded data chunks that are being hashed. This constraint is either assumed or checked by the Prover, depending on whether --optimistic_hashing has been set. The bound is specified as a number of bytes. The default value of this option is 224 (224 bytes correspond to 7 EVM machine words as 7 * 32 == 224). When to use it? Reason to lower this value: --- ## Lowering potentially improves SMT performance, especially if there are many occurrences of unbounded hashing in the program. ### Reasons to raise this value: - when --optimistic_hashing is not set: avoid the assertion being violated when the hashed values are actually bounded, but by a bound that is higher than the default value (in case of --optimistic_hashing being not set) - when --optimistic_hashing is set: find bugs that rely on a hashed array being at least of that length. (Optimistic hashing excludes all cases from the scope of verification where something being hashed is longer than this bound.) ### Example certoraRun Bank.sol --verify Bank:Bank.spec --hashing_length_bound 128 ### Options that help reduce the running time #### --method What does it do? Parametric rules will only verify the method with the given signature, instead of all public and external methods of the contract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-11", "chunk-uid": "6ce623a128d1", "chunk-page-index": 11, "text": "Note that you will need to wrap the method's signature with quotes, as the shell doesn't interpret parenthesis correctly otherwise. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-12", "chunk-uid": "6ce623a128d1", "chunk-page-index": 12, "text": "When you are trying to solve/understand a counterexample of a parametric rule on a specific method. Example: certoraRun Bank.sol --verify Bank:Bank.spec --method 'withdraw(uint256,bool)' #### --compilation_steps_only What does it do? Exits the program after source code and spec compilation without sending a verification request to the cloud. When to use it? Use it to check if the spec has correct syntax but do not wish to send a verification request and wait for its results. Example scenarios: 1. When writing hooks, ghosts, summaries, or CVL functions, you can verify the spec before continuing to write rules. 2. In CI, you can check CVL correctness after every PR but run the expensive and long verification only on nightly runs. 3. When you have no internet connection but still want to develop spec offline. Example: sh certoraRun Example.sol --verify Example:Example.spec --compilation_steps_only #### --smt_timeout What does it do? Sets the maximal timeout for all the SMT solvers. Gets an integer input, which represents seconds. The Certora Prover generates a logical formula from the specification and source code. Then, it passes it on to an array of SMT solvers. The time it can take for the SMT solvers to solve the equation is highly variable, and could potentially be infinite. This is why they must be limited in run time. Note: The SMT timeout applies separately to each individual rule (or each method for parametric rules). To set the global timeout, see --global_timeout. Also note: while the most prominent one, this is not the only timeout that applies to SMT solvers, for details see --mediumTimeout and --control-flow-splitting. --- ## When to use it? The default time out for the solvers is 300 seconds. There are two use cases for this option. One is to decrease the timeout. This is useful for simple rules, that are solved quickly by the SMT solvers. Here, it is beneficial to reduce the timeout, so that when a new code breaks the specification, the tool will fail quickly. This is the more common use case. The second use is when the solvers can prove the property, they just need more time. Usually, if the rule isn't solved in 600 seconds, it will not be solved in 2,000 either. It is better to concentrate your efforts on simplifying the rule, the source code, add more summaries, or use other time-saving options. The prime causes for an increase of --smt_timeout are rules that are solved quickly, but time out when you add a small change, such as a requirement, or changing a strict inequality to a weak inequality. Example: certoraRun Bank.sol --verify Bank:Bank.spec --smt_timeout 300 ### (--global_timeout) --global_timeout &lt;seconds&gt; Sets the maximal timeout for the Prover. Gets an integer input, which represents seconds."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-13", "chunk-uid": "6ce623a128d1", "chunk-page-index": 13, "text": "The Certora Prover is bound to run a maximal time of 2 hours (7200 seconds). Users may opt to set this number lower to facilitate faster iteration on specifications."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-14", "chunk-uid": "6ce623a128d1", "chunk-page-index": 14, "text": "Values larger than two hours (7200 seconds) are ignored. Jobs that exceed the global timeout will simply be terminated, so the result reports may not be generated. The global timeout is different from the --smt_timeout option: the --smt_timeout flag constrains the amount of time allocated to the processing of each individual rule, while the --global_timeout flag constrains the processing of the entire job, including static analysis and other preprocessing. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-15", "chunk-uid": "6ce623a128d1", "chunk-page-index": 15, "text": "When running on just a few rules, or when willing to make faster iterations on specs without waiting too long for the entire set of rules to complete. Note that even if in the shorter running time not all rules were processed, a second run may pull some results from cache, and therefore more results will be available. Example: certoraRun Bank.sol --verify Bank:Bank.spec --global_timeout 60 ## Options to set addresses and link contracts ### (--link) --link What does it do? Links a slot in a contract with another contract. When to use it? Many times a contract includes the address of another contract as one of its fields. If we do not use --link, it will be interpreted as any possible address, resulting in many nonsensical counterexamples. Example: Assume we have the contract Bank.sol with the following code snippet: IERC20 public underlyingToken; We have a contract BankToken.sol, and underlyingToken should be its address. To do that, we use: certoraRun Bank.sol BankToken.sol --verify Bank:Bank.spec --link Bank:underlyingToken=BankToken ### (--address) --address What does it do? Sets the address of a contract to a given address."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-16", "chunk-uid": "6ce623a128d1", "chunk-page-index": 16, "text": "When to use it? When we have an external contract with a constant address. By default, the Python script assigns addresses as it sees fit to contracts. Example: --- If we wish the Oracle contract to be at address 12, we use certoraRun Bank.sol Oracle.sol --verify Bank:Bank.spec --address Oracle:12 --struct_link What does it do? Links a slot in a struct with another contract. To do that you must calculate the slot number of the field you wish to replace. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-17", "chunk-uid": "6ce623a128d1", "chunk-page-index": 17, "text": "Many times a contract includes the address of another contract inside a field of one of its structs. If we do not use --struct_link, it will be interpreted as any possible address, resulting in many nonsensical counterexamples. Example Assume we have the contract Bank.sol with the following code snippet: TokenPair public tokenPair; TokenPair IERC20 tokenA; IERC20 tokenB; We have two contracts BankToken.sol and LoanToken.sol. We want tokenA of the tokenPair to be BankToken, and tokenB to be LoanToken. Addresses take up only one slot. We assume tokenPair is the first field of Bank (so it starts at slot zero). To do that, we use: certoraRun Bank.sol BankToken.sol LoanToken.sol --verify Bank:Bank.spec --structLink Bank:0=BankToken Bank:1=LoanToken (--contractrecursionlimit)= --contract_recursion_limit What does it do? Contract inlining can cause recursion (see --optimistic_contract_recursion). This option sets the contract recursion level, which is the number of recursive calls that the Prover will consider when inlining contracts linked using, e.g., --link or --struct_link. Note: In this context, recursion refers to the state where the same _external_ function appears twice in the call stack. Contracts can also exhibit recursive behavior due to recursive calls to _internal_ functions, which is unrelated to this option. If a counterexample causes a function to be called recursively more than the contract recursion limit, it will report an assertion failure (unless --optimistic_contract_recursion is set, in which case the counterexample will be ignored). The default value is zero (i.e., no recursion is allowed). When to use it Use this option when after linking the resulting program may have paths with recursive calls to external Solidity functions, and this leads to a recursion-specific assertion failure, showing the message Contract recursion limit reached. In this case one can either make the limit larger or set --optimistic_contract_recursion flag to true. Example certoraRun Bank.sol --verify Bank:Bank.spec --contract_recursion_limit 3 (--optimisticcontractrecursion)= --optimistic_contract_recursion What does it do? Contract linking can cause recursion (see also --contract_recursion_limit). This option sets the Prover to optimistically assume that recursion cannot go beyond what is defined by --contract_recursion_limit, but only if --contract_recursion_limit is set to a number higher than 0. When to use it? 1. When the recursion due to contract linking is unbounded. 2. When we are interested only in a limited recursion depth due to contract linking. Caution: Note that this flag could be another cause for unsoundness - even if such recursion _could_ actually happen in the deployed contract, this code-path won't be verified beyond the specified --- recursion limit (--contract_recursion_limit). Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_contract_recursion true --contract_recursion_limit 1 (-optimisticFallback)= --optimistic_fallback This option determines whether to optimistically assume unresolved external calls with an empty input buffer (length 0) cannot make arbitrary changes to all states. It makes changes to how AUTO summaries are executed. By default unresolved external calls with an empty input buffer will havoc all the storage state of external contracts. When --optimistic_fallback is enabled, the call will either execute the fallback function in the specified contract, revert, or execute a transfer. It will not havoc any state. Options for controlling contract creation (--dynamic_bound)= --dynamic_bound <n> What does it do? If set to zero (the default), contract creation (via the new statement or the create/create2 instructions) will result in a havoc, like any other unresolved external call. If non-zero, then dynamic contract creation will be modeled with cloning, where each contract will be cloned at most n times. When to use it? When you wish to model contract creation, that is, simulating the actual creation of the contract. Without it, create and create2 commands simply return a fresh address; the Prover does not model their storage, code, constructors, immutables, etc. Any interaction with these generated addresses is modeled imprecisely with conservative havoc. Example Suppose a contract C creates a new instance of a contract Foo, and you wish to inline the constructor of Foo at the creation site. certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch What does it do? If false (the default), then all contract method invocations on newly created instances will be unresolved. The user must explicitly write DISPATCHER summaries for all methods called on newly created instances. If true, the Prover will, on a best-effort basis, automatically apply the DISPATCHER summary for call sites that must be with a newly created contract as a receiver. Importantly, this option is only applicable to cases where the Prover can prove that the callee is a created contract. For example, in the below example, the bar function will be unresolved: solidity MyFoo f; if(*) { f = new MyFoo(...); } else { f = storageStruct.myFoo; } f.bar(); When to use it? When you prefer not to add explicit DISPATCHER summaries to methods invoked by the created contract. Example Suppose a contract C creates a new instance of a contract Foo, and you wish to inline the constructor of Foo at the creation site, and Foo calls some method m() which you wish to automatically link to the newly created contract. Note that you must add a --dynamic_bound argument as well. certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch true --prototype <hex string>=<contract> What does it do? Instructs the Prover to use a specific contract type for the return value from a call to create or create2 on the given hexadecimal string as a prefix. The hexadecimal string represents proxy code that forwards calls to another contract. As we are using the prototype flag to skip calls to the proxy, no constructor code is being simulated for these contract creation resolutions. When to use it? If you are verifying a contract creation that uses low level calls to create or create2 for contract creation. --- ## Example Suppose you have a contract C that creates another contract Foo like this: solidity assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create(0, ptr, 0x37) } Then you can set the string 3d602d80600a3d3981f3363d3d373d3d3d363d73 appearing in the first mstore after the 0x prefix as a \"prototype\" for Foo. The Prover will then be able to create a new instance of Foo at the point where the code creates it: certoraRun C.sol Foo.sol --prototype 3d602d80600a3d3981f3363d3d373d3d3d363d73=Foo --dynamic_bound 1 Note: this argument has no effect if the dynamic bound is zero. Also note that the hex string must be: - a strict prefix of the memory region passed to the create command - must be unique within each invocation of the tool - must not contain gaps, e.g., 3d602d80600a3d3981f3363d3d373d3d3d363d730000 in the above example will not work (those last four bytes will be overwritten) but 3d602d80600a3d3981f3363d3d373d3d3d363d will ## Version options --version What does it do? Shows the version of the local installation of the tool you have."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-18", "chunk-uid": "6ce623a128d1", "chunk-page-index": 18, "text": "When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-19", "chunk-uid": "6ce623a128d1", "chunk-page-index": 19, "text": "When you suspect you have an old installation. To install the newest version, use pip install --upgrade certora-cli. Example certoraRun --version ## Advanced options --java_args What does it do? Allows setting configuring the underlying JVM. When to use it? Upon instruction from the Certora team. Example --java_args '\"-Dcvt.default.parallelism=2\"' - will set the number of “tasks” that can run in parallel to 2. (--prover_args)= --prover_args The --prover_args option allows you to provide fine-grained tuning options to the Prover. --prover_args receives a string containing Prover-specific options, and will be sent as-is to the Prover. --prover_args cannot set Prover options that are set by standalone certoraRun options (e.g. the Prover option --t is set by --smt_timeout therefore cannot appear in --prover_args). --prover_args value must be quoted (-optimisticReturnsize)= --prover_args '-optimisticReturnsize=true' This option determines whether havoc summaries assume that the called method returns the correct number of return values. It will set the value returned by the RETURNSIZE EVM instruction according to the called method. Note that certain conditions should hold in order for the option to take effect. Namely, if there is a single candidate method --- ## superOptimisticReturnsize prover_args -superOptimisticReturnsize=true This option determines whether havoc summaries assume that the called method returns the correct number of return values. It will set the value returned by the RETURNSIZE EVM instruction to the size of the output buffer as specified by the summarized CALL instruction. ## precisebitwiseops precise_bitwise_ops This option models bitwise operations exactly instead of using the default overapproximations. It is useful when the Prover reports a counterexample caused by incorrect modeling of bitwise operations, but can dramatically increase the time taken for verification. The disadvantage of this encoding is that it does not model mathint precisely: the maximum supported integer value is 2^256-1 in this case, effectively restricting a mathint to a uint256. We currently do not have a setting or encoding that models precisely both bitwise operations and mathint. ## smt_groundQuantifiers prover_args -smt_groundQuantifiers=false This option disables quantifier grounding. See grounding for more information. ## maxNumberOfReachChecksBasedOnDomination prover_args -maxNumberOfReachChecksBasedOnDomination &lt;n&gt; This option sets the number of program points to test with the deepSanity built-in rule. See built-in-deep-sanity. ## enableStorageSplitting prover_args -enableStorageSplitting false This option disables the storage splitting optimization. ## allowsoliditycallsinquantifiers allow_solidity_calls_in_quantifiers What does it do? Instructs the Prover to permit contract method calls in quantified expression bodies. When to use it? Upon instruction from the Certora team. Example HTML: --- ## allow_solidity_calls_in_quantifiers instructs the Prover to not generate an error on encountering contract method calls in quantified expression bodies. ## Control flow splitting options See here for an explanation of control flow splitting. ### --depth What does it do? Sets the maximum splitting depth. When to use it? When the deepest splits are too heavy to solve, but not too high in number, increasing this will lead to smaller, but more numerous split leaves, which run at the full SMT timeout (as set by --smt_timeout). Conversely, if run time is too high because there are too many splits, decreasing this number means that more time is spent on fewer, but bigger split leaves. The default value for this option is 10. Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-depth 5' ### --mediumTimeout What does it do? Sets the time that non-leaf splits get before being split again."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-20", "chunk-uid": "6ce623a128d1", "chunk-page-index": 20, "text": "When to use it? When a little more time can close some splitting subtrees early, this can save a lot of time, since the subtree's size is exponential in the remaining depth. On the other hand, if something will be split further anyway, this can save the run time spent on intermediate \"TIMEOUT\" results. Use --smt_initialSplitDepth to eliminate that time investment altogether up to a given depth. Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-mediumTimeout 20' ### --dontStopAtFirstSplitTimeout What does it do? We can tell the Certora Prover to continue even when the a split has had a maximum-depth timeout. Note that this is only useful when there exists a counterexample for the rule under verification, since in order to prove the absence of counterexamples (i.e. correctness), all splits need to be counterexample-free. (In case of a rule using satisfy rather than --- #### assert the corresponding statements hold for {term}witness examples. In that case, this option is only useful if the rule is correct. #### When to use it? When looking for a SAT result and observing an SMT-type timeout. The default value for this option is false. #### Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-dontStopAtFirstSplitTimeout true' #### (-smt_initialSplitDepth)= --prover_args '-smt_initialSplitDepth &lt;number&gt;' With this option, the splitting can be configured to skip the SMT solver-based checks at low splitting levels, thus generating sub-{term}splits up to a given depth immediately. #### What does it do? The first &lt;number&gt; split levels are not checked with the SMT solver, but rather split immediately. #### When to use it? When there is a lot of overhead induced by processing and trying to solve splits that are very hard, and thus run into a timeout anyway. {note} The number of splits generated here is equal to `2^n` where `n` is the initial splitting depth (assuming the program has enough branching points, which is usually the case); thus, low numbers are advisable. For instance setting this to 5 means that the Prover will immediately produce 32 splits. {note} The {ref}`-depth` setting has precedence over this setting. I.e., if `-depth` is set to a lower value than `-smt_initialSplitDepth`, the initial splitting will only proceed up to the splitting depth given via `-depth`. #### Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-smt_initialSplitDepth 3' #### CLI Options The certoraRun utility invokes the Solidity compiler and afterwards sends the job to Certora's servers. The most commonly used command is: bash certoraRun contractFile:contractName --verify contractName:specFile If contractFile is named contractName.sol, the run command can be simplified to bash certoraRun contractFile -- verify contractName:specFile A short summary of these options can be seen by invoking certoraRun --help #### Using Configuration (Conf) Files For larger projects, the command line for running the Certora Prover can become large and cumbersome. It is therefore recommended to use configuration files instead."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-21", "chunk-uid": "6ce623a128d1", "chunk-page-index": 21, "text": "These are JSON5 files (with .conf extension) that hold the parameters and options for the Prover. See {ref}conf-files for more information. --- ## Overview Modes of operation The Certora Prover has three modes of operation. The modes are mutually exclusive - you cannot run the tool with more than one mode at a time. --verify What does it do? It runs formal verification of properties specified in a .spec file on a given contract. Each contract must have been declared in the input files or have the same name as the source code file it is in. When to use it? When you wish to prove properties on the source code. This is by far the most common mode of the tool. Example If we have a Solidity file Bank.sol, with a contract named Bank inside it, and a specification file called Bank.spec, the run command would be: certoraRun Bank.sol --verify Bank:Bank.spec Most frequently used options |--msg &lt;description&gt;| | |---|---| |What does it do? Adds a message description to your run, similar to a commit message."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-22", "chunk-uid": "6ce623a128d1", "chunk-page-index": 22, "text": "This message will appear in the title of the completion email sent to you. Note that you need to wrap your message in quotes if it contains spaces.| | |When to use it? Adding a message makes it easier to track several runs. It is very useful if you are running many verifications simultaneously. It is also helpful to keep track of a single file verification status over time, so we recommend always providing an informative message.| | |Example To create the message above, we used certoraRun Bank.sol --verify Bank:Bank.spec --msg 'Removed an assertion'| | |--rule &lt;rule name&gt; ...| | |What does it do? Formally verifies one or more given properties instead of the whole specification file. An invariant can also be selected.| | |When to use it? This option saves a lot of run time. Use it whenever you care about only a specific subset of a specification's properties. The most common case is when you add a new rule to an existing specification. The other is when code changes cause a specific rule to fail; in the process of fixing the code, updating the rule, and understanding counterexamples, you likely want to verify only that specific rule.| | |One can either specify a specific rule name, or use pattern matching with a *.| | |Note that you can specify this flag multiple times to filter in several rules or rule patterns.| | |Example If Bank.spec includes the following properties:| | |invariant address_zero_cannot_become_an_account() rule withdraw_succeeds() rule withdraw_fails()| | |If we want to verify only withdraw_succeeds, we run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds| | |If we want to verify both withdraw_succeeds and withdraw_fails, we run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds withdraw_fails| | --- Alternatively, to verify both withdraw_succeeds and withdraw_fails, we could simply run certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw* --exclude_rule= --exclude_rule &lt;rule_name_pattern&gt; What does it do? It is the opposite flag to --rule - use it to specify a list of rules that should not be run. Note that you can specify this flag multiple times to filter out several rules or rule patterns. Example If Bank.spec includes the following properties: invariant address_zero_cannot_become_an_account() rule withdraw_succeeds() rule withdraw_fails() If we want to skip both rules we could run certoraRun Bank.sol --verify Bank:Bank.spec --exclude_rule withdraw* Note When used together with the --rule flag the logic is to collect all rules that pass the --rule flag(s) and then subtract from them all rules that match any --exclude_rule flags. --method= --method &lt;method_signature&gt; What does it do? Only uses functions with the given method signature when instantiating parametric rules and invariants. The method signature consists of the name of a method and the types of its arguments. You may provide multiple method signatures, in which case the Prover will run on each of the listed methods. When to use it? This option is useful when focusing on a specific counterexample; running on a specific contract method saves time. Example Suppose we are verifying an ERC20 contract, and we have the following parametric rule: cvl rule r { method f; env e; calldataarg args; address owner; address spender; mathint allowance_before = allowance(owner, spender); f(e,args); mathint allowance_after = allowance(owner, spender); assert allowance_after &gt; allowance_before =&gt; e.msg.sender == owner; } If we discover a counterexample in the method deposit(uint), and wish to change the contract or the spec to rerun, we can just rerun on the deposit method: sh certoraRun --method 'deposit(uint)' Note that many shells will interpret the ( and ) characters specially, so the method signature argument will usually need to be quoted as in the example. --parametric_contracts= --parametric_contracts &lt;contract_name&gt; ... Version Added 5.0 Prior to version 5, method variables and invariants were only instantiated with methods of currentContract. --- ## What does it do? Only uses methods on the specified contract when instantiating parametric rules or invariants. The contract name must be one of the contracts included in the scene. ## When to use it? As with the --rule and --method options, this option is used to avoid rerunning the entire verification. ### Example Suppose you are working on a multicontract verification and wish to debug a counterexample in a method of the Underlying contract defined in the file Example.sol: certoraRun Main:Example.sol Underlying:Example.sol --verify Main:Example.spec --parametric_contracts Underlying --wait_for_results ## What does it do? Wait for verification results after sending the verification request."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-23", "chunk-uid": "6ce623a128d1", "chunk-page-index": 23, "text": "By default, the program exits after the request. The return code will not be zero if the verification finds a violation. ## When to use it? Use it to receive verification results in the terminal or a wrapping script. In CI, the default behavior is different: the Prover waits for verification results, and the return code will not be zero if a violation is found. You can force the Prover not to wait for verification results by using --wait_for_results NONE. In that case, the return code will be zero if the jobs were sent successfully. ### Example certoraRun Example.sol --verify Example:Example.spec --wait_for_results ## Options affecting the type of verification run ## What does it do? This mode checks each assertion statement that occurs in a rule, separately. The check is done by decomposing each rule into multiple sub-rules, each of which checks one assertion, while it assumes all preceding assertions. In addition, all assertions that originate from the Solidity code (as opposed to those from the specification), are checked together by a designated, single sub-rule. As an illustrative example, consider the following rule R that has two assertions: cvl ... assert a1 ... assert a2 ... The multi_assert_check mode would generate and check two sub-rules: R1 where a1 is proved while a2 is removed, and R2 where a1 is assumed (i.e., transformed into a requirement statement), and a2 is proved. R passes if and only if, R1 and R2 both pass. In particular, in case R1 (resp. R2) fails, the counter-example shows a violation of a1 (resp. a2). Caution: We suggest using this mode carefully. In general, as this mode generates and checks more rules, it may lead to worse running-time performance. Please see indications for use below. ## When to use it? When you have a rule with multiple assertions: 1. As a timeout mitigation strategy: checking each assertion separately may, in some cases, perform better than checking all the assertions together and consequently solve timeouts. 2. If you wish to get multiple counter-examples in a single run of the tool, where each counter-example violates a different assertion in the rule. --- ## Example certoraRun Bank.sol --verify Bank:Bank.spec --multi_assert_check --independent_satisfy --independent_satisfy What does it do? The independent satisfy mode checks each {ref}satisfy statement <satisfy> independently from all other satisfy statements that occur in a rule. Normally, each satisfy statement will be turned into a sub-rule (similarly to the {ref}--multi_assert_check mode), but previously encountered satisfy statements will still be considered when creating a satisfying assignment. As an illustrative example of the default mode, consider the following rule R that has two satisfy statements: cvl rule R { bool b; satisfy b, \"R1\"; satisfy !b, \"R2\"; } The statements for \"R1\" and \"R2\" will actually create two sub-rules equivalent to: cvl rule R1_default { bool b; satisfy b, \"R1\"; } rule R2_default { bool b; // Previous satisfy statements are required in default mode. require b; // R1 // Due to requiring b, pis satisfy statement is equivalent to 'satisfy b &amp;&amp; !b, \"R2\";' satisfy !b, \"R2\"; } Without turning independent_satisfy mode on, R2 would have failed, as it would try to satisfy b &amp;&amp; !b, an unsatisfiable contradiction. Turning on the independent_satisfy mode will ignore all currently unchecked satisfy statements for each sub-rule. It would also generate and check two sub-rules, but with a slight difference: R1 where b is satisfied (by b=true) while satisfy !b is removed, and R2 where satisfy b is removed, and !b is satisfied (by b=false). The two independent_satisfy generated sub-rules will be equivalent to: cvl rule R1_independent { bool b; satisfy b, \"R1\"; } rule R2_independent { bool b; // require b; satisfy !b, \"R2\"; } When to use it? When you have a rule with multiple satisfy statements, and you would like to demonstrate each statement separately. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --independent_satisfy --rule_sanity --rule_sanity What does it do? This option enables sanity checking for rules. The --rule_sanity option may be followed by one of none, basic, or advanced; See {doc}../checking/sanity for more information about sanity checks. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-24", "chunk-uid": "6ce623a128d1", "chunk-page-index": 24, "text": "We suggest using this option routinely while developing rules. It is also a useful check if you notice rules passing surprisingly quickly or easily. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --rule_sanity basic --short_output What does it do? Reduces the verbosity of the tool."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-25", "chunk-uid": "6ce623a128d1", "chunk-page-index": 25, "text": "When to use it? When we do not care much for the output."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-26", "chunk-uid": "6ce623a128d1", "chunk-page-index": 26, "text": "It is recommended when running the tool in continuous integration. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --short_output Options that control the Solidity compiler --- ## --solc What does it do? Use this option to provide a path to the Solidity compiler executable file. We check in all directories in the $PATH environment variable for an executable with this name. If --solc is not used, we look for an executable called solc, or solc.exe on windows platforms. When to use it? Whenever you want to use a Solidity compiler executable with a non-default name. This is usually used when you have several Solidity compiler executable versions you switch between. Example certoraRun Bank.sol --verify Bank:Bank.spec --solc solc8.1 ## --solc_map What does it do? Compiles every smart contract with a different compiler executable (Solidity version or Vyper). All used contracts must be listed. When to use it? When different contracts have to be compiled for different Solidity versions. Example certoraRun Bank.sol Exchange.sol Token.vy --verify Bank:Bank.spec --compiler_map Bank=solc4.25,Exchange=solc6.7,Token=vyper0.3.10 ## --solc_optimize What does it do? Passes the value of this option as is to the solidity compiler's option --optimize and --optimize-runs. When to use it? When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs) Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize 300 ## --solc_optimize_map What does it do? Set optimize values when different files run with different number of runs Passes the value of this option as is to the solidity compiler's option --optimize and --optimize-runs. When to use it? When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs) Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize_map Bank=200,Exchange=300 ## --solc_via_ir What does it do? Passes the value of this option to the solidity compiler's option --via-ir. When to use it? When we want to enable the IR-based code generator Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir --- ## What does it do? Passes the value of this option to the solidity compiler's option --evm-version. ## When to use it? When we want to select the Solidity compiler EVM version ## Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_evm_version Istanbul ## What does it do? Passes the value of this option as is to the solidity compiler's option --allow-paths. See --allow-path specification ## When to use it? When we want to add an additional location the Solidity compiler to load sources from ## Example certoraRun Bank.sol --verify Bank:Bank.spec --solc_allow_pap ~/Projects/Bank ## What does it do? Gets the path to a directory including the Solidity packages."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-27", "chunk-uid": "6ce623a128d1", "chunk-page-index": 27, "text": "## When to use it? By default, we look for the packages in $NODE_PATH. If the packages are in any other directory, you must use --packages_path. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --packages_pap Solidity/packages ## What does it do? For each package, gets the path to a directory including that Solidity package."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-28", "chunk-uid": "6ce623a128d1", "chunk-page-index": 28, "text": "## When to use it? By default we look for the packages in $NODE_PATH. If there are packages are in several different directories, use --packages. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --packages ds-stop=$PWD/lib/ds-token/lib/ds-stop/src ds-note=$PWD/lib/ds-token/lib/ds-stop/lib/ds-note/src ## Options regarding source code loops ## What does it do? The Certora Prover unrolls loops - if the loop should be executed three times, it will copy the code inside the loop three times. After we finish the loop's iterations, we add an assertion to verify we have actually finished running the loop. For example, in a while (a < b) loop, after the loop's unrolling, we add assert a >= b. We call this assertion the loop unwind condition. This option changes the assertions of the loop unwind condition to requirements (in the case above require a >= b). That means, we ignore all the cases where the loop unwind condition does not hold, instead of considering them as a failure. ## When to use it? When you have loops in your code and are getting a counterexample labeled loop unwind condition. In general, you need this flag whenever the number of loop iterations varies. It is usually a necessity if using {ref}--loop_iter. Note that --optimistic_loop could cause {ref}vacuous rules <--rule_sanity>. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_loop ## What does it do? The Certora Prover unrolls loops - if the loop should be executed three times, it will copy the code inside the loop three times. After we finish the loop's iterations, we add an assertion to verify we have actually finished running the loop. For example, in a while (a < b) loop, after the loop's unrolling, we add assert a >= b. We call this assertion the loop unwind condition. This option changes the assertions of the loop unwind condition to requirements (in the case above require a >= b). That means, we ignore all the cases where the loop unwind condition does not hold, instead of considering them as a failure. ## When to use it? When you have loops in your code and are getting a counterexample labeled loop unwind condition. In general, you need this flag whenever the number of loop iterations varies. It is usually a necessity if using {ref}--loop_iter. Note that --optimistic_loop could cause {ref}vacuous rules <--rule_sanity>. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --loop_iter --- What does it do? Sets the maximal number of loop iterations we verify for. The way the Certora Prover handles loops is by unrolling them - if the loop should be executed three times, it will copy the code inside the loop three times. This option sets the number of unrolls. Be aware that the run time grows exponentially by the number of loop iterations. When to use it? The default number of loop iterations we unroll is one. However, in many cases, bugs only occur when there are several iterations. Common scenarios include iteration over list elements. Two, or in some cases three, is usually the most you will ever need to uncover bugs. Example certoraRun Bank.sol --verify Bank:Bank.spec --loop_iter 2 Options regarding summarization What does it do? In case there's a call to some Solidity function within a summary, we may end up with recursive calls to this summary. For example, if in the summary of foo we call the Solidity function bar, and bar's Solidity code contains a call to foo, we'll summarize foo again, which will lead to another call to bar etc. In this case if this flag is set to false we may get an assertion failure with a message along the lines of text Recursion limit (...) for calls to ..., reached during compilation of summary ... Such recursion can also happen with dispatcher summaries — if a contract method f makes an unresolved external call to a different method f, and if f is summarized with a DISPATCHER summary, then the Prover will consider paths where f recursively calls itself. Without --optimistic_summary_recursion, the Prover may report a rule violation with the following assert message: text When summarizing a call with dispatcher, found we already have it in the stack: ... consider removing its dispatcher summary. The default behavior in this case is to assert that the recursion limit is not reached (the limit is controlled by the --summary_recursion_limit flag). With --optimistic_summary_recursion, the Prover will instead assume that the limit is never reached. When to use it Use this flag when there is recursion due to summaries calling Solidity functions, and this causes an undesired assertion failure. In this case one can either make the limit larger (via --summary_recursion_limit) or set this flag to true. Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_summary_recursion true Note that this flag could be another cause for unsoundness - even if such recursion could actually happen in the deployed contract, this code-path won't be verified. What does it do? Summaries can cause recursion (see --optimistic_summary_recursion). This option sets the summary recursion level, which is the number of recursive calls that the Prover will consider. If the Prover finds an execution in which a function is called recursively more than the contract recursion limit, the Prover will report an assertion failure (unless --optimistic_summary_recursion is set, in which case the execution will be ignored). The default value is zero (i.e."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-29", "chunk-uid": "6ce623a128d1", "chunk-page-index": 29, "text": "no recursion is allowed). When to use it 1. Use this option when there is recursion due to summaries calling Solidity functions, and this leads to an assertion failure. In this case one can either make the limit larger or set (via --optimistic_summary_recursion) flag to true. --- ## Options regarding hashing of unbounded data |Option|What does it do?| |---|---| |--auto_nondet_difficult_internal_funcs|This option sets the minimal difficulty threshold for the auto-summarization mode enabled by --auto_nondet_difficult_internal_funcs.| |When to use it|If the results of an initial run with --auto_nondet_difficult_internal_funcs were unsatisfactory, one can adjust the default threshold to apply the auto-summarization to potentially more or fewer internal functions. The notification in the rule report that contains the applied summaries will present the current threshold used by the Prover.| |Example|bash certoraRun Bank.sol --verify Bank:Bank.spec --auto_nondet_difficult_internal_funcs --auto_nondet_minimal_difficulty 20| |--use_memory_safe_autofinders|This option avoids compilation errors when using certoraRun by marking auto-generated instrumented assembly code as memory-safe.| |When to use it|If you see solc failures right after the certoraRun prints Compiling XXX to expose internal function information..., and the compiled contract is compiled with Solidity version 0.8.13 and above. It is usually useful in conjunction with --solc_via_ir.| |Example|bash certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir --use_memory_safe_autofinders| --- ## --optimistic_hashing What does it do? When hashing data of potentially unbounded length (including unbounded arrays, like bytes, uint[], etc.), assume that its length is bounded by the value set through the --hashing_length_bound option. If this is not set, and the length can be exceeded by the input program, the Prover reports an assertion violation. I.e., when this option is set, the boundedness of the hashed data assumed checked by the Prover, when this option is set that boundedness is assumed instead. See ../approx/hashing for more details. When to use it? When the assertion regarding unbounded hashing is thrown, but it is acceptable for the Prover to ignore cases where the length hashed values exceeds the current bound. Example certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_hashing ## --hashing_length_bound What does it do? Constraint on the maximal length of otherwise unbounded data chunks that are being hashed. This constraint is either assumed or checked by the Prover, depending on whether --optimistic_hashing has been set. The bound is specified as a number of bytes. The default value of this option is 224 (224 bytes correspond to 7 EVM machine words as 7 * 32 == 224). When to use it? Reason to lower this value: Lowering potentially improves SMT performance, especially if there are many occurrences of unbounded hashing in the program. Reasons to raise this value: - when --optimistic_hashing is not set: avoid the assertion being violated when the hashed values are actually bounded, but by a bound that is higher than the default value (in case of --optimistic_hashing being not set) - when --optimistic_hashing is set: find bugs that rely on a hashed array being at least of that length. (Optimistic hashing excludes all cases from the scope of verification where something being hashed is longer than this bound.) Example certoraRun Bank.sol --verify Bank:Bank.spec --hashing_length_bound 128 ## Options that help reduce the running time --method What does it do? Parametric rules will only verify the method with the given signature, instead of all public and external methods of the contract. Note that you will need to wrap the method's signature with quotes, as the shell doesn't interpret parenthesis correctly otherwise. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-30", "chunk-uid": "6ce623a128d1", "chunk-page-index": 30, "text": "When you are trying to solve/understand a counterexample of a parametric rule on a specific method. --- ## Example certoraRun Bank.sol --verify Bank:Bank.spec --method 'withdraw(uint256,bool)' (--compilationstepsonly)= --compilation_steps_only What does it do? Exits the program after source code and spec compilation without sending a verification request to the cloud. When to use it? Use it to check if the spec has correct syntax but do not wish to send a verification request and wait for its results. Here are a few example scenarios: 1. When writing hooks, ghosts, summaries, or CVL functions, you can verify the spec before continuing to write rules. 2. In CI, you can check CVL correctness after every PR but run the expensive and long verification only on nightly runs. 3. When you have no internet connection but still want to develop spec offline. ## Example sh certoraRun Example.sol --verify Example:Example.spec --compilation_steps_only (--smt_timeout)= --smt_timeout &lt;seconds&gt; What does it do? Sets the maximal timeout for all the SMT solvers. Gets an integer input, which represents seconds. The Certora Prover generates a logical formula from the specification and source code. Then, it passes it on to an array of SMT solvers. The time it can take for the SMT solvers to solve the equation is highly variable, and could potentially be infinite. This is why they must be limited in run time. Note that the SMT timeout applies separately to each individual rule (or each method for parametric rules). To set the global timeout, see {ref}--global_timeout. Also note that, while the most prominent one, this is not the only timeout that applies to SMT solvers, for details see {ref}-mediumTimeout and {ref}control-flow-splitting. When to use it? The default time out for the solvers is 300 seconds. There are two use cases for this option. One is to decrease the timeout. This is useful for simple rules, that are solved quickly by the SMT solvers. Here, it is beneficial to reduce the timeout, so that when a new code breaks the specification, the tool will fail quickly. This is the more common use case. The second use is when the solvers can prove the property, they just need more time. Usually, if the rule isn't solved in 600 seconds, it will not be solved in 2,000 either. It is better to concentrate your efforts on simplifying the rule, the source code, add more summaries, or use other time-saving options. The prime causes for an increase of --smt_timeout are rules that are solved quickly, but time out when you add a small change, such as a requirement, or changing a strict inequality to a weak inequality. ## Example certoraRun Bank.sol --verify Bank:Bank.spec --smt_timeout 300 (--global_timeout)= --global_timeout &lt;seconds&gt; Sets the maximal timeout for the Prover. Gets an integer input, which represents seconds."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-31", "chunk-uid": "6ce623a128d1", "chunk-page-index": 31, "text": "The Certora Prover is bound to run a maximal time of 2 hours (7200 seconds). Users may opt to set this number lower to facilitate faster iteration on specifications."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-32", "chunk-uid": "6ce623a128d1", "chunk-page-index": 32, "text": "Values larger than two hours (7200 seconds) are ignored. Jobs that exceed the global timeout will simply be terminated, so the result reports may not be generated. The global timeout is different from the {ref}--smt_timeout option: the --smt_timeout flag constrains the amount of time allocated to the processing of each individual rule, while the --global_timeout flag constrains the processing of the entire job, including static analysis and other preprocessing. --- When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-33", "chunk-uid": "6ce623a128d1", "chunk-page-index": 33, "text": "When running on just a few rules, or when willing to make faster iterations on specs without waiting too long for the entire set of rules to complete. Note that even if in the shorter running time not all rules were processed, a second run may pull some results from cache, and therefore more results will be available. |Example|certoraRun Bank.sol --verify Bank:Bank.spec --global_timeout 60| |---|---| |Options to set addresses and link contracts| | What does it do? Links a slot in a contract with another contract. When to use it? Many times a contract includes the address of another contract as one of its fields. If we do not use --link, it will be interpreted as any possible address, resulting in many nonsensical counterexamples. |Example|Assume we have the contract Bank.sol with the following code snippet: IERC20 public underlyingToken;| |---|---| |We have a contract BankToken.sol, and underlyingToken should be its address. To do that, we use: certoraRun Bank.sol BankToken.sol --verify Bank:Bank.spec --link Bank:underlyingToken=BankToken| | What does it do? Sets the address of a contract to a given address."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-34", "chunk-uid": "6ce623a128d1", "chunk-page-index": 34, "text": "When to use it? When we have an external contract with a constant address. By default, the Python script assigns addresses as it sees fit to contracts. |Example|If we wish the Oracle contract to be at address 12, we use certoraRun Bank.sol Oracle.sol --verify Bank:Bank.spec --address Oracle:12| |---|---| | | | What does it do? Links a slot in a struct with another contract. To do that you must calculate the slot number of the field you wish to replace. When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-35", "chunk-uid": "6ce623a128d1", "chunk-page-index": 35, "text": "Many times a contract includes the address of another contract inside a field of one of its structs. If we do not use --struct_link, it will be interpreted as any possible address, resulting in many nonsensical counterexamples. |Example|Assume we have the contract Bank.sol with the following code snippet: TokenPair public tokenPair;| |---|---| |We have two contracts BankToken.sol and LoanToken.sol. We want tokenA of the tokenPair to be BankToken, and tokenB to be LoanToken. Addresses take up only one slot. We assume tokenPair is the first field of Bank (so it starts at slot zero). To do that, we use: certoraRun Bank.sol BankToken.sol LoanToken.sol --verify Bank:Bank.spec --structLink Bank:0=BankToken Bank:1=LoanToken| | --- What does it do? Contract inlining can cause recursion (see --optimistic_contract_recursion). This option sets the contract recursion level, which is the number of recursive calls that the Prover will consider when inlining contracts linked using, e.g., --link or --struct_link. Note: In this context, recursion refers to the state where the same external function appears twice in the call stack. Contracts can also exhibit recursive behavior due to recursive calls to internal functions, which is unrelated to this option. If a counterexample causes a function to be called recursively more than the contract recursion limit, it will report an assertion failure (unless --optimistic_contract_recursion is set, in which case the counterexample will be ignored). The default value is zero (i.e., no recursion is allowed). When to use it: Use this option when after linking the resulting program may have paths with recursive calls to external Solidity functions, and this leads to a recursion-specific assertion failure, showing the message Contract recursion limit reached. In this case one can either make the limit larger or set --optimistic_contract_recursion flag to true. Example: certoraRun Bank.sol --verify Bank:Bank.spec --contract_recursion_limit 3 --optimistic_contract_recursion What does it do? Contract linking can cause recursion (see also --contract_recursion_limit). This option sets the Prover to optimistically assume that recursion cannot go beyond what is defined by --contract_recursion_limit, but only if --contract_recursion_limit is set to a number higher than 0. When to use it? 1. When the recursion due to contract linking is unbounded. 2. When we are interested only in a limited recursion depth due to contract linking. Caution: Note that this flag could be another cause for unsoundness - even if such recursion could actually happen in the deployed contract, this code-path won't be verified beyond the specified recursion limit (--contract_recursion_limit). Example: certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_contract_recursion true --contract_recursion_limit 1 --optimistic_fallback This option determines whether to optimistically assume unresolved external calls with an empty input buffer (length 0) cannot make arbitrary changes to all states. It makes changes to how AUTO summaries are executed. By default unresolved external calls with an empty input buffer will havoc all the storage state of external contracts. When --optimistic_fallback is enabled, the call will either execute the fallback function in the specified contract, revert, or execute a transfer. It will not havoc any state. Options for controlling contract creation --dynamic_bound <n> What does it do? If set to zero (the default), contract creation (via the new statement or the create/create2 instructions) will result in a havoc, like any other unresolved external call. If non-zero, then dynamic contract creation will be modeled --- ## with cloning, where each contract will be cloned at most n times. When to use it? When you wish to model contract creation, that is, simulating the actual creation of the contract. Without it, create and create2 commands simply return a fresh address; the Prover does not model their storage, code, constructors, immutables, etc. Any interaction with these generated addresses is modeled imprecisely with conservative havoc. Example Suppose a contract C creates a new instance of a contract Foo, and you wish to inline the constructor of Foo at the creation site. certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch What does it do? If false (the default), then all contract method invocations on newly created instances will be unresolved. The user must explicitly write DISPATCHER summaries for all methods called on newly created instances. If true, the Prover will, on a best-effort basis, automatically apply the DISPATCHER summary for call sites that must be with a newly created contract as a receiver. Importantly, this option is only applicable to cases where the Prover can prove that the callee is a created contract. For example, in the below example, the bar function will be unresolved: solidity MyFoo f; if(*) { f = new MyFoo(...); } else { f = storageStruct.myFoo; } f.bar(); When to use it? When you prefer not to add explicit DISPATCHER summaries to methods invoked by the created contract. Example Suppose a contract C creates a new instance of a contract Foo, and you wish to inline the constructor of Foo at the creation site, and Foo calls some method m() which you wish to automatically link to the newly created contract. Note that you must add a --dynamic_bound argument as well. certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch true --prototype &lt;hex string&gt;=&lt;contract&gt; What does it do? Instructs the Prover to use a specific contract type for the return value from a call to create or create2 on the given hexadecimal string as a prefix. The hexadecimal string represents proxy code that forwards calls to another contract. As we are using the prototype flag to skip calls to the proxy, no constructor code is being simulated for these contract creation resolutions. When to use it? If you are verifying a contract creation that uses low level calls to create or create2 for contract creation. Example Suppose you have a contract C that creates another contract Foo like this: solidity assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create(0, ptr, 0x37) } Then you can set the string 3d602d80600a3d3981f3363d3d373d3d3d363d73 appearing in the first mstore after the 0x prefix as a \"prototype\" for Foo. The Prover will then be able to create a new instance of Foo at the point where the code creates it: certoraRun C.sol Foo.sol --prototype 3d602d80600a3d3981f3363d3d373d3d3d363d73=Foo --dynamic_bound 1 Note: this argument has no effect if the dynamic bound is zero. Also note that the hex string must be: - a strict prefix of the memory region passed to the create command - must be unique within each invocation of the tool - must not contain gaps, e.g., 3d602d80600a3d3981f3363d3d373d3d3d363d730000 in the above example will not work (those last four bytes will be overwritten) but 3d602d80600a3d3981f3363d3d373d3d3d363d will Version options --version What does it do? Shows the version of the local installation of the tool you have."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-36", "chunk-uid": "6ce623a128d1", "chunk-page-index": 36, "text": "When to use it?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-37", "chunk-uid": "6ce623a128d1", "chunk-page-index": 37, "text": "When you suspect you have an old installation. To install the newest version, use pip install --upgrade certora-cli. Example --- ## certoraRun --version Advanced options --java_args What does it do? Allows setting configuring the underlying JVM. When to use it? Upon instruction from the Certora team. Example --java_args '\"-Dcvt.default.parallelism=2\"' - will set the number of “tasks” that can run in parallel to 2. (--prover_args)= --prover_args The --prover_args option allows you to provide fine-grained tuning options to the Prover. --prover_args receives a string containing Prover-specific options, and will be sent as-is to the Prover. --prover_args cannot set Prover options that are set by standalone certoraRun options (e.g. the Prover option --t is set by --smt_timeout therefore cannot appear in --prover_args). --prover_args value must be quoted (-optimisticReturnsize)= --prover_args '-optimisticReturnsize=true' This option determines whether havoc summaries assume that the called method returns the correct number of return values. It will set the value returned by the RETURNSIZE EVM instruction according to the called method. Note that certain conditions should hold in order for the option to take effect. Namely, if there is a single candidate method in the havoc site, and all instances of this method in the scene have exactly the same expected number of return values, then the RETURNSIZE value will be set to the expected size matching the methods in the scene. Otherwise, RETURNSIZE will remain non-deterministic. (-superOptimisticReturnsize)= --prover_args '-superOptimisticReturnsize=true' This option determines whether havoc summaries assume that the called method returns the correct number of return values. It will set the value returned by the RETURNSIZE EVM instruction to the size of the output buffer as specified by the summarized CALL instruction. (--precisebitwiseops)= --precise_bitwise_ops This option models bitwise operations exactly instead of using the default overapproximations. It is useful when the Prover reports a counterexample caused by incorrect modeling of bitwise operations, but can dramatically increase the time taken for verification. The disadvantage of this encoding is that it does not model mathint precisely: the maximum supported integer value is :math:2^256-1 in this case, effectively restricting a mathint to a uint256. We currently do not have a setting or encoding that models precisely both bitwise operations and mathint. --- ## Control flow splitting options See here for an explanation of control flow splitting. ### (-depth) --prover_args '-depp &lt;number&gt;' What does it do? Sets pe maximum splitting depp. When to use it? When pe deepest {term}splits are too heavy to solve, but not too high in number, increasing pis will lead to smaller, but more numerous {term}split leaves, which run at pe full SMT timeout (as set by {ref}--smt_timeout). Conversely, if run time is too high because pere are too many splits, decreasing pis number means pat more time is spent on fewer, but bigger split leaves. The default value for pis option is 10. Example --- ## sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-depth 5' (-mediumTimeout)= --prover_args '-mediumTimeout &lt;seconds&gt;' The \"medium timeout\" determines how much time the SMT solver gets for checking a {term}split that is not a {term}split leaf. (For split leaves, the full {ref}--smt_timeout is used.) What does it do?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "options", "id": "6ce623a128d1-38", "chunk-uid": "6ce623a128d1", "chunk-page-index": 38, "text": "Sets the time that non-leaf splits get before being split again. When to use it? When a little more time can close some splitting subtrees early, this can save a lot of time, since the subtree's size is exponential in the remaining depth. On the other hand, if something will be split further anyway, this can save the run time spent on intermediate \"TIMEOUT\" results. Use {ref}-smt_initialSplitDepth to eliminate that time investment altogether up to a given depth. Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-mediumTimeout 20' (-dontStopAtFirstSplitTimeout)= --prover_args '-dontStopAtFirstSplitTimeout &lt;true/false&gt;' What does it do? We can tell the Certora Prover to continue even when the a {term}split has had a maximum-depth timeout. Note that this is only useful when there exists a {term}counterexample for the rule under verification, since in order to prove the absence of counterexamples (i.e. correctness), all splits need to be counterexample-free. (In case of a rule using satisfy rather than assert, the corresponding statements hold for {term}witness examples. In that case, this option is only useful if the rule is correct.) When to use it? When looking for a SAT result and observing an SMT-type timeout. The default value for this option is false. Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-dontStopAtFirstSplitTimeout true' (-smt_initialSplitDepth)= --prover_args '-smt_initialSplitDepth &lt;number&gt;' With this option, the splitting can be configured to skip the SMT solver-based checks at low splitting levels, thus generating sub-{term}splits up to a given depth immediately. What does it do? The first &lt;number&gt; split levels are not checked with the SMT solver, but rather split immediately. When to use it? When there is a lot of overhead induced by processing and trying to solve splits that are very hard, and thus run into a timeout anyway. --- {note} The number of splits generated here is equal to `2^n` where `n` is the initial splitting depth (assuming the program has enough branching points, which is usually the case); thus, low numbers are advisable. For instance setting this to 5 means that the Prover will immediately produce 32 splits. {note} The {ref}`-depth` setting has precedence over this setting. I.e., if `-depth` is set to a lower value than `-smt_initialSplitDepth`, the initial splitting will only proceed up to the splitting depth given via `-depth`. Example sh certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-smt_initialSplitDepth 3'"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "debugging", "id": "6adf783b63fb-0", "chunk-uid": "6adf783b63fb", "chunk-page-index": 0, "text": "## Advanced Debugging ### Memory Analysis The memory analysis makes sure that memory access is safe."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "debugging", "id": "6adf783b63fb-1", "chunk-uid": "6adf783b63fb", "chunk-page-index": 1, "text": "That is, the allocation of objects and the update of the free memory pointer are done correctly, and pointers are consistent. In Results.txt one can find indications of whether the points-to analysis (a major component of the memory analysis) fails or not, e.g., Pointer analysis failed while analyzing as in the full message, also indicating the source location: [main] WARN POINTS_TO - Pointer analysis failed while analyzing simplifiedVaultHarness-batchSwap @ LTACCmd(ptr=CmdPointer(block=24991_998_0_0_0_0_0_0, pos=2), cmd=ByteStore R38900:bv256 R39227:bv256 tacM:bytemap (5059:58:5:0xce4604a0000000000000000000000004) // .certora_config/simplifiedVaultHarness.sol_4/5_SignaturesValidator.sol)"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-0", "chunk-uid": "e591f86a9241", "chunk-page-index": 0, "text": "## Built-in Rules The Certora Prover has built-in general-purpose rules targeted at finding common vulnerabilities. These rules can be verified on a contract without writing any contract-specific rules. Built-in rules can be included in any spec file by writing use builtin rule &lt;rule-name&gt;;."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-1", "chunk-uid": "e591f86a9241", "chunk-page-index": 1, "text": "This document describes the available built-in rules. ### Syntax The syntax for rules is given by the following EBNF grammar: builtinrule ::= \"use\" \"builtin\" \"rule\" builtinrule_name ; builtinrule_name ::= | \"msgValueInLoopRule\" | \"hasDelegateCalls\" | \"sanity\" | \"deepSanity\" | \"viewReentrancy\" ### Bad loop detection — msgValueInLoopRule Loops that use msg.value or make delegate calls are a well-known source of security vulnerabilities. The msgValueInLoopRule detects these anti-patterns. It can be enabled by including cvl use builtin rule msgValueInLoopRule; in a spec file. The rule will fail on any functions that can make delegate calls or access msg.value inside a loop. This includes any functions that recursively call any functions that have this vulnerability. ### Delegate call detection — hasDelegateCalls The hasDelegateCalls built-in rule is a handy way to find delegate calls in a contract. Contracts that use delegate calls require proper security checking. The hasDelegateCalls can be enabled by including cvl use builtin rule hasDelegateCalls; in a spec file. Any functions that can make delegate calls will fail the hasDelegateCalls rule. ### Basic setup checks — sanity The sanity rule checks that there is at least one non-reverting path through each contract function. It can be enabled by including cvl use builtin rule sanity; in a spec file. The sanity rule is useful for two reasons: - It is an easy way to determine which contract functions take a long time to analyze. If a method takes a long time to verify the sanity rule (or times out), it will almost certainly time out while verifying interesting properties. This can help you quickly discover which methods may need summarization. - A method that fails the sanity rule will revert on every input; every rule that calls the method will therefore be vacuous. This probably indicates a problem with the Prover configuration; the most likely cause is --- {ref}loop unrolling <unrolling>. We recommend running the sanity rule at the beginning of a project to ensure that the Prover's configuration is reasonable."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-2", "chunk-uid": "e591f86a9241", "chunk-page-index": 2, "text": "{note} The `sanity` built-in rule is unrelated to the {ref}`--rule_sanity` option; the built-in rule is used to check the basic setup, while `--rule_sanity` checks individual rules. How sanity is checked The sanity rule is translated into the following {term}parametric rule: cvl rule sanity { method f; env e; calldataarg arg; f(e, arg); satisfy true; } To find a satisfying trace, the Prover must construct an input for which f doesn't revert. (built-in-deep-sanity)= Thorough complexity checks — deepSanity The basic sanity rule only tries to find a single input that causes each function to execute without reverting. While this check can quickly identify problems with the Prover setup, a successful sanity run does not guarantee that the contract methods won't cause Prover timeouts, or that all of the contract code is reachable. For example, consider the following method: solidity function veryComplexFunction() returns(uint) { uint x = 0; for (uint i = 0 ; i < array.len; i++) { x = x + complexComputation(i); } return x; } There is clearly a simple non-reverting path through the code: it will immediately return if array.len is 0; the basic sanity can quickly find a {term}model like this without even considering the implementation of complexComputation, so the sanity rule will succeed. However, verifying any property that depends on the return value of veryComplexFunction will require the Prover to reason about complexComputation(), which may cause timeouts. Moreover, portions of complexComputation may be unreachable, and this will not be caught by the basic sanity rule. The deepSanity rule generalizes the basic sanity rule by heuristically choosing interesting statements in the contract code and ensuring that there are non-reverting {term}models <model> that execute those statements. In the above example, one of the paths chosen by deepSanity would go through the body of the for loop, forcing the Prover to find a non-reverting path through the complexComputation method. The deepSanity rule heuristic favors the following program points: 1. The \"if\" and \"else\" branches of a code-heavy if statement 2. The beginning of an external call 3. The beginning of the program (this is the same as the usual sanity rule) The deepSanity rule can be enabled by including cvl use builtin rule deepSanity; in a spec file. You must also pass the {ref}--multi_assert_check flag to the Prover. The number of code points that are chosen can be configured with the {ref}-maxNumberOfReachChecksBasedOnDomination flag; the default value is 10. How deepSanity is checked The deepSanity rule works similarly to the sanity rule; it adds an additional variable x_p for each interesting program point p, and instruments the contract code at p to set x_p to true. The Prover then tries to prove that x_p is false after executing the function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-3", "chunk-uid": "e591f86a9241", "chunk-page-index": 3, "text": "To find a counterexample; the Prover must construct a model that passes through p. (built-in-view-reentrancy)= Read-only reentrancy detection — viewReentrancy The viewReentrancy built-in rule detects read-only reentrancy vulnerabilities in a contract. --- ## The viewReentrancy rule The viewReentrancy rule can be enabled by including cvl use builtin rule viewReentrancy; in a spec file. Any functions that have read-only reentrancy will fail the viewReentrancy rule. ### How viewReentrancy is checked Reentrancy vulnerabilities can arise when a contract makes an external call with an inconsistent internal state. This behavior allows the receiver contract to make reentrant calls that exploit the inconsistency. The viewReentrancy rule ensures that whenever a method f of {ref}currentContract <currentContract> makes an external call, the internal state of currentContract is equivalent to either (1) the state of currentContract at the beginning of the calling function, or (2) the state of currentContract at the end of the calling function (by \"equivalent\", we mean that all view functions return the same values). This ensures that the external call cannot observe currentContract in any state that it couldn't have without being called from currentContract. ## Built-in Rules The Certora Prover has built-in general-purpose rules targeted at finding common vulnerabilities."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-4", "chunk-uid": "e591f86a9241", "chunk-page-index": 4, "text": "These rules can be verified on a contract without writing any contract-specific rules. Built-in rules can be included in any spec file by writing use builtin rule <rule-name>; This document describes the available built-in rules. ### Syntax The syntax for rules is given by the following EBNF grammar: |builtinrule|::=|\"use\" \"builtin\" \"rule\" builtinrule_name ;| |---|---|---| |builtinrule_name|::=|| \"msgValueInLoopRule\" | \"hasDelegateCalls\" | \"sanity\" | \"deepSanity\" | \"viewReentrancy\"| ## Bad loop detection — msgValueInLoopRule Loops that use msg.value or make delegate calls are a well-known source of security vulnerabilities. The msgValueInLoopRule detects these anti-patterns. It can be enabled by including cvl use builtin rule msgValueInLoopRule; in a spec file. The rule will fail on any functions that can make delegate calls or access msg.value inside a loop. This includes any functions that recursively call any functions that have this vulnerability. ## Delegate call detection — hasDelegateCalls The hasDelegateCalls built-in rule is a handy way to find delegate calls in a contract. Contracts that use delegate calls require proper security checking. The hasDelegateCalls can be enabled by including cvl use builtin rule hasDelegateCalls; in a spec file. Any functions that can make delegate calls will fail the hasDelegateCalls rule. --- ## Basic setup checks — sanity The sanity rule checks that there is at least one non-reverting path through each contract function. It can be enabled by including cvl use builtin rule sanity; in a spec file. The sanity rule is useful for two reasons: - It is an easy way to determine which contract functions take a long time to analyze. If a method takes a long time to verify the sanity rule (or times out), it will almost certainly time out while verifying interesting properties. This can help you quickly discover which methods may need summarization. - A method that fails the sanity rule will revert on every input; every rule that calls the method will therefore be vacuous. This probably indicates a problem with the Prover configuration; the most likely cause is loop unrolling. We recommend running the sanity rule at the beginning of a project to ensure that the Prover's configuration is reasonable. Note: The sanity built-in rule is unrelated to the --rule_sanity option; the built-in rule is used to check the basic setup, while --rule_sanity checks individual rules. ### How sanity is checked The sanity rule is translated into the following parametric rule: cvl rule sanity { method f; env e; calldataarg arg; f(e, arg); satisfy true; } To find a satisfying trace, the Prover must construct an input for which f doesn't revert. ## Thorough complexity checks — deepSanity The basic sanity rule only tries to find a single input that causes each function to execute without reverting. While this check can quickly identify problems with the Prover setup, a successful sanity run does not guarantee that the contract methods won't cause Prover timeouts, or that all of the contract code is reachable. For example, consider the following method: solidity function veryComplexFunction() returns(uint) { uint x = 0; for (uint i = 0 ; i &lt; array.len; i++) { x = x + complexComputation(i); } return x; } There is clearly a simple non-reverting path through the code: it will immediately return if array.len is 0; the basic sanity can quickly find a model like this without even considering the implementation of complexComputation, so the sanity rule will succeed. However, verifying any property that depends on the return value of veryComplexFunction will require the Prover to reason about complexComputation(), which may cause timeouts. Moreover, portions of complexComputation may be unreachable, and this will not be caught by the basic sanity rule. The deepSanity rule generalizes the basic sanity rule by heuristically choosing interesting statements in the contract code and ensuring that there are non-reverting models that execute those statements. In the above example, one of the paths chosen by deepSanity would go through the body of the for loop, forcing the Prover to find a non-reverting path through the complexComputation method. The deepSanity rule heuristic favors the following program points: 1. The \"if\" and \"else\" branches of a code-heavy if statement 2. The beginning of an external call 3. The beginning of the program (this is the same as the usual sanity rule) The deepSanity rule can be enabled by including cvl use builtin rule deepSanity; in a spec file. You must also pass the --multi_assert_check flag to the Prover. The number of code points that are chosen can be configured with the -maxNumberOfReachChecksBasedOnDomination flag; the default value is 10. --- ## How deepSanity is checked The deepSanity rule works similarly to the sanity rule; it adds an additional variable x_p for each interesting program point p, and instruments the contract code at p to set x_p to true. The Prover then tries to prove that x_p is false after executing the function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "builtin", "id": "e591f86a9241-5", "chunk-uid": "e591f86a9241", "chunk-page-index": 5, "text": "To find a counterexample, the Prover must construct a model that passes through p. ## Read-only reentrancy detection — viewReentrancy The viewReentrancy built-in rule detects read-only reentrancy vulnerabilities in a contract. The viewReentrancy rule can be enabled by including cvl use builtin rule viewReentrancy; in a spec file. Any functions that have read-only reentrancy will fail the viewReentrancy rule. ## How viewReentrancy is checked Reentrancy vulnerabilities can arise when a contract makes an external call with an inconsistent internal state. This behavior allows the receiver contract to make reentrant calls that exploit the inconsistency. The viewReentrancy rule ensures that whenever a method f of {ref}currentContract makes an external call, the internal state of currentContract is equivalent to either (1) the state of currentContract at the beginning of the calling function, or (2) the state of currentContract at the end of the calling function (by \"equivalent\", we mean that all view functions return the same values). This ensures that the external call cannot observe currentContract in any state that it couldn't have without being called from currentContract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "ghostfunctions", "id": "2f36f4b6f9e3-0", "chunk-uid": "2f36f4b6f9e3", "chunk-page-index": 0, "text": "## Ghost Functions CVL specifications support normal solidity primitives (uint256, address etc.) in addition to some of its own (for example mathint). These types are interpreted meaning that their values are ascribed some sort of semantics (for example a bit vector of width 256 can be used inside arithmetic operations or comparison operations and has specific semantics associated i.e."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "ghostfunctions", "id": "2f36f4b6f9e3-1", "chunk-uid": "2f36f4b6f9e3", "chunk-page-index": 1, "text": "2 + 2 = 4 or x = y =&gt; z + x = z + y etc.). While it can be useful to use interpreted sorts within uninterpreted functions, for reasons we won't get into here, sometimes it is easier to use an uninterpreted sort that doesn't carry around all the \"baggage,\" so to speak, associated with its interpretation. This is where uninterpreted sorts come in. In CVL an uninterpreted sort is simply declared at the top level of a specification. For example: cvl sort MyUninterpSort; sort Foo; rule myRule { ... } There are then 3 things we can do with these sorts: 1. Declare variables of said sort: Foo x. 2. Test equality between two elements of this sort: Foo x; Foo y; assert x == y;; 3. Use these sorts in the signatures of uninterpreted functions: ghost myGhost(uint256 x, Foo f) returns Foo. Putting these pieces together we might write the following useless, but demonstrative example: cvl sort Foo; ghost bar(Foo, Foo) returns Foo; rule myRule { Foo x; Foo y; Foo z = bar(x, y); assert x == y &amp;&amp; y == z; } This will generate an assertion violation. Behind the scenes the solver gets to generate any number of members of the sort Foo."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "ghostfunctions", "id": "2f36f4b6f9e3-2", "chunk-uid": "2f36f4b6f9e3", "chunk-page-index": 2, "text": "So it can easily generate a counterexample by assigning x to one member and y to the other. ## Uninterpreted Functions Uninterpreted functions are called uninterpreted because they have no interpretation associated with them. In the example above, it is impossible to say what bar(x, y) means. Uninterpreted functions really only give us a single guarantee: Any two applications of the same uninterpreted function with the same arguments will return the same value. So for example: cvl ghost bar(Foo) returns Foo; rule shouldSucceed(Foo x, Foo y, Foo z) { require bar(x) == y; require x == z; // the solver must choose y for bar(z) assert bar(z) == y; } rule shouldFail(Foo x, Foo y, Foo z) { require bar(x) == y; // the solver can choose whatever it wants for bar(z) assert bar(z) == y; } ## Axioms for Uninterpreted Functions --- Sometimes we might want to constrain the behavior of an uninterpreted function in some particular way. In CVL this is achieved by writing axioms. Axioms are simply CVL expressions that the tool will then assume are true about the uninterpreted functions. For example: cvl ghost bar(uint256) returns uint256 { axiom forall uint256 x. bar(x) &gt; 10; } In any rule that uses bar, no application of bar could ever evaluate to a number less than or equal to 10. While this is not a very interesting axiom, we could imagine expressing more complicated functions, such as a reachability relation. Caution: Axioms are dangerous and should be used carefully as they are a potential source of vacuity bugs. This can happen in two situations: 1. The axiom implies false 2. Somewhere in the program, we assume something about a ghost function that, when conjoined with a ghost axiom, implies false Initial Axioms for Uninterpreted Functions Initial axioms look a lot like axioms but are used for a completely different reason. When writing invariants initial axioms are a way to express the \"initial state\" of a ghost function. For example: cvl ghost sum() returns uint256 { init_state axiom sum() == 0; } This simply states that our sum should start out at zero. Ghost Functions Uninterpreted Sorts CVL specifications support normal solidity primitives (uint256, address etc.) in addition to some of its own (for example mathint). These types are interpreted meaning that their values are ascribed some sort of semantics (for example a bit vector of width 256 can be used inside arithmetic operations or comparison operations and has specific semantics associated i.e. 2 + 2 = 4 or x = y =&gt; z + x = z + y etc.). While it can be useful to use interpreted sorts within uninterpreted functions, for reasons we won't get into here, sometimes it is easier to use an uninterpreted sort that doesn't carry around all the \"baggage,\" so to speak, associated with its interpretation. This is where uninterpreted sorts come in. In CVL an uninterpreted sort is simply declared at the top level of a specification. For example cvl sort MyUninterpSort; sort Foo; There are then 3 things we can do with these sorts: 1. Declare variables of said sort: Foo x. 2. Test equality between two elements of this sort: Foo x; Foo y; assert x == y;; 3. Use these sorts in the signatures of uninterpreted functions: ghost myGhost(uint256 x, Foo f) returns Foo. Putting these pieces together we might write the following useless, but demonstrative example: cvl sort Foo; ghost bar(Foo, Foo) returns Foo; rule myRule { Foo x; Foo y; Foo z = bar(x, y); assert x == y &amp;&amp; y == z; } --- This will generate an assertion violation. Behind the scenes the solver gets to generate any number of members of the sort Foo."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "ghostfunctions", "id": "2f36f4b6f9e3-3", "chunk-uid": "2f36f4b6f9e3", "chunk-page-index": 3, "text": "So it can easily generate a counterexample by assigning x to one member and y to the other. ## Uninterpreted Functions Uninterpreted functions are called uninterpreted because they have no interpretation associated with them. In the example above, it is impossible to say what bar(x, y) means. Uninterpreted functions really only give us a single guarantee: {note} Any two applications of the same uninterpreted function with the same arguments will return the same value. So for example: cvl ghost bar(Foo) returns Foo; rule shouldSucceed(Foo x, Foo y, Foo z) { require bar(x) == y; require x == z; // the solver must choose y for bar(z) assert bar(z) == y; } rule shouldFail(Foo x, Foo y, Foo z) { require bar(x) == y; // the solver can choose whatever it wants for bar(z) assert bar(z) == y; } ### Axioms for Uninterpreted Functions Sometimes we might want to constrain the behavior of an uninterpreted function in some particular way. In CVL this is achieved by writing axioms. Axioms are simply CVL expressions that the tool will then assume are true about the uninterpreted functions. For example: cvl ghost bar(uint256) returns uint256 { axiom forall uint256 x. bar(x) &gt; 10; } In any rule that uses bar, no application of bar could ever evaluate to a number less than or equal to 10. While this is not a very interesting axiom, we could imagine expressing more complicated functions, such as a reachability relation. {caution} Axioms are dangerous and should be used carefully as they are a potential source of vacuity bugs. This can happen in two situations: 1. The axiom implies false 2. Somewhere in the program, we assume something about a ghost function that, when conjoined with a ghost axiom, implies false ### Initial Axioms for Uninterpreted Functions Initial axioms look a lot like axioms but are used for a completely different reason. When writing invariants initial axioms are a way to express the \"initial state\" of a ghost function. For example: cvl ghost sum() returns uint256 { init_state axiom sum() == 0; } This simply states that our sum should start out at zero."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "best-practices", "id": "3d20108cf15f-0", "chunk-uid": "3d20108cf15f", "chunk-page-index": 0, "text": "## Best Practices When to use the environment argument? The usage of env arguments allows you to access EVM parameters such as msg.sender. env arguments can describe the behavior of multiple EVM transactions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "best-practices", "id": "3d20108cf15f-1", "chunk-uid": "3d20108cf15f", "chunk-page-index": 1, "text": "An example is shown in rule can_withdraw_after_any_time_and_any_other_transaction. cvl rule canwipdrawafteranytimeandanyopertransaction address account; uint256 amount; mepod f; // account deposits amount env _e; require _e.msg.sender == account; require amount > 0; deposit(_e, amount); // any oper transaction beside wipdraw and transfer by account env eF; require (f.selector != wipdraw().selector && f.selector != transfer(address, uint256).selector) || eF.msg.sender!=account; calldataarg arg; // any argument f(eF, arg); // successful (potentially state-changing!) // account wipdraws env e_; require e_.block.timestamp > _e.block.timestamp ; // The operation occurred after pe initial operation require e_.msg.sender == account; wipdraw(e_); // check pe erc balance uint256 epBalance = getEpBalance(e_); assert epBalance >= amount, \"should have at least what have been deposited\"; --- #### // any other transaction beside withdraw and transfer by account env eF; require (f.selector != withdraw().selector &amp;&amp; f.selector != transfer(address, uint256).selector) || eF.msg.sender!=account; calldataarg arg; // any argument f(eF, arg); // successful (potentially state-changing!) #### // account withdraws env e_; require e_.block.timestamp > _e.block.timestamp ; // The operation occurred after the initial operation require e_.msg.sender == account; withdraw(e_); // check the erc balance uint256 ethBalance = getEthBalance(e_); assert ethBalance >= amount, \"should have at least what have been deposited\";"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-0", "chunk-uid": "891656a17308", "chunk-page-index": 0, "text": "## Troubleshooting Certora Prover is a complex tool, relying on many abstractions, and thus its outputs can be confusing. Moreover, it is constantly in development, and as it becomes more robust, one should still be aware of its oddities."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-1", "chunk-uid": "891656a17308", "chunk-page-index": 1, "text": "This page lists a few common issues that can happen and helps in their debugging. Ask, ask, ask! There’s no stupid question. There’s no not-in-place comment. This page will only address a partial subset of the problems that could happen. ### Timeouts Identify the kind of timeout Global timeout Every cloud run is limited to 2 hours. When 2 hours have elapsed, you will get an email that looks like this: As you can see there’s a ~2 hours difference between “Queue Time” and “Finish Time”. Action items: 1. Figure out if pe problem happened due to having too many rules and SMT taking too long, or if preprocessing has failed to complete in time. Therefore, open pe linked-to zip file, extract it, and look into Reports/Results.txt. If pere is no message “Has CVL checks” or “Starting to run on rule ….” pen pere is a good chance pat preprocessing took too long. If you did not even see a message “The scene contains … contracts” it means pat even pe first step of preprocessing took too long. 2. If pe problem is preprocessing, first try to run wip -enableEqualitySaturation=false, and if pat does not help try in addition -simplificationDepp=10. If bop don't help, please report to Certora. 3. If you’re blocked on pis contract, try to make progress by eiper summarization, or manually removing parts of pe code. The code may contain libraries pat add to pe complication, so try to “erase” pose parts of pe code first and re-run. If it works, it's better to undo pe changes and apply summarizations. 4. Operwise, if rules are already starting to process, check how long approximately preprocessing took. You can measure pat using pe “Ping” messages. A ping message is printed every minute. If preprocessing took more pan 30 minutes, report to Certora like in step 2, and eiper you can try removing parts of pe code or just run 1 rule instead of all rules. 5. If pere are many rules, you could also try to set -depp=1. This implies pere will be fewer SMT solver instances run per each rule. (default is 10, so 3 or 5 could also work.) It may work better wip even reduced timeouts: -t=60 (default is 300). SMT timeouts SMT is the hardest nut to crack! There could be so many reasons that they occur. But there’s a checklist of things that we can check off before giving up. Timeouts in sanity rules: Those would show up if the code is inherently complex. Red flags to look for: --- ## Tool analyses failing Open the statsdata.json file. For example, if you have a link https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc then the file would be in https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/statsdata.json?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc Look at the ANALYSIS key. If you see any false entries on keys that are not constructor() or ecrecover - report to Certora. ## A non-empty “Call Resolution” warnings table Delegate calls could be tricky and invalidate some of the Prover’s optimizations that were built to avoid timeouts. If such appear, try to scope out the verification to ignore the delegatecalls. Check with a security person, a more experienced user, or even the customer if you’re not sure if it’s safe to ignore. ## Complex data types As of today, passing around complex structs and arrays between contracts and within internal functions could be complicated for the tool. Try to harness those. ## Inline assembly and bitwise arithmetic It may contain complex optimized code. ## Non-linear arithmetic This is usually not expected in sanity rules, but if a timeout happens and only these remain, try to remove those last. It is almost always better to get the sanity rule to succeed for all functions in the contract after applying all the summaries, links, and simplifications you planned to do. If sanity is failing, probably any other rule will also fail. ## Timeouts in your rules At this point, if sanity passed and in reasonable times (not more than 1-2 minutes per method), non-linear arithmetic, an abundance of complex data types management in multiple calls, and complex contract logic are to blame. Some tips: 1. Do you have simpler rules that you did not try yet? Try them first. The simpler the rule, the easier it should be to understand timeouts in it. 2. Try to summarize more extensively. 3. Review your links and dispatchers. If the dispatcher can select more than 2 options (e.g. more than 2 ERC20 tokens), it could add significant overhead to SMT. 4. If your rule checks more than a single assertion, select just one assertion at a time, and comment out the rest. 5. Check one rule at a time and try to increase -depth=15. This could help if the code contains many branches. 6. It could be that internal function summaries were not applied. You can check this with the -showInternalMethods option that prints the internal functions detected. If you provided such summaries and there is no change in run times, please report to Certora. 7. If your rule or code is heavy with bitwise operations, run with -useBitVectorTheory. 8. Set -smt_hashingScheme to either Legacy or PlainInjectivity. Default option is Datatypes."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-2", "chunk-uid": "891656a17308", "chunk-page-index": 2, "text": "9. Set -mediumTimeout to a value above 10. 10. Set the Prover to check every assert individually, by setting -multiAssertCheck. 11. If your rule or code contain divisions, see if underapproximation helps (underapproximation means a counterexample is valid but a proof is not), by using either -divideByConstants=true or -divideNoRemainder=true. 12. Make sure you set the unroll factor --loop_iter to the minimum that is still sound (passing sanity rule). Another option to experiment with regarding loops is -copyLoopUnroll (default 4, one may attempt to decrease). 13. Enable CEGAR (advanced solving mode) with -cegar=true. --- ## Errors Out of Memory (OOM) Report to Certora, along with the zip file for the run. Context-switch to another contract or rule if you can. If you are aware of a complex library or function in the code - try to remove it. Also, try to understand where the tool OOM’d - follow the process described in the global timeout section. Opaque errors in the output page Jump to FinalResults.html to get more information. For example, if you have a link https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc then the file would be in https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/FinalResults.html?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc Share the results with Certora. The comment could still help you get started on debugging. Failures to apply hooks and ghosts One of the most common reasons for hooks failing is that the storage analysis failed. Potential causes: 1. You have an unresolved library call in pe contract. This could be seen from pe Call Resolution Warnings table. Essentially, an unknown delegatecall can freely modify pe contract's storage and violate any storage layout defined by pe main contract we verify. So pe storage analysis fails because it can be unsound to infer anyping about pe storage. 2. Your code is compiled wip optimizations. Solidity's optimizations are notoriously hard to process sometimes. Report to Certora and try to run wipout pem (some codes will fail to compile, in which case a more complicated solution should be devised, ideally in cooperation wip anoper team member or even pe customer). Understanding counter-examples There could be many reasons for false counterexamples, but here are a few common ones. 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-3", "chunk-uid": "891656a17308", "chunk-page-index": 3, "text": "External call havocs. Look for warnings in pe Call Resolution table - pis could indicate havocs. Havocs are a common cause of counterexamples pat seem to come out of nowhere! 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-4", "chunk-uid": "891656a17308", "chunk-page-index": 4, "text": "Links are not applied as expected. Note pat if you use --link to link, you may sometimes need to require pat pe field is equal to pe linked-to contract's address wipin pe rule itself. (Dispatcher links do not have pis issue.) 3. Bitwise operations. By default, pe tool will overapproximate bitwise operations applied in a non-standard way (xor, or, and non 2^n-1 masks for and). Try to look over pe dump and look for red-background lines. You may be able to solve pese by passing pe --prover_arsg -useBitVectorTheory option on pe command line 4. Map. Sometimes pe tool overapproximates map, in particular, multiplication by non-constant, division, and modulo operations. The development team tries to minimize pe number of times it happens, but it could still happen. Follow guidelines for bitwise operations as stated above. 5."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-5", "chunk-uid": "891656a17308", "chunk-page-index": 5, "text": "Aliasing. Be on pe lookout if your environment’s msg.sender is pe same as currentContract or any linked contract. The tool should report pese more clearly but read pe call trace carefully. Also, note trivial assignments like 0."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-6", "chunk-uid": "891656a17308", "chunk-page-index": 6, "text": "6. Correct storage modeling. Suppose you have a rule pat calls some getter, pen you call a function pat’s expected to affect pe results of pat getter, but in pe counterexample it stays pe same. It could be pat pe code invoked is not --- reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function. ## Known issues All of these issues already appear in our to-do list, but it takes time to handle them."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-7", "chunk-uid": "891656a17308", "chunk-page-index": 7, "text": "1. There is no support for structs in CVL. Struct return types can be handled as tuples, but this will work only for simple types. 2. Array support is still limited in CVL. You could pass arrays as arguments, but not get them as return values. Arrays-within-arrays are not supported. You cannot dereference arrays or access their length from a quantified expression. 3. Using quantifiers is generally advised against at this point. 4. Writing to immutable fields in constructors cannot be reasoned about. This will affect you if you have an invariant that checks fields marked immutable. 5. One cannot link to constructors. 6. A loop with a large, statically known constant (> ~10) is impractical to handle - get rid of the relevant code snippet. ## Troubleshooting Certora Prover is a complex tool, relying on many abstractions, and thus its outputs can be confusing. Moreover, it is constantly in development, and as it becomes more robust, one should still be aware of its oddities."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-8", "chunk-uid": "891656a17308", "chunk-page-index": 8, "text": "This page lists a few common issues that can happen and helps in their debugging. Ask, ask, ask! There’s no stupid question. There’s no not-in-place comment. This page will only address a partial subset of the problems that could happen. ## Timeouts Identify the kind of timeout Global timeout Every cloud run is limited to 2 hours. When 2 hours have elapsed, you will get an email that looks like this: As you can see there’s a ~2 hours difference between “Queue Time” and “Finish Time”. ### Action items: 1. Figure out if the problem happened due to having too many rules and SMT taking too long, or if preprocessing has failed to complete in time. Therefore, open the linked-to zip file, extract it, and look into Reports/Results.txt. If there is no message “Has CVL checks” or “Starting to run on rule ….” then there is a good chance that preprocessing took too long. If you did not even see a message “The scene contains … contracts” it means that even the first step of preprocessing took too long. 2. If the problem is preprocessing, first try to run with -enableEqualitySaturation=false, and if that does not help try in addition -simplificationDepth=10. If both don't help, please report to Certora."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-9", "chunk-uid": "891656a17308", "chunk-page-index": 9, "text": "--- ### 3. If you’re blocked on this contract, try to make progress by either summarization, or manually removing parts of the code. The code may contain libraries that add to the complication, so try to “erase” those parts of the code first and re-run. If it works, it's better to undo the changes and apply summarizations. ### 4. Otherwise, if rules are already starting to process, check how long approximately preprocessing took. You can measure that using the “Ping” messages. A ping message is printed every minute. If preprocessing took more than 30 minutes, report to Certora like in step 2, and either you can try removing parts of the code or just run 1 rule instead of all rules. ### 5. If there are many rules, you could also try to set -depth=1. This implies there will be fewer SMT solver instances run per each rule. (default is 10, so 3 or 5 could also work.) It may work better with even reduced timeouts: -t=60 (default is 300.) ### SMT timeouts SMT is the hardest nut to crack! There could be so many reasons that they occur."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-10", "chunk-uid": "891656a17308", "chunk-page-index": 10, "text": "But there’s a checklist of things that we can check off before giving up. ### Timeouts in sanity rules: Those would show up if the code is inherently complex. Red flags to look for: - Tool analyses failing. Open the statsdata.json file. For example, if you have a link https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc then the file would be in https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/statsdata.json?anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc Look at the ANALYSIS key. If you see any false entries on keys that are not constructor() or ecrecover - report to Certora. - A non-empty “Call Resolution” warnings table. Delegate calls could be tricky and invalidate some of the Prover’s optimizations that were built to avoid timeouts. If such appear, try to scope out the verification to ignore the delegatecalls. Check with a security person, a more experienced user, or even the customer if you’re not sure if it’s safe to ignore. - Complex data types. As of today, passing around complex structs and arrays between contracts and within internal functions could be complicated for the tool. Try to harness those. - Inline assembly and bitwise arithmetic. It may contain complex optimized code. - Non-linear arithmetic. This is usually not expected in sanity rules, but if a timeout happens and only these remain, try to remove those last. It is almost always better to get the sanity rule to succeed for all functions in the contract after applying all the summaries, links, and simplifications you planned to do. If sanity is failing, probably any other rule will also fail. ### Timeouts in your rules: At this point, if sanity passed and in reasonable times (not more than 1-2 minutes per method), non-linear arithmetic, an abundance of complex data types management in multiple calls, and complex contract logic are to blame. Some tips: - Do you have simpler rules that you did not try yet? Try them first. The simpler the rule, the easier it should be to understand timeouts in it. - Try to summarize more extensively. - Review your links and dispatchers. If the dispatcher can select more than 2 options (e.g. more than 2 ERC20 tokens), it could add significant overhead to SMT. - If your rule checks more than a single assertion, select just one assertion at a time, and comment out the rest. --- ## 5. Check one rule at a time and try to increase -depth=15. This could help if the code contains many branches. ## 6. It could be that internal function summaries were not applied. You can check this with the -showInternalMethods option that prints the internal functions detected. If you provided such summaries and there is no change in run times, please report to Certora. ## 7. If your rule or code is heavy with bitwise operations, run with -useBitVectorTheory. ## 8. Set -smt_hashingScheme to either Legacy or PlainInjectivity. Default option is Datatypes."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-11", "chunk-uid": "891656a17308", "chunk-page-index": 11, "text": "## 9. Set -mediumTimeout to a value above 10. ## 10. Set the Prover to check every assert individually, by setting -multiAssertCheck. ## 11. If your rule or code contain divisions, see if underapproximation helps (underapproximation means a counterexample is valid but a proof is not), by using either -divideByConstants=true or -divideNoRemainder=true. ## 12. Make sure you set the unroll factor --loop_iter to the minimum that is still sound (passing sanity rule). Another option to experiment with regarding loops is -copyLoopUnroll (default 4, one may attempt to decrease). ## 13. Enable CEGAR (advanced solving mode) with -cegar=true. ## Errors ### Out of Memory (OOM) Report to Certora, along with the zip file for the run. Context-switch to another contract or rule if you can. If you are aware of a complex library or function in the code - try to remove it. Also, try to understand where the tool OOM’d - follow the process described in the global timeout section. ### Opaque errors in the output page Jump to FinalResults.html to get more information. For example, if you have a link https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/? anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc then the file would be in https://vaas-stg.certora.com/output/43260/dafd64136c1d71ba882c/FinalResults.html? anonymousKey=a8e7a2b10c4f9f74ea55624c166d7edee8f1e2bc Share the results with Certora. The comment could still help you get started on debugging. ### Failures to apply hooks and ghosts One of the most common reasons for hooks failing is that the storage analysis failed. Potential causes: 1. You have an unresolved library call in the contract. This could be seen from the Call Resolution Warnings table. Essentially, an unknown delegatecall can freely modify the contract's storage and violate any storage layout defined by the main contract we verify. So the storage analysis fails because it can be unsound to infer anything about the storage. 2. Your code is compiled with optimizations. Solidity's optimizations are notoriously hard to process sometimes. Report to Certora and try to run without them (some codes will fail to compile, in which case a more complicated solution should be devised, ideally in cooperation with another team member or even the customer). ### Understanding counter-examples There could be many reasons for false counterexamples, but here are a few common ones. --- A counterexample that looks fishy does not rule out a potential bug that the rule can uncover. ## External call havocs Look for warnings in the Call Resolution table - this could indicate havocs. Havocs are a common cause of counterexamples that seem to come out of nowhere! ## Links are not applied as expected Note that if you use --link to link, you may sometimes need to require that the field is equal to the linked-to contract's address within the rule itself. (Dispatcher links do not have this issue.) ## Bitwise operations By default, the tool will overapproximate bitwise operations applied in a non-standard way (xor, or, and non 2^n-1 masks for and). Try to look over the dump and look for red-background lines. You may be able to solve these by passing the --prover_arsg -useBitVectorTheory option on the command line ## Math Sometimes the tool overapproximates math, in particular, multiplication by non-constant, division, and modulo operations. The development team tries to minimize the number of times it happens, but it could still happen."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-12", "chunk-uid": "891656a17308", "chunk-page-index": 12, "text": "Follow guidelines for bitwise operations as stated above. ## Aliasing Be on the lookout if your environment’s msg.sender is the same as currentContract or any linked contract. The tool should report these more clearly but read the call trace carefully."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-13", "chunk-uid": "891656a17308", "chunk-page-index": 13, "text": "Also, note trivial assignments like 0. ## Correct storage modeling Suppose you have a rule that calls some getter, then you call a function that’s expected to affect the results of that getter, but in the counterexample it stays the same. It could be that the code invoked is not reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function. ## Known issues All of these issues already appear in our to-do list, but it takes time to handle them."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "perplexed", "id": "891656a17308-14", "chunk-uid": "891656a17308", "chunk-page-index": 14, "text": "### 1. There is no support for structs in CVL. Struct return types can be handled as tuples, but this will work only for simple types. ### 2. Array support is still limited in CVL. You could pass arrays as arguments, but not get them as return values. Arrays-within-arrays are not supported. You cannot dereference arrays or access their length from a quantified expression. ### 3. Using quantifiers is generally advised against at this point. ### 4. Writing to immutable fields in constructors cannot be reasoned about. This will affect you if you have an invariant that checks fields marked immutable. ### 5. One cannot link to constructors. ### 6. A loop with a large, statically known constant (> ~10) is impractical to handle - get rid of the relevant code snippet."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gaps", "id": "2e1eb25e5b4d-0", "chunk-uid": "2e1eb25e5b4d", "chunk-page-index": 0, "text": "## Understanding gaps between high and low level code The Certora Prover is analyzing low-level code, such as the EVM bytecode. However, the CVL specification as well as the Rule Report and Call Trace are usually presenting information in terms of the high-level language (e.g., Solidity). In this document we describe how some of the gaps between the high-level source and the low-level bytecode can affect our understanding of the Prover's outputs, and recommended solutions. ### Loops Determining the number of needed iterations The Prover deals with loops by unrolling them a constant number of times (see {ref}--loop_iter). Furthermore, it can add an assertion that the number of unrolled iterations was sufficient to fully capture all of the loop's behavior, which is usually useful in loops that are known to have a constant number of iterations. Otherwise, the user can opt-in to assume the unroll bound was sufficient (see {ref}--optimistic_loop). This approach works well for common simple loops such as: solidity uint x; for (uint i = 0; i < 3 ; i++) { x++; } {note} For trivial loops such as the above, the Prover automatically infers the required number of iterations is 3, even if a lower `--loop_iter` is provided. The natural loop condition determining whether we enter the body of the loop or exit is clearly i < 3, thus 3 iterations are sufficient to fully unroll the loop and render the loop condition false. If --loop_iter 3 is defined, the Prover unrolls the loop 3 times, and evaluates the loop exit condition one more time (a total of 4 evaluations of the loop exit condition). The resulting code would behave like the following Solidity snippet: solidity uint x; uint i = 0; if (i < 3) { // iteration #1 i++; x++; if (i < 3) { // iteration #2 i++; x++; if (i < 3) { // iteration #3 i++; x++; assert (i < 3) // exit condition evaluation // require(i < 3) if `--optimistic_loop` is set } } } However, for less trivial cases, the definition is not so clear: solidity uint x; // global state variable uint i = 0; while (true) { x++; // if x overflows, we exit the loop and revert. But is this the loop condition? if (i >= 3) { break; } i += 1; } Running the builtin sanity rule for the above code with --loop_iter of 2 or less results in sanity violation (can find no paths reaching the end of the loop), as is expected. Sanity is passing with --loop_iter 3. However, running with --loop_iter 3 actually shows 4 loop iterations in the Call Trace output. The reason for that is that in cases the Prover cannot detect an exit condition in the loop's head, it unrolls one extra time to evaluate a potential exit condition in the loop's body."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gaps", "id": "2e1eb25e5b4d-1", "chunk-uid": "2e1eb25e5b4d", "chunk-page-index": 1, "text": "In our case, the bytecode representation shows that the loop's head is ending with a non-conditional jump. The equivalent Solidity-like version of the unrolled code would look as follows, (c-style goto and label commands were added for clarity): solidity uint x; // global state variable uint i = 0; // iteration #1 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #2 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #3 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #4 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; assert(false); // require(false) if --optimistic_loop is set afteroriginalwhileloopend: ... In the next example, we show how two different compilations of the same code lead to different behaviors of the unroller. First low-level conditional branch is used for unrolling --- The following examples show how the same code can generate different bytecodes in different versions of the Solidity compiler, in a way that affects the Prover's behavior. Consider: solidity import \"./Other.sol\"; contract Loops { uint x; Other other; function loop() external { for (int i = 0 ; other.cond(i) ; i++) { x++; } } } where the Other contract is defined as: solidity contract Other { function cond(int i) external returns (bool) { return i < 3; } } Considering the behavior of both contracts (by linking --link Loops:other=Other), we would assume that 3 iterations are sufficient: we increment i three times, and then evaluate the loop-exit condition other.cond(3) which then evaluates to false. If the contract is compiled with solc version 0.8.18 and without optimizations, this is exactly the behavior that we get. The sanity rule will succeed with just 3 iterations (--loop_iter 3). However, if we compiled the same code with solc version 0.7.6, we note that sanity fails for 3 iterations, and succeeds with 4 iterations. The reason for that is that in solc7.6, the first condition checked in the loop's head is that the extcodesize value of other is greater than zero, and this is considered the loop exit condition. Therefore, with --loop_iter 3, the Prover is running 3 iterations of the loop, and one more check that extcodesize(other) > 0, which trivially evaluates to true. One extra loop iteration is required to reach the actual code checking the value of i in other, and indeed with --loop_iter 4 the sanity rule passes. Of course, the user is not expected to be aware of such delicacies in how Solidity contracts are compiled. It is therefore recommended to ensure the chosen --loop_iter configuration is sufficient both by running the basic sanity rule, and if loops appear only under certain conditions, to write specialized sanity rules that force the Prover to reason about these particular code paths. Mutation testing can also be useful here. ## Understanding gaps between high and low level code The Certora Prover is analyzing low-level code, such as the EVM bytecode. However, the CVL specification as well as the Rule Report and Call Trace are usually presenting information in terms of the high-level language (e.g., Solidity). In this document we describe how some of the gaps between the high-level source and the low-level bytecode can affect our understanding of the Prover's outputs, and recommended solutions. ## Loops ### Determining the number of needed iterations The Prover deals with loops by unrolling them a constant number of times (see <ref>--loop_iter). Furthermore, it can add an assertion that the number of unrolled iterations was sufficient to fully capture all of the loop's behavior, which is usually useful in loops that are known to have a constant number of iterations. Otherwise, the user can opt-in to assume the unroll bound was sufficient (see <ref>--optimistic_loop). This approach works well for common simple loops such as: solidity uint x; for (uint i = 0; i < 3 ; i++) { x++; } <note>For trivial loops such as the above, the Prover automatically infers the required number of iterations is 3, even if a lower `--loop_iter` is provided.</note> The natural loop condition determining whether we enter the body of the loop or exit is clearly i < 3, thus 3 iterations are sufficient to fully unroll the loop and render the loop condition false. If --loop_iter 3 is defined, the Prover unrolls the loop 3 times, and evaluates the loop exit condition one more time (a total of 4 evaluations of the loop exit condition). The resulting code would behave like the following Solidity snippet: solidity uint x; uint i = 0; if (i < 3) { // } --- iteration #1 i++; x++; if (i < 3) { // iteration #2 i++; x++; if (i < 3) { // iteration #3 i++; x++; assert (i < 3) // exit condition evaluation // require(i < 3) if `--optimistic_loop` is set } } } However, for less trivial cases, the definition is not so clear: solidity uint x; // global state variable uint i = 0; while (true) { x++; // if x overflows, we exit the loop and revert. But is this the loop condition?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gaps", "id": "2e1eb25e5b4d-2", "chunk-uid": "2e1eb25e5b4d", "chunk-page-index": 2, "text": "if (i >= 3) { break; } i += 1; } Running the builtin sanity rule for the above code with --loop_iter of 2 or less results in sanity violation (can find no paths reaching the end of the loop), as is expected. Sanity is passing with --loop_iter 3. However, running with --loop_iter 3 actually shows 4 loop iterations in the Call Trace output. The reason for that is that in cases the Prover cannot detect an exit condition in the loop's head, it unrolls one extra time to evaluate a potential exit condition in the loop's body."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gaps", "id": "2e1eb25e5b4d-3", "chunk-uid": "2e1eb25e5b4d", "chunk-page-index": 3, "text": "In our case, the bytecode representation shows that the loop's head is ending with a non-conditional jump. The equivalent Solidity-like version of the unrolled code would look as follows, (c-style goto and label commands were added for clarity): solidity uint x; // global state variable uint i = 0; // iteration #1 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #2 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #3 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; // iteration #4 x++; if (i >= 3) { goto afteroriginalwhileloopend; } i += 1; assert(false); // require(false) if --optimistic_loop is set afteroriginalwhileloopend: ... In the next example, we show how two different compilations of the same code lead to different behaviors of the unroller. First low-level conditional branch is used for unrolling The following examples show how the same code can generate different bytecodes in different versions of the Solidity compiler, in a way that affects the Prover's behavior. Consider solidity import \"./Other.sol\"; |contract Loops| | | |---|---|---| |uint x;| | | |Other other;| | | |function loop() external| | | |for (int i = 0 ; other.cond(i) ; i++)| | | |x++;| | | |}| | | where the Other contract is defined as: solidity contract Other { function cond(int i) external returns (bool) { return i < 3; } } Considering the behavior of both contracts (by linking --link Loops:other=Other), we would assume that 3 iterations are sufficient: we increment i three times, and then evaluate the loop-exit condition other.cond(3) which then evaluates to false. If the contract is compiled with solc version 0.8.18 and without optimizations, this is exactly the behavior that we get. The sanity rule will succeed with just 3 iterations (--loop_iter 3). However, if we compiled the same code with solc version 0.7.6, we note that sanity fails for 3 iterations, and succeeds with 4 iterations. The reason for that is that in solc7.6, the first condition checked in the loop's head is that the extcodesize value of other is greater than zero, and this is considered the loop exit condition. Therefore, with --loop_iter 3, the Prover is running 3 iterations of the loop, and one more check that extcodesize(other) > 0, which trivially evaluates to true. One extra loop iteration is required to reach the actual code checking the value of i in other, and indeed with --loop_iter 4 the sanity rule passes. Of course, the user is not expected to be aware of such delicacies in how Solidity contracts are compiled. It is therefore recommended to ensure the chosen --loop_iter configuration is sufficient both by running the basic sanity rule, and if loops appear only under certain conditions, to write specialized sanity rules that force the Prover to reason about these particular code paths. Mutation testing can also be useful here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sums", "id": "ac790319d40c-0", "chunk-uid": "ac790319d40c", "chunk-page-index": 0, "text": "Tracking Sums Enforcing Sum of Two Balances Constraint cvl invariant directSumOfTwo(address a, address b) (a != b) => (balanceOf(a) + balanceOf(b) <= to_mapint(totalSupply())); Ensure that the sum of balances for any two distinct addresses, a and b, does not exceed the total supply. Maintaining Equality Between Sum of Balances and Total Supply cvl ghost mathint sumBalances { init_state axiom sumBalances == 0; } hook Sstore balanceOf[KEY address user] uint256 newBalance (uint256 oldBalance) { // there is no += operator in CVL sumBalances = sumBalances + newBalance - oldBalance; } invariant totalIsSumBalances() to_mathint(totalSupply()) == sumBalances; Track the sum of all balances and ensure that it remains equal to the total supply. The sumBalances ghost variable is updated with changes in individual balances using a storage hook, ensuring accuracy and consistency in the overall sum. for more information about the example checkout this tutorial. Tracking Sums Enforcing Sum of Two Balances Constraint cvl invariant directSumOfTwo(address a, address b) (a != b) => (balanceOf(a) + balanceOf(b) <= to_mapint(totalSupply())); Ensure that the sum of balances for any two distinct addresses, a and b, does not exceed the total supply. Maintaining Equality Between Sum of Balances and Total Supply cvl ghost mathint sumBalances { init_state axiom sumBalances == 0; } hook Sstore balanceOf[KEY address user] uint256 newBalance (uint256 oldBalance) { // there is no += operator in CVL sumBalances = sumBalances + newBalance - oldBalance; } invariant totalIsSumBalances() to_mathint(totalSupply()) == sumBalances; Track the sum of all balances and ensure that it remains equal to the total supply. The sumBalances ghost variable is updated with changes in individual balances using a storage hook, ensuring accuracy and consistency in the overall sum."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sums", "id": "ac790319d40c-1", "chunk-uid": "ac790319d40c", "chunk-page-index": 1, "text": "for more information about the example checkout this tutorial."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-0", "chunk-uid": "8589cf42ca40", "chunk-page-index": 0, "text": "## Certora CLI 5.0 Changes The release of certora-cli version 5.0 introduces a few small breaking changes for CVL. These changes improve the coverage for parametric rules and invariants, disallow Solidity function calls in quantified expressions, and simplify some rarely-used features. This document explains those changes and how to work with them. Note: certora-cli 5.0 also includes several new features, bug fixes, and performance improvements that are not discussed here; see prover-release-notes for more details. ## Exhaustive parametric rules Starting with certora-cli version 5.0, parametric rules and invariants will now be checked on the methods of all contracts by default, instead of just the primary contract. This change improves the coverage of rules and can catch important errors."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-1", "chunk-uid": "8589cf42ca40", "chunk-page-index": 1, "text": "For example, an invariant that relates a contract's total supply to its balance in an underlying token contract could be invalidated by calling methods directly on the underlying token; before this change those violations would not have been detected. This change can break existing specifications in a few ways: - A property that should hold cannot be verified. - A parametric rule that was never intended to apply to secondary contracts may be violated by methods of those contracts. - Verification may time out on methods of secondary contracts. The remainder of this section describes how to address these three failure modes. ## Fixing properties that should hold Most parametric rules and all invariants encode general properties of a system that should be impossible for any contract to violate. For example, consider a \"solvency\" invariant that shows that a vault contract holds enough underlying tokens to cover any withdrawals: cvl invariant solvency() underlying.balanceOf(currentContract) >= currentContract.totalSupply(); Any violation of this property would be an important security vulnerability, regardless of whether it is violated by a method of the vault or a method of the underlying token. Therefore, it is important to check that no method of any contract can violate these kinds of properties. However, sometimes verifying these kinds of properties on methods of secondary contracts will require additional work. Continuing the solvency example, the Prover is likely to find a violation of the solvency rule in underlying.transferFrom where the vault contract has given an allowance to a third party. If a third party has an allowance, it will be able to reduce the vault's balance by transferring the vault's tokens to itself. This violation represents an important vulnerability: if the vault mismanages its allowances, then it may become insolvent. This violation shows that the solvency of the vault depends on the correct management of its underlying allowances. Therefore, to get the rule to pass, we will need to add another invariant stating that the vault manages its allowances correctly: cvl invariant no_vault_allowance() underlying.allowance(currentContract) == 0; --- ## We can then use this invariant in the preserved block for the original solvency rule. We are also likely to get violations from the case that the vault contract itself calls methods on the underlying contract, so we rule that out as well[^call-note]: behaviors. If the vault does call methods on the underlying contract, it will only do so from its code, and that call will be analyzed while the Prover is verifying the calling method. The additional requirement only rules out spurious counterexamples where the vault makes calls to the underlying token without having code that does so. cvl invariant solvency() underlying.balanceOf(currentContract) >= currentContract.totalSupply() preserved wip (env e) { require e.msg.sender != currentContract; requireInvariant no_vault_allowance(); } There is nothing new about this process of identifying violations and adding new invariants as necessary; it is the same process you would use for analyzing any violation. This example just shows that some work may be required when verifying old specifications with certora-cli 5.0. The benefit is that by checking methods on secondary contracts, the Prover forces us to consider previously unstated assumptions about the contract and write invariants that could detect important security vulnerabilities. For this reason, you are encouraged to identify and prove additional invariants to address counterexamples instead of using the filtering techniques described in the following sections. ## Filtering properties that should not be checked Some parametric rules encode properties that are only expected to hold on a specific contract. For example, you might have a rule that ensures that every successful method invocation is correctly authorized: cvl rule auporization_check(mepod f) filtered { f -> f.isView } { env e; calldataarg args; f(e,args); assert is_auporized(e.msg.sender, f.selector); There is no reason to expect this property to hold on any contract besides the main contract. To handle cases like these, certora-cli 5.0 introduces two new ways to filter methods to a specific contract. The first and simplest way to restrict verification to a specific contract is to call the method object with a specific receiver contract: rule auporization_check(mepod f) filtered { f -> f.isView } { env e; calldataarg args; currentContract.f(e,args); assert is_auporized(e.msg.sender, f.selector); This syntax will add a filter that will only instantiate f with the methods of currentContract. The receiver may be either currentContract or a variable introduced by a using clause. The second and more flexible way is to use the new contract property of the method variable: rule auporization_check(mepod f) filtered { f -> f.isView && f.contract == currentContract } { env e; calldataarg args; f(e,args); --- assert is_authorized(e.msg.sender, f.selector); If f is a method variable, f.contract refers to the contract that contains the method f. (v5-contract-option) Focusing on specific contracts If you want to focus verification on a specific contract, you can do so using the --parametric_contracts option. This option takes a list of contracts and only instantiates parametric rules and invariants on methods of those contracts. You can use this option to help transition specs to certora-cli 5.0; if C is the main contract being verified, then passing --parametric_contracts C will cause method variables to be instantiated in the same way they would have in older versions. Disallow calls to contract functions in quantified expressions Starting with certora-cli version 5.0, the Prover no longer supports making contract method calls in quantified expression bodies by default. For example, given the simple contract below, you can no longer use the method getI() in a quantified expression body. contract example { uint i; function getI() public view returns (uint256) { return i; } } cvl :emphasize-lines: 4 rule there_exists { // Using getI() in the quantified body will now cause the Prover to // generate a type-checking error. require (exists uint256 i . i == getI()); assert false, \"Prover will generate an error before this line\"; } In the example rule there_exists, the Prover will now generate an error similar to the following: Error in spec file (test2.spec:8:36): Contract function calls such as getI() are disallowed inside quantified formulas. In most simple cases, you can replace contract method calls with either a direct storage access or a ghost. For example the above function getI simply returns the storage variable i and you can change the require statement in the there_exists rule to use storage access: require (exists uint i . i == currentContract.i). To use a ghost, declare the ghost and the hook that populates the ghost with the current value of the contract variable i. cvl ghost uint gI; hook Sstore i uint256 v { gI = v; } Finally, replace getI in the require statement in rule there_exists with the ghost variable gI: require (exists uint i . i == gI). If you must use contract method calls in quantified expressions, you can still access the old behavior by specifying the --allow_solidity_calls_in_quantifiers argument to certoraRun on the command line. Method variable restrictions Starting with certora-cli version 5.0, you cannot declare new method variables anywhere except the top-level body of a rule. Declaring new method variables inside of if statements, hook bodies, CVL function bodies, --- preserved blocks, and all other contexts are all disallowed. You can still pass method-type variables as arguments to CVL functions and definitions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-2", "chunk-uid": "8589cf42ca40", "chunk-page-index": 2, "text": "You can use this feature to rewrite CVL functions that formerly declared new method variables. For example, before certora-cli 5.0, the following CVL function was valid: cvl function call_arbitrary() { mepod f; env e; calldataarg args; f(e, args); } rule r { call_arbitrary(); assert true; } The declaration of f inside of call_arbitrary is now disallowed, so f must be passed into call_arbitrary instead of declared within it: cvl function call_arbitrary(mepod f) { env e; calldataarg args; f(e,args); } rule r { mepod f; call_arbitrary(f); assert true; } New DELETE summary syntax The syntax of the new `DELETE` keyword <delete-summary> in summaries has changed. Prior to certora-cli 5.0, it was possible to call methods summarized with DELETE summaries from spec, and the user had to annotate the DELETE modifier to indicate how those calls should be treated. Starting with certora-cli 5.0, calling methods that have been summarized with a DELETE summary is disallowed, and the DELETE annotation requires no additional annotation. CLI changes: New Parametric Contracts Attribute As mentioned above the attribute parametric_contracts was added to certora-cli 5.0. The attribute accepts the parametric contracts as a list of strings. The attribute can be set as the CLI flag --parametric_contracts or in a .conf file. Example CLI: certoraRun C1.sol C2.sol C3.sol --parametric_contracts C1 C3 ... Configuration file: \"files\": [ \"C1\", \"C2\", \"C3\"], \"parametric_contracts\": [ \"C1\", \"C3\"], ... CLI changes: End of CVL1 Deprecation period With the release of certora-cli version 5.0, we stop supporting the CVL1 attributes that were deprecated during the transition to CVL2. You can find the list of the deprecated attributes here. Certora CLI 5.0 Changes The release of certora-cli version 5.0 introduces a few small breaking changes for CVL. These changes improve the coverage for parametric rules and invariants, disallow Solidity function calls in quantified expressions, and simplify some rarely-used features. This document explains those changes and how to work with them. {note} `certora-cli` 5.0 also includes several new features, bug fixes, and performance improvements that are not discussed here; see {ref}`prover-release-notes` for more details. {contents} --- ## Exhaustive parametric rules Starting with certora-cli version 5.0, parametric rules and invariants will now be checked on the methods of all contracts by default, instead of just the primary contract. This change improves the coverage of rules and can catch important errors."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-3", "chunk-uid": "8589cf42ca40", "chunk-page-index": 3, "text": "For example, an invariant that relates a contract's total supply to its balance in an underlying token contract could be invalidated by calling methods directly on the underlying token; before this change those violations would not have been detected. This change can break existing specifications in a few ways: - A property that should hold cannot be verified. - A parametric rule that was never intended to apply to secondary contracts may be violated by methods of those contracts. - Verification may time out on methods of secondary contracts. The remainder of this section describes how to address these three failure modes. ### Fixing properties that should hold Most parametric rules and all invariants encode general properties of a system that should be impossible for any contract to violate. For example, consider a \"solvency\" invariant that shows that a vault contract holds enough underlying tokens to cover any withdrawals: cvl invariant solvency() underlying.balanceOf(currentContract) >= currentContract.totalSupply(); Any violation of this property would be an important security vulnerability, regardless of whether it is violated by a method of the vault or a method of the underlying token. Therefore, it is important to check that no method of any contract can violate these kinds of properties. However, sometimes verifying these kinds of properties on methods of secondary contracts will require additional work. Continuing the solvency example, the Prover is likely to find a violation of the solvency rule in underlying.transferFrom where the vault contract has given an allowance to a third party. If a third party has an allowance, it will be able to reduce the vault's balance by transferring the vault's tokens to itself. This violation represents an important vulnerability: if the vault mismanages its allowances, then it may become insolvent. This violation shows that the solvency of the vault depends on the correct management of its underlying allowances. Therefore, to get the rule to pass, we will need to add another invariant stating that the vault manages its allowances correctly: cvl invariant no_vault_allowance() underlying.allowance(currentContract) == 0; We can then use this invariant in the preserved block for the original solvency rule. We are also likely to get violations from the case that the vault contract itself calls methods on the underlying contract, so we rule that out as well: behaviors. If the vault does call methods on the underlying contract, it will only do so from its code, and that call will be analyzed while the Prover is verifying the calling method. The additional requirement only rules out spurious counterexamples where the vault makes calls to the underlying token without having code that does so. cvl invariant solvency() underlying.balanceOf(currentContract) >= currentContract.totalSupply() { preserved with (env e) { require e.msg.sender != currentContract; requireInvariant no_vault_allowance(); } } --- There is nothing new about this process of identifying violations and adding new invariants as necessary; it is the same process you would use for analyzing any violation. This example just shows that some work may be required when verifying old specifications with certora-cli 5.0. The benefit is that by checking methods on secondary contracts, the Prover forces us to consider a previously unstated assumptions about the contract and write invariants that could detect important security vulnerabilities. For this reason, you are encouraged to identify and prove additional invariants to address counterexamples instead of using the filtering techniques described in the following sections. Filtering properties that should not be checked Some parametric rules encode properties that are only expected to hold on a specific contract. For example, you might have a rule that ensures that every successful method invocation is correctly authorized: cvl rule auporization_check(mepod f) filtered { f -&gt; f.isView } { env e; calldataarg args; f(e,args); assert is_auporized(e.msg.sender, f.selector); There is no reason to expect this property to hold on any contract besides the main contract. To handle cases like these, certora-cli 5.0 introduces two new ways to filter methods to a specific contract. The first and simplest way to restrict verification to a specific contract is to call the method object with a specific receiver contract: cvl :emphasize-lines: 6 rule auporization_check(mepod f) filtered { f -&gt; f.isView } { env e; calldataarg args; currentContract.f(e,args); assert is_auporized(e.msg.sender, f.selector); This syntax will add a filter that will only instantiate f with the methods of currentContract. The receiver may be either currentContract or a variable introduced by a using clause. The second and more flexible way is to use the new contract property of the method variable: cvl :emphasize-lines: 2 rule auporization_check(mepod f) filtered { f -&gt; f.isView &amp;&amp; f.contract == currentContract } { env e; calldataarg args; f(e,args); assert is_auporized(e.msg.sender, f.selector); If f is a method variable, f.contract refers to the contract that contains the method f. --- If you want to focus verification on a specific contract, you can do so using the {ref}--parametric_contracts option."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-4", "chunk-uid": "8589cf42ca40", "chunk-page-index": 4, "text": "This option takes a list of contracts and only instantiates parametric rules and invariants on methods of those contracts. You can use this option to help transition specs to certora-cli 5.0; if C is the main contract being verified, then passing --parametric_contracts C will cause method variables to be instantiated in the same way they would have in older versions. Disallow calls to contract functions in quantified expressions Starting with certora-cli version 5.0, the Prover no longer supports making contract method calls in quantified expression bodies by default. For example, given the simple contract below, you can no longer use the method getI() in a quantified expression body. {code-block} solidity contract example { uint i; function getI() public view returns (uint256) { return i; } } } {code-block} cvl :emphasize-lines: 4 rule pere_exists { // Using getI() in pe quantified body will now cause pe Prover to // generate a type-checking error. require (exists uint256 i . i == getI()); assert false, \"Prover will generate an error before pis line\"; } } In the example rule there_exists, the Prover will now generate an error similar to the following: Error in spec file (test2.spec:8:36): Contract function calls such as getI() are disallowed inside quantified formulas. In most simple cases, you can replace contract method calls with either a {ref}direct storage access or a {ref}ghost."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-5", "chunk-uid": "8589cf42ca40", "chunk-page-index": 5, "text": "For example, the above function getI simply returns the storage variable i and you can change the require statement in the there_exists rule to use storage access: require (exists uint i . i == currentContract.i). To use a ghost, declare the ghost and the hook that populates the ghost with the current value of the contract variable i. {code-block} cvl ghost uint gI; hook Sstore i uint256 v { gI = v; } } Finally, replace getI in the require statement in rule there_exists with the ghost variable gI: require (exists uint i . i == gI)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-6", "chunk-uid": "8589cf42ca40", "chunk-page-index": 6, "text": "If you must use contract method calls in quantified expressions, you can still access the old behavior by specifying the {ref}--allow_solidity_calls_in_quantifiers argument to certoraRun on the command line. Method variable restrictions Starting with certora-cli version 5.0, you cannot declare new {ref}method variables anywhere except the top-level body of a rule. Declaring new method variables inside of if statements, hook bodies, CVL function bodies, preserved blocks, and all other contexts are all disallowed. You can still pass method-type variables as arguments to CVL functions and definitions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "v5-changes", "id": "8589cf42ca40-7", "chunk-uid": "8589cf42ca40", "chunk-page-index": 7, "text": "You can use this feature to rewrite CVL functions that formerly declared new method variables. For example, before certora-cli 5.0, the following CVL function was valid: cvl function call_arbitrary() { mepod f; env e; calldataarg args; f(e, args); } rule r { call_arbitrary(); assert true; } } --- ## The declaration of f inside of call_arbitrary is now disallowed, so f must be passed into call_arbitrary instead of declared within it: cvl function call_arbitrary(mepod f) { env e; calldataarg args; f(e,args); } rule r { mepod f; call_arbitrary(f); assert true; } ## New DELETE summary syntax The syntax of the new DELETE keyword delete-summary in summaries has changed. Prior to certora-cli 5.0, it was possible to call methods summarized with DELETE summaries from spec, and the user had to annotate the DELETE modifier to indicate how those calls should be treated. Starting with certora-cli 5.0, calling methods that have been summarized with a DELETE summary is disallowed, and the DELETE annotation requires no additional annotation. ## CLI changes: New Parametric Contracts Attribute As mentioned above the attribute parametric_contracts was added to certora-cli 5.0. The attribute accepts the parametric contracts as a list of strings. The attribute can be set as the CLI flag --parametric_contracts or in a .conf file. Example CLI: certoraRun C1.sol C2.sol C3.sol --parametric_contracts C1 C3 ... Configuration file: \"files\": [ \"C1\", \"C2\", \"C3\"], \"parametric_contracts\": [ \"C1\", \"C3\"], ... ## CLI changes: End of CVL1 Deprecation period With the release of certora-cli version 5.0, we stop supporting the CVL1 attributes that were deprecated during the transition to CVL2. You can find the list of the deprecated attributes here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "methods", "id": "ca9becd4e794-0", "chunk-uid": "ca9becd4e794", "chunk-page-index": 0, "text": "|Summary|Return value|Return code|Current contract state|Other contracts states|Balances| |---|---|---|---|---|---| |HAVOC_ALL|*|*|*|*|Havoc'd except for current contract's balance| |HAVOC_ECF|*|*|Unchanged|*|Contract's balance that may increase| |ALWAYS(n)|n|success (1)|Unchanged|Unchanged|Unchanged| |CONSTANT|Some constant x for all calls to the same method signature in any target contract|success (1)|Unchanged|Unchanged|Unchanged| |PER_CALLEE_CONSTANT|constant x_c for all calls to the same method signature|success (1)|Unchanged|Unchanged|Unchanged| |DISPATCHER[(bool)]|See below|See below|See below|See below|Unchanged (up to current transfer)| |NONDET|*|success(1)|Unchanged|Unchanged|Up to current transfer| |AUTO|*|*|Depends on call type*|Depends on call type*|Depends on call type*| Internal Function Summaries Allowed Summaries Not all summaries make sense in the context of an internal function. Only the following summaries are allowed: - ALWAYS(X) the summary always returns X and has no side-effects - CONSTANT the summary always returns the same constant and has no side effects - NONDET the summary returns a havoced value - Ghost the summary returns the value return by the given ghost function with the given arguments --- ## Example Consider the following toy contract where accounts earn continuously compounding interest. Balances are stored as \"day 0 principal\" and current balances are calculated from that principal using the function continuous_interest which implements the standard continuous interest formula. |solidity contract Interest {|uint256 days;|uint256 interest;|mapping(address => uint256) principals;| |---|---|---|---| |// decimals 18 public|uint256 constant e = 2718300000000000000;| | | |function balance(address account) public view returns (uint256) {|return continuous_interest(principals[account], interest, days);| | | |function advanceDays(uint256 n) public {|days = days + n;| | | |function continuous_interest(uint256 p, uint256 r, uint256 t) internal pure returns (uint256) {|return p * e ** (r * t);| | | |}|}| | | Now suppose we would like to prove that this balance calculation is monotonic with respect to time (as days go by, balance never decreases). The following spec would demonstrate this property. cvl rule yield_monotonic(address a, uint256 n) { uint256 y1 = balance(a); require n >= 0; advanceDays(n); uint256 y2 = balance(a); assert y2 >= y1; } Unfortunately, the function continuous_interest includes some arithmetic that is very difficult for the underlying SMT solver to reason about and two things may happen. 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "methods", "id": "ca9becd4e794-1", "chunk-uid": "ca9becd4e794", "chunk-page-index": 1, "text": "The resulting formula may be cause the underlying SMT formula to time out which will result in an unknown result 2. The Prover will use \"overapproximations\" of the arithmetic operations in the resulting formula. Basically this means that we let allows some weird and unexpected behavior which includes the behavior of the function, but also includes more behavior. Basically, this means that a counterexample may not be a real counterexample (i.e. not actually possible program behavior). To understand this better see our section on overapproximation. It turns out that in this case, we run into problem (2) where the tool reports a violation which doesn't actually make sense. This is where function summarization becomes useful, since we get to decide how we would like to overapproximate our function! Suppose we would like to prove that, assuming the equation we use to calculate continuously compounding interest is monotonic, then it is also the case that the value of our principal is monotonically increasing over time. In this case we do the following: |cvl methods {|// tell the tool to use a ghost function as the summary for the function continuousinterest(uint256 p, uint256 r, uint256 t) => ghostinterest(p, r, t)| |---|---| |// define the ghost function ghost ghostinterest(uint256,uint256,uint256) {|// add an axiom describing monotonicity of ghostinterest axiom forall uint256 p. forall uint256 r."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "methods", "id": "ca9becd4e794-2", "chunk-uid": "ca9becd4e794", "chunk-page-index": 2, "text": "forall uint256 t1. forall uint256 t2. t2 >= t1 => ghostinterest(p,r,t2) >= ghostinterest(p,r,t1); }| |rule yieldmonotonic(address a, uint256 n) {|// internally, when this call continuousinterest, the function will // be summarized as ghost_interest uint256 y1 = balance(a); require n >= 0; advanceDays(n); // internally, when this call continuousinterest, the function will // be summarized as ghostinterest uint256 y2 = balance(a); assert y2 >= y1; }| By summarizing continuous_interest as a function who is monotonic with its last argument (time) we are able to prove the property. --- ## More Expressive Summaries Ghost Summaries What we refer to as ghost functions are simply uninterpreted functions. Because these can be axiomatized, they can be used to express any number of approximating semantics (rather than summarizing a function as simply a constant). For example, say we wanted to give some approximation for a multiplication function--this is an example of an operation that is very difficult for an SMT solver. Perhaps we only care about the monotonicity of this multiplication function. We may do something like the following: cvl ghost ghost_multiplication(uint256,uint256) returns uint256 axiom forall uint256 x1. forall uint256 x2. forall uint256 y. x1 > x2 => ghost_multiplication(x1, y) > ghost_multiplication(x2, y); axiom forall uint256 x. forall uint256 y1. forall uint256 y2. y1 > y2 => ghost_multiplication(x, y1) > ghost_multiplication(x, y2); Then we can summarize our multiplication function: cvl mepods { mul(uint256 x, uint256 y) => ghost_multiplication(x, y); } You may pass whichever parameters from the summarized function as arguments to the summary in whichever order you want. However you may not put an expression as an argument to the summary. CVL Function Summaries CVL Functions provide standard encapsulation of code within a spec file and allow for control flow, local variables etc. (but not loops). A subset of these are allowed as summaries, namely: 1. They do not contain methods as parameters 2. They do not contain calls to contract functions For example, say we want to summarize a multiplication function again, but this time we want to cut down the search space for the solver a bit. We might try something like the following: cvl function easier_multiplication(uint256 x, uint256 y) returns uint256 require(x < 1000 || y < 1000); return to_uint256(x * y); And just as above we summarize the multiplication function in the methods block: cvl mepods { mul(uint256 x, uint256 y) => easier_multiplication(x, y); } Note this specific summarization is very dangerous and may cause vacuity bugs. In simple cases, these summaries may be used to replace harnesses, though the fact that they cannot call contract functions limits the types of harnesses that may be written. Method declarations (summaries-sec) Summarizing Solidity Functions Calls inside the code --- ## Internal Function Summaries |Summary|Return value|Return code|Current contract state|Other contracts states|Balances| |---|---|---|---|---|---| |HAVOC_ALL|*|*|*|*|*| |HAVOC_ECF|*|*|Unchanged|*|contract's balance that may increase| |ALWAYS(n)|n|success (1)|Unchanged|Unchanged|Unchanged| |CONSTANT|Some constant x|success (1)|Unchanged|Unchanged|Unchanged| |PER_CALLEE_CONSTANT|constant x_c|success (1)|Unchanged|Unchanged|Unchanged| |DISPATCHER[(bool)]|See below|signature|See below|See below|See below| |NONDET|*|success(1)|Unchanged|Unchanged|up to current transfer| |AUTO|*|*|Depends on call type*|Depends on call type*|Depends on call type*| ## Allowed Summaries Not all summaries make sense in the context of an internal function. Only the following summaries are allowed: ALWAYS(X) the summary always returns X and has no side-effects CONSTANT the summary always returns the same constant and has no side effects NONDET the summary returns a havoced value Ghost the summary returns the value return by the given ghost function with the given arguments ## Example Consider the following toy contract where accounts earn continuously compounding interest. Balances are stored as \"day 0 principal\" and current balances are calculated from that principal using the function continuous_interest which implements the standard continuous interest formula. ```solidity contract Interest { uint256 days; uint256 interest; mapping(address => uint256) principals; // decimals 18 public uint256 constant e = 2718300000000000000; --- ## function balance(address account) public view returns (uint256) { return continuous_interest(principals[account], interest, days); } ## function advanceDays(uint256 n) public { days = days + n; } ## function continuous_interest(uint256 p, uint256 r, uint256 t) internal pure returns (uint256) { return p * e ** (r * t); } } Now suppose we would like to prove that this balance calculation is monotonic with respect to time (as days go by, balance never decreases). The following spec would demonstrate this property. cvl rule yield_monotonic(address a, uint256 n) { uint256 y1 = balance(a); require n >= 0; advanceDays(n); uint256 y2 = balance(a); assert y2 >= y1; } Unfortunately, the function continuous_interest includes some arithmetic that is very difficult for the underlying SMT solver to reason about and two things may happen. 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "methods", "id": "ca9becd4e794-3", "chunk-uid": "ca9becd4e794", "chunk-page-index": 3, "text": "The resulting formula may be cause the underlying SMT formula to time out which will result in an unknown result 2. The Prover will use \"overapproximations\" of the arithmetic operations in the resulting formula. Basically this means that we let allows some weird and unexpected behavior which includes the behavior of the function, but also includes more behavior. Basically, this means that a counterexample may not be a real counterexample (i.e. not actually possible program behavior). To understand this better see our section on overapproximation. It turns out that in this case, we run into problem (2) where the tool reports a violation which doesn't actually make sense. This is where function summarization becomes useful, since we get to decide how we would like to overapproximate our function! Suppose we would like to prove that, assuming the equation we use to calculate continuously compounding interest is monotonic, then it is also the case that the value of our principal is monotonically increasing over time. In this case we do the following: ## cvl methods { // tell the tool to use a ghost function as the summary for the function continuousinterest(uint256 p, uint256 r, uint256 t) => ghostinterest(p, r, t) } // define the ghost function ghost ghostinterest(uint256,uint256,uint256) { // add an axiom describing monotonicity of ghostinterest axiom forall uint256 p. forall uint256 r. forall uint256 t1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "methods", "id": "ca9becd4e794-4", "chunk-uid": "ca9becd4e794", "chunk-page-index": 4, "text": "forall uint256 t2. t2 >= t1 => ghostinterest(p,r,t2) >= ghostinterest(p,r,t1); } rule yieldmonotonic(address a, uint256 n) { // internally, when this call continuousinterest, the function will // be summarized as ghost_interest uint256 y1 = balance(a); require n >= 0; advanceDays(n); // internally, when this call continuousinterest, the function will // be summarized as ghostinterest uint256 y2 = balance(a); assert y2 >= y1; } By summarizing continuous_interest as a function who is monotonic with its last argument (time) we are able to prove the property. More Expressive Summaries Ghost Summaries What we refer to as ghost functions are simply uninterpreted functions. Because these can be axiomatized, they can be used to express any number of approximating semantics (rather than summarizing a function as simply a constant). For example, say we wanted to give some approximation for a multiplication function--this is an example of an operation that is very difficult for an SMT solver. Perhaps we only care about the monotonicity of this multiplication function. We may do something like the following: --- cvl ghost ghost_multiplication(uint256,uint256) returns uint256 { axiom forall uint256 x1. forall uint256 x2. forall uint256 y. x1 > x2 => ghost_multiplication(x1, y) > ghost_multiplication(x2, y); axiom forall uint256 x. forall uint256 y1. forall uint256 y2. y1 > y2 => ghost_multiplication(x, y1) > ghost_multiplication(x, y2); } Then we can summarize our multiplication function: cvl methods { mul(uint256 x, uint256 y) => ghost_multiplication(x, y); } You may pass whichever parameters from the summarized function as arguments to the summary in whichever order you want. However you may not put an expression as an argument to the summary. CVL Function Summaries CVL Functions provide standard encapsulation of code within a spec file and allow for control flow, local variables etc. (but not loops). A subset of these are allowed as summaries, namely: 1. They do not contain methods as parameters 2. They do not contain calls to contract functions For example, say we want to summarize a multiplication function again, but this time we want to cut down the search space for the solver a bit. We might try something like the following: cvl function easier_multiplication(uint256 x, uint256 y) returns uint256 { require(x < 1000 || y < 1000); return to_uint256(x * y); } and just as above we summarize the multiplication function in the methods block: cvl methods { mul(uint256 x, uint256 y) => easier_multiplication(x, y); } Note this specific summarization is very dangerous and may cause vacuity bugs. In simple cases, these summaries may be used to replace harnesses, though the fact that they cannot call contract functions limits the types of harnesses that may be written."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-0", "chunk-uid": "d108306050ef", "chunk-page-index": 0, "text": "## Rules Rules (along with invariants) are the main entry points for the Prover. A rule defines a sequence of commands that should be simulated during verification. When the Prover is invoked with the --verify option, it generates a report for each rule and invariant present in the spec file (as well as any imported rules). See /docs/confluence/bank/index for an example demonstrating some of these features. ### Syntax The syntax for rules is given by the following EBNF grammar: rule ::= [ \"rule\" ] id [ \"(\" [ params ] \")\" ] [ \"filtered\" \"{\" id \"->\" expression { \",\" id \"->\" expression } \"}\" ] [ \"description\" string ] [ \"good_description\" string ] block params ::= cvltype [ id ] { \",\" cvltype [ id ] } See basics for the id and string productions; see expr for the expression production; see types for the cvl_type production. ## Overview A rule defines a sequence of commands that should be simulated during verification. These commands may be non-deterministic: they may contain unassigned variables whose value is not specified. The state of storage at the beginning of a rule is also unspecified. Rules may also be declared with a set of parameters; these parameters are treated the same way as undeclared variables. In principal, the Prover will generate every possible combination of values for the undefined variables, and simulate the commands in the rule using those values. A particular combination of values is referred to as an example or a model. There are often an infinite number of models for a given rule; see verification for a brief explanation of how the Prover considers all of them. If a rule contains a require statement that fails on a particular example, the example is ignored. Of the remaining examples, the Prover checks that all of the assert statements evaluate to true. If all of the assert statements evaluate to true on every example, the rule passes. Otherwise, the Prover will output a specific counterexample that causes the assertions to fail. simple rule example cvl ///deposit` must increase the pool's underlying asset balance rule integrityOfDeposit mathint balance_before = underlyingBalance(); env e; uint256 amount; safeAssumptions(_, e); --- deposit(e, amount); mathint balance_after = underlyingBalance(); assert balance_after == balance_before + amount, \"deposit must increase the underlying balance of the pool\"; {caution} assert statements in contract code are handled differently from assert statements in rules. An assert statement in Solidity causes the transaction to revert, in the same way that a require statement in Solidity would."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-1", "chunk-uid": "d108306050ef", "chunk-page-index": 1, "text": "By default, examples that cause contract functions to revert are {ref}ignored by the prover <with-revert>, and these examples will not be reported as counterexamples. The {ref}--multi_assert_check option causes assertions in the contract code to be reported as counterexamples. (parametric-rules)= Parametric rules Rules that contain undefined method variables are sometimes called {term}parametric rules."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-2", "chunk-uid": "d108306050ef", "chunk-page-index": 2, "text": "See {ref}method-type for more details about how to use method variables. Undefined variables of the method type are treated slightly differently from undefined variables of other types. If a rule uses one or more undefined method variables, the Prover will generate a separate report for each method (or combination of methods). In particular, the Prover will generate a separate counterexample for each method that violates the rule, and will indicate if some contract methods always satisfy the rule. You can request that the Prover only run with specific methods using the {ref}--method and {ref}--parametric_contracts command line arguments. The set of methods can also be restricted using {ref}rule filters <rule-filters>. The Prover will automatically skip any methods that have {ref}`DELETE` summaries <delete-summary>. If you wish to only invoke methods on a certain contract, you can call the method variable with an explicit receiver contract. The receiver must be a contract variable (either {ref}currentContract <currentContract> or a variable introduced with a using statement). For example, the following will only verify the rule r on methods of the contract example: cvl using Example as example; rule r { mepod f; env e; calldataarg args; example.f(e,args); ... } It is an error to call the same method variable on two different contracts. cvl rule sanity(method f) { env e; calldataarg args; f(e,args); assert false; } - parameteric rule example (rule-filters)= Filters A rule declaration may have a filtered block after the rule parameters. Rule filters allow you to prevent verification of parametric rules on certain methods. This can be less computationally expensive than using a require statement to ignore counterexamples for a method. The filtered block consists of zero or more filters of the form var -&gt; expr. var must match one of the method parameters to the rule, and expr must be a boolean expression that may refer to the variable var. The filter expression may not refer to other method parameters or any variables defined in the rule. --- Before verifying that a method m satisfies a parametric rule, the expr is evaluated with var bound to a method object. This allows expr to refer to the fields of var, such as var.selector and var.isView. See {ref}method-type for a list of the fields available on method objects. For example, the following rule has two filters. The rule will only be verified with f instantiated by a view method, and g instantiated by a method other than exampleMethod(uint,uint) or otherExample(address): | filters example | | --- | | cvl rule r(method f, method g) filtered { f -> f.isView, g -> g.selector != exampleMethod(uint,uint).selector && g.selector != otherExample(address).selector } { // rule body ... } | | --- | See {ref}method-type for a list of the fields of the method type."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-3", "chunk-uid": "d108306050ef", "chunk-page-index": 3, "text": "Multiple assertions Rules may contain multiple assertions. By default, if any assertion fails, the Prover will report that the entire rule failed and give a counterexample that causes one of the assertions to fail. Occasionally it is useful to consider different assert statements in a rule separately. With the {ref}--multi_assert_check option, the Prover will try to generate separate counterexamples for each assert statement. The counterexamples generated for a particular assert statement will pass all earlier assert statements. Rule descriptions Rules may be annotated by writing description and/or good_description before the method body, followed by a string. These strings are displayed in the verification report. (verification)= How rules are verified While verifying a rule, the Prover does not actually enumerate every possible example and run the rule on the example. Instead, the Prover translates the contract code and the rule into a logical formula with logical variables representing the unspecified variables from the rule. The logical formula is designed so that if a particular example satisfies the requirements and also causes an assertion to fail, then the formula will evaluate to true on that example; otherwise the formula will evaluate to false. The Prover then uses off-the-shelf software called an SMT solver to determine whether there are any examples that cause the formula to evaluate to true. If there are, the SMT solver provides an example to the Prover, which then translates it into an example for the user. If the SMT solver reports that the formula is unsatisfiable, then we are guaranteed that whenever the require statements are true, the assert statements are also true. (rules-main)= Rules Rules (along with {doc}invariants) are the main entry points for the Prover. A rule defines a sequence of commands that should be simulated during verification. When the Prover is invoked with the {ref}--verify option, it generates a report for each rule and invariant present in the spec file (as well as any {ref}imported rules <use>). See {doc}/docs/confluence/bank/index for an example demonstrating some of these features. --- ## Syntax The syntax for rules is given by the following EBNF grammar: rule ::= [ \"rule\" ] id [ \"(\" [ params ] \")\" ] [ \"filtered\" \"{\" id \"->\" expression { \",\" id \"->\" expression } \"}\" ] [ \"description\" string ] [ \"good_description\" string ] block params ::= cvltype [ id ] { \",\" cvltype [ id ] } See {doc}basics for the id and string productions; see {doc}expr for the expression production; see {doc}types for the cvl_type production. ## Overview A rule defines a sequence of commands that should be simulated during verification. These commands may be non-deterministic: they may contain unassigned variables whose value is not specified. The state of storage at the beginning of a rule is also unspecified. Rules may also be declared with a set of parameters; these parameters are treated the same way as undeclared variables. In principal, the Prover will generate every possible combination of values for the undefined variables, and simulate the commands in the rule using those values. A particular combination of values is referred to as an example or a model. There are often an infinite number of models for a given rule; see verification for a brief explanation of how the Prover considers all of them. If a rule contains a require statement that fails on a particular example, the example is ignored. Of the remaining examples, the Prover checks that all of the assert statements evaluate to true. If all of the assert statements evaluate to true on every example, the rule passes. Otherwise, the Prover will output a specific counterexample that causes the assertions to fail. simple rule example cvl ///deposit` must increase the pool's underlying asset balance rule integrityOfDeposit { mathint balance_before = underlyingBalance(); env e; uint256 amount; safeAssumptions(_, e); deposit(e, amount); mathint balance_after = underlyingBalance(); assert balance_after == balance_before + amount, \"deposit must increase the underlying balance of the pool\"; } Caution: assert statements in contract code are handled differently from assert statements in rules. An assert statement in Solidity causes the transaction to revert, in the same way that a require statement in Solidity would."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-4", "chunk-uid": "d108306050ef", "chunk-page-index": 4, "text": "By default, examples that cause contract functions to revert are ignored by the prover, and these examples will not be reported as counterexamples. The --multi_assert_check option causes assertions in the contract code to be reported as counterexamples. --- ## Parametric rules Rules that contain undefined method variables are sometimes called parametric rules."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-5", "chunk-uid": "d108306050ef", "chunk-page-index": 5, "text": "See method-type for more details about how to use method variables. Undefined variables of the method type are treated slightly differently from undefined variables of other types. If a rule uses one or more undefined method variables, the Prover will generate a separate report for each method (or combination of methods). In particular, the Prover will generate a separate counterexample for each method that violates the rule, and will indicate if some contract methods always satisfy the rule. You can request that the Prover only run with specific methods using the --method and --parametric_contracts command line arguments. The set of methods can also be restricted using rule filters. The Prover will automatically skip any methods that have DELETE summaries. If you wish to only invoke methods on a certain contract, you can call the method variable with an explicit receiver contract. The receiver must be a contract variable (either currentContract or a variable introduced with a using statement). For example, the following will only verify the rule r on methods of the contract example: cvl using Example as example; rule r { method f; env e; calldataarg args; example.f(e,args); ... } It is an error to call the same method variable on two different contracts. cvl rule sanity(method f) { env e; calldataarg args; f(e,args); assert false; } - parameteric rule example ## Filters A rule declaration may have a filtered block after the rule parameters. Rule filters allow you to prevent verification of parametric rules on certain methods. This can be less computationally expensive than using a require statement to ignore counterexamples for a method. The filtered block consists of zero or more filters of the form var -&gt; expr. var must match one of the method parameters to the rule, and expr must be a boolean expression that may refer to the variable var. The filter expression may not refer to other method parameters or any variables defined in the rule. Before verifying that a method m satisfies a parametric rule, the expr is evaluated with var bound to a method object. This allows expr to refer to the fields of var, such as var.selector and var.isView. See method-type for a list of the fields available on method objects."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "rules", "id": "d108306050ef-6", "chunk-uid": "d108306050ef", "chunk-page-index": 6, "text": "For example, the following rule has two filters. The rule will only be verified with f instantiated by a view method, and g instantiated by a method other than exampleMethod(uint,uint) or otherExample(address): filters example cvl rule r(method f, method g) filtered { f -&gt; f.isView, g -&gt; g.selector != exampleMethod(uint,uint).selector &amp;&amp; g.selector != otherExample(address).selector } { // rule body ... } See method-type for a list of the fields of the method type. --- ## Multiple assertions Rules may contain multiple assertions. By default, if any assertion fails, the Prover will report that the entire rule failed and give a counterexample that causes one of the assertions to fail. Occasionally it is useful to consider different assert statements in a rule separately. With the --multi_assert_check option, the Prover will try to generate separate counterexamples for each assert statement. The counterexamples generated for a particular assert statement will pass all earlier assert statements. ## Rule descriptions Rules may be annotated by writing description and/or good_description before the method body, followed by a string. These strings are displayed in the verification report. (verification)= ## How rules are verified While verifying a rule, the Prover does not actually enumerate every possible example and run the rule on the example. Instead, the Prover translates the contract code and the rule into a logical formula with logical variables representing the unspecified variables from the rule. The logical formula is designed so that if a particular example satisfies the requirements and also causes an assertion to fail, then the formula will evaluate to true on that example; otherwise the formula will evaluate to false. The Prover then uses off-the-shelf software called an SMT solver to determine whether there are any examples that cause the formula to evaluate to true. If there are, the SMT solver provides an example to the Prover, which then translates it into an example for the user. If the SMT solver reports that the formula is unsatisfiable, then we are guaranteed that whenever the require statements are true, the assert statements are also true."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-0", "chunk-uid": "4384cbd08138", "chunk-page-index": 0, "text": "## Quantifier Grounding Quantified expressions <quantifier> are a very powerful tool for writing specifications, but they can also lead to incredibly long running times. For this reason, the Prover uses an approximation called \"grounding\". It is not possible to ground every expression perfectly. While grounding is sound (i.e. it will not allow a rule to be verified if it is not true), there are cases where it may generate counterexamples even for rules that should pass. For example, a counterexample may not obey a require statement that contains a quantifier. You can prevent spurious counterexamples by turning off grounding (by passing -smt_groundQuantifiers), but without grounding the Prover may run considerably slower, and is likely to time out. The remainder of this document explains grounding in more detail, and lists the specific kinds of quantified expressions that may lead to spurious counterexamples. We also include some suggestions for rewriting your quantified statements to avoid spurious counterexamples. ## How grounding works Quantifier grounding transforms a quantified <quantifier> statement into a series of non-quantified statements. For example, suppose a specification contains the following ghost axiom <ghost-axioms>: cvl ghost f(uint x) returns (mathint) { init_state axiom forall uint x . f(x) == 0 } This statement logically says that f(0) == 0 and f(1) == 1 and f(2) == 0 and so on."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-1", "chunk-uid": "4384cbd08138", "chunk-page-index": 1, "text": "In practice, however, the verification may only make use of a small finite number of these facts. Grounding is the process of automatically replacing the forall statement with the specific unquantified statements that are necessary. For example, if the program and specification only ever access f(2), f(9), f(y+3), and f(z), then the axiom above would be automatically replaced with: cvl ghost f(uint x) returns (mathint) { init_state axiom f(2) == 0; init_state axiom f(9) == 0; init_state axiom f(y+3) == 0; init_state axiom f(z) == 0; } The Prover will also ground more complex quantified expressions, and will ground them anywhere that you can write a quantified statement (e.g. assert and require statements, ghost axioms, and invariants). Grounding also works with exists quantifiers. ## Limitations on grounding In some cases, there is an easy way to rewrite your expression with fewer quantifiers. For example, the following quantified statement requires that f(x) is always odd, but it is written in a way that violates one of the restrictions on quantifiers: cvl require forall uint x . forall mathint y . f(x) != 2 * y; However, there is a much simpler way to require that f(x) is odd by using %: cvl require forall uint x . f(x) % 2 == 1; This rewritten statement obeys the rules listed below, and therefore will not produce any spurious counterexamples. --- The remainder of this section describes specific cases where the Prover cannot ground quantified statements, and gives advice on how to work around those limitations. Alternating Quantifiers Alternating quantifiers (those containing forall followed by exist or vice-versa) complicate the process of grounding, so there are limitations to what statements you can write and which of them are grounded. In most contexts, you may not have a forall expression contained inside of an exists statement. For example, this is allowed: cvl assert forall address x . forall uint y ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-2", "chunk-uid": "4384cbd08138", "chunk-page-index": 2, "text": "exists uint z . exists uint w . e(x,y,z,w); but this is disallowed: cvl assert forall address x . exists address y . exists address z . forall address w . e(x,y,z,w); In the latter case, the forall address w is contained inside the exists address z. Logical negations and require statements reverse the rules for forall and exists statements: in those contexts, you cannot nest an exists expression inside of a forall statement. Including another negation will again reverse the rules. For example, the following are allowed: cvl require exists address x . forall uint y . e(x,y); assert !(exists address x . forall uint y . e(x,y)); require !(forall address x . exists uint y . e(x,y)); assert !(!(forall address x . exists uint y . e(x,y)); but these are disallowed: cvl require forall address x . exists uint y . e(x,y); assert !(forall address x . exists uint y . e(x,y)); One common way to work around these limitations is by replacing exists expressions with concrete expressions that produce the values that should exist. For example, suppose your contract function always returned twice its input: solidity function f(uint x) external returns(uint) { return 2 * x; } You might like to prove that if x is positive, then it's possible for f to output something smaller than f(x): cvl assert forall uint x . (x > 0) => (exists uint y ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-3", "chunk-uid": "4384cbd08138", "chunk-page-index": 3, "text": "f(y) < f(x)); This is clearly true; for example f(x - 1) is always smaller than f(x), as is f(0). However, to work around the nested quantifier restriction, we have to help the Prover find the correct value for y. We could replace this statement with either of the following two: cvl assert forall uint x . (x > 0) => f(0) < f(x); cvl assert forall uint x . (x > 0) => f(x-1) < f(x); Recursion Quantified statements that relate a function with itself on two different inputs may give incorrect counterexamples. For example, the following forall statement refers to f twice: rule recursiveQuantifier { require forall uint x . f(x) > f(x-1); assert f(8) > f(6); } --- Although we can see that the assertion must be true, we would need to combine the statements f(8) > f(7) and f(7) > f(6) to prove it, and the grounding mechanism is unable to do this. In these cases, you may see a counterexample that doesn't satisfy the require statement; in this case the best option is to disable grounding with {ref}-smt_groundQuantifiers. (grounding-arguments)= Variables must be arguments In order for grounding to work, every variable appearing in a quantified statement must be used at least once as an argument to a ghost or contract function. For example, neither of the following examples are allowed: cvl require forall mathint x ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-4", "chunk-uid": "4384cbd08138", "chunk-page-index": 4, "text": "x * 2 != y; require forall uint x . forall mathint y . f(x) != 2 * y; In the first example, x is not used as an argument to a function, while in the second case, y is not. Although you are allowed to call functions on complicated expressions that use quantified variables, doing so may produce spurious counterexamples. For example, the following is allowed, but is likely to produce spurious counterexamples (because x itself is not an argument to a function): cvl require forall uint x . f(2 * x) == 0; This particular example requires that all even inputs to f produce 0 as output; it could be rewritten as follows: cvl require forall uint y . (y % 2 == 0) => f(y); If you use a quantified variable in an argument to two different functions, you may produce spurious counterexamples. For example: cvl require forall uint x . f(x) <= g(x+1) && g(x+1) != 0; Here, x + 1 is used as an argument to g, but x is not; you may get counterexamples where g(x+1) == 0 for some x. In that case, you can add an additional equivalent require that does use the quantified variable as an argument to g: cvl require forall uint x . f(x) < g(x+1) && g(x+1) != 0; require forall uint x ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-5", "chunk-uid": "4384cbd08138", "chunk-page-index": 5, "text": "f(x-1) < g(x) && g(x) != 0; This will make x a direct argument to g, so the expression will be grounded properly. (grounding-polarity)= Double Polarity The polarity of a sub-formula is the direction of the effect it has on the output of the formula. This is best demonstrated through an example: cvl a && (b || !c) In this example, b possesses a positive polarity because changing b from false to true can't make the formula false if it wasn't before. Informally, making b \"more true\" can only make the whole formula \"more true\". In this example, a also possesses positive polarity: if the formula was true when a was false, it must also be true when a is true. On the other hand, c has a negative polarity because changing c from true to false can only make the statement \"more false\". If can't become true if it wasn't true before. Sub-expressions can also have double polarity. For example, consider the formula a <=> b In this example, a has double polarity, because making a true could cause the formula to become false when it was true before, but it could also cause the --- ## Quantifier Grounding Quantified expressions are a very powerful tool for writing specifications, but they can also lead to incredibly long running times. For this reason, the Prover uses an approximation called \"grounding\"."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-6", "chunk-uid": "4384cbd08138", "chunk-page-index": 6, "text": "It is not possible to ground every expression perfectly. While grounding is sound (i.e. it will not allow a rule to be verified if it is not true), there are cases where it may generate counterexamples even for rules that should pass. For example, a counterexample may not obey a require statement that contains a quantifier. You can prevent spurious counterexamples by turning off grounding (by passing -smt_groundQuantifiers), but without grounding the Prover may run considerably slower, and is likely to time out. The remainder of this document explains grounding in more detail, and lists the specific kinds of quantified expressions that may lead to spurious counterexamples. We also include some suggestions for rewriting your quantified statements to avoid spurious counterexamples. ## How grounding works Quantifier grounding transforms a quantified statement into a series of non-quantified statements. For example, suppose a specification contains the following ghost axiom: cvl ghost f(uint x) returns (mathint) { init_state axiom forall uint x . f(x) == 0 } This statement logically says that f(0) == 0 and f(1) == 1 and f(2) == 0 and so on."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-7", "chunk-uid": "4384cbd08138", "chunk-page-index": 7, "text": "In practice, however, the verification may only make use of a small finite number of these facts. Grounding is the process of automatically replacing the forall statement with the specific unquantified statements that are necessary. For example, if the program and specification only ever access f(2), f(9), f(y+3), and f(z), then the axiom above would be automatically replaced with: cvl ghost f(uint x) returns (mathint) { init_state axiom f(2) == 0; init_state axiom f(9) == 0; init_state axiom f(y+3) == 0; init_state axiom f(z) == 0; } The Prover will also ground more complex quantified expressions, and will ground them anywhere that you can write a quantified statement (e.g. assert and require statements, ghost axioms, and invariants). Grounding also works with exists quantifiers. --- Limitations on grounding In some cases, there is an easy way to rewrite your expression with fewer quantifiers. For example, the following quantified statement requires that f(x) is always odd, but it is written in a way that violates one of the restrictions on quantifiers grounding-arguments: cvl require forall uint x . forall mathint y . f(x) != 2 * y; However, there is a much simpler way to require that f(x) is odd by using %: cvl require forall uint x . f(x) % 2 == 1; This rewritten statement obeys the rules listed below, and therefore will not produce any spurious counterexamples. The remainder of this section describes specific cases where the Prover cannot ground quantified statements, and gives advice on how to work around those limitations. Alternating Quantifiers Alternating quantifiers (those containing forall followed by exist or vice-versa) complicate the process of grounding, so there are limitations to what statements you can write and which of them are grounded. In most contexts, you may not have a forall expression contained inside of an exists statement. For example, this is allowed: cvl assert forall address x . forall uint y ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-8", "chunk-uid": "4384cbd08138", "chunk-page-index": 8, "text": "exists uint z . exists uint w . e(x,y,z,w); but this is disallowed: cvl assert forall address x . exists address y . exists address z . forall address w . e(x,y,z,w); In the latter case, the forall address w is contained inside the exists address z. Logical negations and require statements reverse the rules for forall and exists statements: in those contexts, you cannot nest an exists expression inside of a forall statement. Including another negation will again reverse the rules. For example, the following are allowed: cvl require exists address x . forall uint y . e(x,y); assert !(exists address x . forall uint y . e(x,y)); require !(forall address x . exists uint y . e(x,y)); assert !(!(forall address x . exists uint y . e(x,y))); but these are disallowed: cvl require forall address x . exists uint y . e(x,y); assert !(forall address x . exists uint y . e(x,y)); One common way to work around these limitations is by replacing exists expressions with concrete expressions that produce the values that should exist. For example, suppose your contract function always returned twice its input: solidity function f(uint x) external returns(uint) { return 2 * x; } You might like to prove that if x is positive, then it's possible for f to output something smaller than f(x): cvl assert forall uint x . (x > 0) => (exists uint y ."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "grounding", "id": "4384cbd08138-9", "chunk-uid": "4384cbd08138", "chunk-page-index": 9, "text": "f(y) < f(x)); --- ## This is clearly true; for example f(x - 1) is always smaller than f(x), as is f(0). However, to work around the nested quantifier restriction, we have to help the Prover find the correct value for y. We could replace this statement with either of the following two: cvl assert forall uint x . (x > 0) => f(0) < f(x); assert forall uint x . (x > 0) => f(x-1) < f(x); ### Recursion Quantified statements that relate a function with itself on two different inputs may give incorrect counterexamples. For example, the following forall statement refers to f twice: rule recursiveQuantifier { require forall uint x . f(x) > f(x-1); assert f(8) > f(6); } Although we can see that the assertion must be true, we would need to combine the statements f(8) > f(7) and f(7) > f(6) to prove it, and the grounding mechanism is unable to do this. In these cases, you may see a counterexample that doesn't satisfy the require statement; in this case the best option is to disable grounding with {ref}-smt_groundQuantifiers. ### Variables must be arguments In order for grounding to work, every variable appearing in a quantified statement must be used at least once as an argument to a ghost or contract function. For example, neither of the following examples are allowed: cvl require forall mapint x . x * 2 != y; require forall uint x . forall mapint y . f(x) != 2 * y; Although you are allowed to call functions on complicated expressions that use quantified variables, doing so may produce spurious counterexamples. For example, the following is allowed, but is likely to produce spurious counterexamples (because x itself is not an argument to a function): cvl require forall uint x . f(2 * x) == 0; This particular example requires that all even inputs to f produce 0 as output; it could be rewritten as follows: cvl require forall uint y . (y % 2 == 0) => f(y); If you use a quantified variable in an argument to two different functions, you may produce spurious counterexamples. For example: cvl require forall uint x . f(x) <= g(x+1) && g(x+1) != 0; Here, x + 1 is used as an argument to g, but x is not; you may get counterexamples where g(x+1) == 0 for some x. In that case, you can add an additional equivalent require that does use the quantified variable as an argument to g: cvl require forall uint x . f(x) < g(x+1) && g(x+1) != 0; require forall uint x . f(x-1) < g(x) && g(x) != 0; This will make x a direct argument to g, so the expression will be grounded properly. ### Double Polarity --- The polarity of a sub-formula is the direction of the effect it has on the output of the formula. This is best demonstrated through an example: In this example, b possesses a positive polarity because changing b from false to true can't make the formula false if it wasn't before. Informally, making b \"more true\" can only make the whole formula \"more true\". In this example, a also possesses positive polarity: if the formula was true when a was false, it must also be true when a is true. On the other hand, c has a negative polarity because changing c from true to false can only make the statement \"more false\". It can't become true if it wasn't true before. Sub-expressions can also have double polarity. For example, consider the formula a <=> b In this example, a has double polarity, because making a true could cause the formula to become false when it was true before, but it could also cause the formula to become true when it wasn't before. Grounding is disallowed when the quantified expression has double polarity in the rule. For example, the following is disallowed, because the forall statement has double polarity. cvl rule r { ... assert (forall uint x . f(x) > 0) <=> y; } In many cases you can split a rule with a quantifier in a double-polarity position into multiple rules with single-polarity quantifiers. For example, the above assertion could be split into two rules: cvl rule r1 { ... assert (forall uint x . f(x) > 0) => y; } rule r2 { ... assert y => (forall uint x . f(x) > 0); } Verifying r1 and r2 is logically equivalent to verifying r, but the quantified expression appears with single polarity in each of the two rules."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-0", "chunk-uid": "16758c0229b0", "chunk-page-index": 0, "text": "## Using Gambit with the Prover The mutation verifier checks that variants of the original Solidity program do not pass verification against a given specification. You can either use random mutations generated by Gambit or manually crafted with a specific error. If a mutated program passes the specification, it may indicate that the specification is vacuous or not rigorous enough. ## Installation To use the mutation verifier, first install the Certora Prover and its dependencies. To install it, run: sh pip install certora-cli If you already have certora-cli installed and the certoraMutate command is not available, you may need to update to a newer version by running: sh pip install --upgrade certora-cli Note: If you are on Linux, you will need pip version 20.3 or above. ## Running the Mutation Verifier You need to extend your Prover configuration file by adding a mutation object. The mutation verification script is called certoraMutate. Run it from the command line just like certoraRun: sh certoraMutate path/to/prover.conf If you do, the script will generate code mutants, then submit a verification job per mutant to Certora's server. Submitting the verification jobs of the mutants may take several minutes. When it finishes successfully, you should see the following lines printed: ```text ** PROVER END ** You will receive an email notification when this mutation test is completed. It may take several hours. You can follow the test's progress at https://prover.certora.com/mutations. The time required to verify all mutants depends on various factors, such as the number of mutants, the complexity of the contracts, and the complexity of the specifications. In some instances, the entire testing process may take several hours. You can follow the test's progress in the mutations dashboard. The results will be available in the dashboard when they are ready. Once the test is completed, you should receive an email that looks like this: Mutation Configuration The mutation tester script requires a Prover JSON .conf configuration file that includes a mutations key. Within this key, an object is defined to specify the behavior of mutation testing. Notably, all other settings, including those influencing compilation or verification, remain consistent with those defined outside the mutations object. --- ## For example, see the file default.conf from the CertoraInit repository: json { \"files\": [ \"contracts/ERC20.sol\" ], \"verify\": \"ERC20:certora/spec/ERC20.spec\", \"msg\": \"ERC20Rules\", \"mutations\": { \"gambit\": [ { \"filename\" : \"contracts/ERC20.sol\", \"num_mutants\": 5 } ], \"msg\": \"basic mutation configuration\" } } ### Mutation Sources Mutations can either be randomly generated via Gambit, or manually generated by you. ### Randomly generated mutations via Gambit To generate random mutations via Gambit, add a gambit key inside the mutations object. This key should include a list of Gambit mutation objects. All file paths are relative to the current working directory. For example, see the gambit value from the file advanced_mutation.conf of the CertoraInit repository: json \"gambit\": [ { \"filename\": \"contracts/ERC20.sol\", \"num_mutants\": 2, \"mutations\": [ \"require-mutation\" ] }, { \"filename\": \"contracts/ERC20.sol\", \"num_mutants\": 1, \"mutations\": [ \"assignment-mutation\" ] } ] ### Manual mutations You have the option to include manually generated mutated files, not produced by Gambit, in your mutation test. We refer to these as 'manual mutations.' They can be used for regression tests, or to check mutations that Gambit does not currently support. Note: It is recommended to limit each manually mutated file to a single mutation for more accurate coverage analysis and better traceability. To add manual mutations, under mutations create a key manual_mutants containing a list of manual mutation objects. Each manual mutation object must contain two keys: - file_to_mutate: A file path relative to the current working directory of the file we wish to replace with the mutations - mutants_location: A relative path to a directory from the current working directory. This directory contains files that will be tested in place of the mutated file. All .sol files in the directory will undergo testing. For example, see the manual_mutants value from the file advanced_mutation.conf of the CertoraInit repository: json \"manual_mutants\": [ { \"file_to_mutate\": \"contracts/ERC20.sol\", \"mutants_location\": \"mutations\" } ] If you don't have a gambit object in the conf file, certoraMutate will run only on the manual mutants, and no other mutants will be generated. Note: All manual mutations must be named uniquely. For example, if you want to generate manual mutations for `C.sol` and `D.sol`, name them `C.m1.sol, C.m2.sol, D.m3.sol, D.m4.sol, ...` etc. ### Original Verification Run A mutation test requires a verification job that was completed successfully without halting as a basis for comparison, called the original run. All mutant checks will be run with the same verification configuration as the original run, and their results will be compared to the original run. Rules that are not verified or did not pass basic sanity checks on the original run will be ignored. ### Generating the original run --- ## Original verification link You can also provide a link to a run that was already executed. The mutants will run with the same specification and configuration as that run. The files relevant for that run will be downloaded to your local machine. You can provide the original run job's link via --orig_run, for example: sh --orig_run https://prover.certora.com/output/53342/9487899b2afc4709899889fab6c2c673/?anonymousKey=5c365717c9c1076f0c1acb050c7eb5867f07a236 Note: The run must have the job status 'Executed' on the Prover dashboard. ## The Mutations Dashboard You can track your mutation tests at the mutations dashboard. A test that just started would look like this: Mutation test running The Mutation ID is a unique identifier for the test. The Message column includes the description given either in the command line via the --msg flag or the conf file's \"msg\" key. It aids in identifying and documenting mutation tests."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-1", "chunk-uid": "16758c0229b0", "chunk-page-index": 1, "text": "By default, it will show None. The Status column of a test includes two different parts - the status of the test (see below) and a progress counter. The progress counter shows how many of the sent mutant verification jobs have already been executed. ### Mutation test statuses A mutation test can have one of five different statuses: Running indicates pat pe verification jobs of pe mutants are still being computed. Calculating indicates pat all pe verification jobs have finished, and pe results are now being gapered and processed into a verification report. Executed indicates pat all mutant verification jobs were executed correctly and are available in pe report, which can be accessed by clicking on pe Mutation ID. Halted indicates pat pe mutation test reached a global time limit and was stopped. The partial verification results pat were collected before pe time limit are available in pe verification report. This usually happens when too many mutants are used in a single test. --- ## Problem indicates the test had errors. A report is usually not generated. ## Mutation test problem Mutation Test Report The mutation verification results are summarized in a user-friendly visual report. Here is an example summary for the advanced mutation of an ERC20 example. The green outer circles represent the rules, and the gray dots represent the mutants. ### Report of the advanced mutation of CertoraInit Selecting a rule shows which mutants it detected, and selecting a mutant shows which rules caught it. Selecting a rule Clicking on a mutant's patch shows the difference between it and the original program. ### Showing a mutant patch ### Metrics At the top bar of the report there are different coverage metrics. #### Mutation metrics - The Coverage metric is the ratio of the caught mutants to all mutants tested, also shown under Caught Mutations. - The Rules metric shows the ratio of the rules that caught at least one mutation out of all the rules in the tested specification."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-2", "chunk-uid": "16758c0229b0", "chunk-page-index": 2, "text": "- The Solo Rules metric shows the ratio between the rules that caught a unique mutation and all rules that caught at least one mutation. ### CLI Options certoraMutate supports the following options; for a comprehensive list, run certoraMutate --help: |Option|Description| |---|---| |--orig_run|Specify the {ref}link to a previous verification job<orig-verification-link>| |--orig_run_dir|Specify the folder where the files will be downloaded from the {ref}original verification job <orig-verification-link>| |--msg|Add a message to identify the certoraMutate run| |--gambit_only|Stop processing after generating mutations| |--dump_failed_collects|Specify a log file to capture mutant collection failures| |--debug|Show additional logging information during execution| ### Troubleshooting At the moment, there are a few ways in which certoraMutate can fail. Here are some suggestions on how to troubleshoot when that happens."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-3", "chunk-uid": "16758c0229b0", "chunk-page-index": 3, "text": "We are actively working on mitigating them. - There are currently no official Gambit binaries for Linux ARM or Windows. That means that Gambit will not be installed with pip install certora-cli, and must be {ref}built from source <build-gambit-from-source>. - Sometimes, the problem stems from Gambit's mutant generation. Try running with --gambit_only and look at the generated mutations. --- ## Try running the Prover on your mutants individually using certoraRun Usually the mutant setup will be in .certora_internal/applied_mutants_dir and can be retried by running the Prover's .conf file with certoraRun. Manual mutants that don't show up in the report may have had a Solidity compilation error. It is also possible that you are encountering a bug with the underlying version of the Prover."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-4", "chunk-uid": "16758c0229b0", "chunk-page-index": 4, "text": "Check if your packages paths have a trailing /. The packages paths, both sources and targets, should never end with a /. ## Using Gambit with the Prover The mutation verifier checks that variants of the original Solidity program do not pass verification against a given specification. You can either use random mutations generated by Gambit or manually crafted mutants with a specific error. If a mutated program passes the specification, it may indicate that the specification is vacuous or not rigorous enough. ## Installation To use the mutation verifier, first install the Certora Prover and its dependencies. To install it, run: sh pip install certora-cli If you already have certora-cli installed and the certoraMutate command is not available, you may need to update to a newer version by running: sh pip install --upgrade certora-cli Note: If you are on Linux, you will need pip version 20.3 or above. ## Running the Mutation Verifier You need to extend your Prover configuration file by adding a mutation object. The mutation verification script is called certoraMutate. Run it from the command line just like certoraRun: sh certoraMutate path/to/prover.conf If you do, the script will generate code mutants, then submit a verification job per mutant to Certora's server. Submitting the verification jobs of the mutants may take several minutes. When it finishes successfully, you should see the following lines printed: ** PROVER END ** You will receive an email notification when this mutation test is completed. It may take several hours. You can follow the test's progress at https://prover.certora.com/mutations The time required to verify all mutants depends on various factors, such as the number of mutants, the complexity of the contracts, and the complexity of the specifications. In some instances, the entire testing process may take several hours. You can follow the test's progress in the mutations dashboard. The results will be available in the dashboard when they are ready. Once the test is completed, you should receive an email that looks like this: Mutation succeeded email --- ## Mutation Configuration The mutation tester script requires a Prover JSON .conf configuration file that includes a mutations key. Within this key, an object is defined to specify the behavior of mutation testing. Notably, all other settings, including those influencing compilation or verification, remain consistent with those defined outside the mutations object. For example, see the file default.conf from the CertoraInit repository: json { \"files\": [ \"contracts/ERC20.sol\" ], \"verify\": \"ERC20:certora/spec/ERC20.spec\", \"msg\": \"ERC20Rules\", \"mutations\": { \"gambit\": [ { \"filename\" : \"contracts/ERC20.sol\", \"num_mutants\": 5 } ], \"msg\": \"basic mutation configuration\" } } ## Mutation Sources Mutations can either be randomly generated via Gambit, or manually generated by you. ### Randomly generated mutations via Gambit To generate random mutations via Gambit, add a gambit key inside the mutations object. This key should include a list of Gambit mutation objects. All file paths are relative to the current working directory. For example, see the gambit value from the file advanced_mutation.conf of the CertoraInit repository: json \"gambit\": [ { \"filename\": \"contracts/ERC20.sol\", \"num_mutants\": 2, \"mutations\": [ \"require-mutation\" ] }, { \"filename\": \"contracts/ERC20.sol\", \"num_mutants\": 1, \"mutations\": [ \"assignment-mutation\" ] } ] ### Manual mutations You have the option to include manually generated mutated files, not produced by Gambit, in your mutation test. We refer to these as 'manual mutations.' They can be used for regression tests, or to check mutations that Gambit does not currently support. Note: It is recommended to limit each manually mutated file to a single mutation for more accurate coverage analysis and better traceability. To add manual mutations, under mutations create a key manual_mutants containing a list of manual mutation objects. Each manual mutation object must contain two keys: - file_to_mutate: A file path relative to the current working directory of the file we wish to replace with the mutations - mutants_location: A relative path to a directory from the current working directory. This directory contains files that will be tested in place of the mutated file. All .sol files in the directory will undergo testing. For example, see the manual_mutants value from the file advanced_mutation.conf of the CertoraInit repository: json \"manual_mutants\": [ { \"file_to_mutate\": \"contracts/ERC20.sol\", \"mutants_location\": \"mutations\" } ] If you don't have a gambit object in the conf file, certoraMutate will run only on the manual mutants, and no other mutants will be generated. Note: All manual mutations must be named uniquely. For example, if you want to generate manual mutations for `C.sol` and `D.sol`, name them `C.m1.sol, C.m2.sol, D.m3.sol, D.m4.sol, ...` etc. --- ## A mutation test requires a verification job that was completed successfully without halting as a basis for comparison, called the original run. All mutant checks will be run with the same verification configuration as the original run, and their results will be compared to the original run. Rules that are not verified or did not pass basic sanity checks on the original run will be ignored. ## Generating the original run Usually, the original run is sent for verification with the mutants. An unaltered file without mutations is sent for verification before all mutant verification runs. The mutation test will be aborted if the original run fails to compile. Original verification link You can also provide a link to a run that was already executed. The mutants will run with the same specification and configuration as that run. The files relevant for that run will be downloaded to your local machine. You can provide the original run job's link via --orig_run, for example: sh --orig_run https://prover.certora.com/output/53342/9487899b2afc4709899889fab6c2c673/?anonymousKey=5c365717c9c1076f0c1acb050c7eb5867f07a236 Note: The run must have the job status 'Executed' on the Prover dashboard. ## The Mutations Dashboard You can track your mutation tests at the mutations dashboard. A test that just started would look like this: Mutation test running The Mutation ID is a unique identifier for pe test. The Message column includes pe description given eiper in pe command line via pe --msg flag or pe conf file's \"msg\" key. It aids in identifying and documenting mutation tests."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-5", "chunk-uid": "16758c0229b0", "chunk-page-index": 5, "text": "By default, it will show None. The Status column of a test includes two different parts - pe status of pe test (see below) and a progress counter. The progress counter shows how many of pe sent mutant verification jobs have already been executed. Mutation test statuses |Running|indicates that the verification jobs of the mutants are still being computed.| |---|---| |Calculating|indicates that all the verification jobs have finished, and the results are now being gathered and processed into a verification report.| |Executed|indicates that all mutant verification jobs were executed correctly and are available in the report, which can be accessed by clicking on the Mutation ID.| --- ## Mutation test executed Halted indicates that the mutation test reached a global time limit and was stopped. The partial verification results that were collected before the time limit are available in the verification report. This usually happens when too many mutants are used in a single test. ## Mutation test halted Problem indicates the test had errors. A report is usually not generated. ## Mutation test problem Mutation Test Report The mutation verification results are summarized in a user-friendly visual report. Here is an example summary for the advanced mutation of an ERC20 example. The green outer circles represent the rules, and the gray dots represent the mutants. ## Report of the advanced mutation of CertoraInit Selecting a rule shows which mutants it detected, and selecting a mutant shows which rules caught it. Clicking on a mutant's patch shows the difference between it and the original program. ## Metrics At the top bar of the report there are different coverage metrics. The Coverage metric is the ratio of the caught mutants to all mutants tested, also shown under Caught Mutations. The Rules metric shows the ratio of the rules that caught at least one mutation out of all the rules in the tested specification."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-6", "chunk-uid": "16758c0229b0", "chunk-page-index": 6, "text": "The Solo Rules metric shows the ratio between the rules that caught a unique mutation and all rules that caught at least one mutation. ## CLI Options certoraMutate supports the following options; for a comprehensive list, run certoraMutate --help: |Option|Description| |---|---| |--orig_run|Specify the {ref}link to a previous verification job<orig-verification-link>| |--orig_run_dir|Specify the folder where the files will be downloaded from the {ref}original verification job <orig-verification-link>| |--msg|Add a message to identify the certoraMutate run| |--gambit_only|Stop processing after generating mutations| |--dump_failed_collects|Specify a log file to capture mutant collection failures| |--debug|Show additional logging information during execution| ## Troubleshooting --- At the moment, there are a few ways in which certoraMutate can fail. Here are some suggestions on how to troubleshoot when that happens."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-7", "chunk-uid": "16758c0229b0", "chunk-page-index": 7, "text": "We are actively working on mitigating them. There are currently no official Gambit binaries for Linux ARM or Windows. That means that Gambit will not be installed with pip install certora-cli, and must be built from source. Sometimes, the problem stems from Gambit's mutant generation. Try running with --gambit_only and look at the generated mutations. Try running the Prover on your mutants individually using certoraRun. Usually the mutant setup will be in .certora_internal/applied_mutants_dir and can be retried by running the Prover's .conf file with certoraRun. Manual mutants that don't show up in the report may had a Solidity compilation error. It is also possible that you are encountering a bug with the underlying version of the Prover."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation-verifier", "id": "16758c0229b0-8", "chunk-uid": "16758c0229b0", "chunk-page-index": 8, "text": "Check if your packages paths have a trailing /. The packages paths, both sources and targets, should never end with a /."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-0", "chunk-uid": "12a6a556aa91", "chunk-page-index": 0, "text": "## Modeling of Hashing in the Certora Prover In this document we present how the Keccak hash function is modeled in the Certora Prover and how that impacts smart contract verification. ### Introduction The Keccak hash function is used heavily by Solidity smart contracts in an implicit way. Most prominently, all unbounded data structures in storage (arrays, mappings) receive their storage addresses as values of the Keccak function. It is also possible to call the Keccak hash function explicitly, both through a solidity built-in function and through inline assembly. The Certora Prover does not operate with an actual implementation of the Keccak hash function, since this would make most verification intractable and provide no practical benefits. Instead, the Certora Prover models the properties of the Keccak hash function that are crucial for the function of the smart contracts under verification while abstracting away from implementation details of the actual hash function. ### Modeling the Keccak function (bounded case) The Certora Prover models the Keccak hash function as an arbitrary function that is injective with large gaps. The hash function hash being injective with large gaps means that on distinct inputs x and y: - the hashes hash(x) and hash(y) are also distinct - the gap between hash(x) and hash(y) is large enough that every additive term hash(x) + i that occurs in the program is also distinct from hash(y) Furthermore, the initial storage slots and large constants that appear in the code are reserved. This ensures that no hash value ends up colliding with slots 0 to 10000 nor with any constant that is explicitly given in the source code. These constraints are enough for the Solidity storage model to work as expected. However, this modeling allows the Certora Prover to pick hash functions that show different behavior from the actual Keccak function. See the later subsection \"Background: The Solidity Storage Model\" for details on why this property is an adequate model for maintaining the integrity of Solidity's storage operations. ### Examples (Imprecision of Modeling) We illustrate the implications of our modeling decisions using a few examples. Modeling does not account for individual values of the Keccak function The Keccak256-hash of the string hello is 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8. However, due to our modeling, the Certora Prover cannot prove that fact. The rule hashOf17Eq will show as \"violated\" since the Prover can pick a function for Keccak256 that assigns hello differently. For the same reason, the Prover also does not disprove that the hash of 17 is 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8, since we allow it to choose Keccak256 appropriately. // CVL: methods { hash(uint) returns (uint) envfree; } rule hashOf17Eq { assert(hash(\"hello\") == 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8); } --- rule hashOf17Neq { assert(hash(\"hello\") != 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8); } Modeling does not account for ordering Whichever distinct values we chose for x and y in the example below, on the real Keccak function, one rule would be violated and one rule would not. In the modeling of the Certora Prover, both rules are violated, since the Prover is allowed to \"invent\" a hash function for each rule and will choose one that violates the property whenever there is such a function (as long as that function fulfills the \"injectivity with large gaps\" property). definition x() : uint = 12345678 definition y() : uint = 87654321 rule hashXLowerOrEqualToHashY { assert hash(x()) <= hash(y()); } rule hashXLargerThanHashY { assert(hash(x()) > hash(y())); } Constants in code vs hashes A special case in Certora Prover's modeling of hashing is the treatment of constants that appear in the code: The Prover implicitly assumes that the hash function never outputs one of these constants on any of the concrete inputs it gets in that program. // CVL: methods { function readAtSlotAddress() external returns (uint) envfree; function updateMap(uint k, uint v) external envfree; } rule foo { uint v1 = readAtSlotAddress(); uint preImage; uint x; updateMap(preImage, x); uint v2 = readAtSlotAddress(); assert(v1 == v2); // solidity contract C { uint constant slotAddress = 1000000; mapping(uint => uint) map; function updateMap(uint k, uint v) public { } map[k] = v; function readAtSlotAddress() public returns (uint r) { assembly { r := sload(slotAddress) --- The function readAtSlotAddress reads from storage at the slot with the number 1000000. The function updateMap updates a mapping; this means it updates storage at a hash computed from its identifier (here 1, since it is the second field in the contract) and the key k. Now, if k is chosen such that keccak(1, k) equals 1000000, the map update would overwrite that storage slot, and thus the assertion in the rule foo would be violated. However, the Certora Prover will return \"not violated\" for this assertion, since it assumes that no hash ever collides with the constant 1000000, which occurs in the program. On the other hand, if we change the contract to leave slotAddress uninitialized, then Certora Prover will return a violation, since then it can choose the values such that keccak(2, preImage) == slotAddress. Also see this example run for a further illustration of both cases. {note} The reader may wonder at first whether this means that the Certora Prover computes the inverse value of the Keccak function for some image value (which would be a challenging task in and of itself). This is not the case, in practice the Prover makes up any arbitrary function that fulfills the previously described axioms and also maps that single input to an output accordingly. Hashing of unbounded data In the discussion so far we only considered hashes of data whose length is already known before program execution (e.g. a uint variable always has 256 bits). Hashing of unbounded data (typically unbounded arrays, like bytes, uint[], etc.) requires some extra measures, since their implementation requires loops and the Certora Prover {doc}internally eliminates all loops <loops> in order to achieve better tractability. The Certora Prover models unbounded hashing similar to how it eliminates loops. The user specifies an upper length bound up to which unbounded hashing should be modeled precisely (using the CLI option {ref}--hashing_length_bound) as well as whether this bound is to be assumed or to be verified (using the CLI option {ref}--optimistic_hashing). We demonstrate how these flags work using the following program snippet: solidity contract C { mapping(bytes => uint) m; bytes b1, b2, b3; uint u, v, w; // ... require b1.lengp < 224; m[b1] = u; // ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-1", "chunk-uid": "12a6a556aa91", "chunk-page-index": 1, "text": "// no constraints on b2.lengp m[b2] = v; // ... // no constraints on b3.lengp m[b3] = v; assert(b3.lengp < 300, \"b3 is more pan 300 bytes long, unexpectedly\") // ... } Let us assume that the --hashing_length_bound flag is set to 224 (which corresponds to 7 machine words). Then, the first hash operation, triggered by the mapping access m[b1], behaves like the hash of a bounded data chunk. The --optimstic_hashing flag has no impact on this hash operation. The behavior of the second hash operation, triggered by the mapping access m[b2], depends on whether --optimistic_hashing is set. If the --optimistic_hashing flag is not set, the violation of an internal assertion will be reported by the Prover, stating that a chunk of data is being hashed that may exceed the given bound of 224. The reported message will look like this: text Trying to hash a non-constant length array whose length may exceed the bound (set in option \"--hashing_length_bound\", current value is 224). Optimistic unbounded hashing is currently deactivated (can be activated via option \"--optimistic_hashing\"). If the --optimistic_hashing flag is set, the Prover will internally make an assumption (equivalent to a require statement) on b2 stating that its length cannot exceed 224 bytes. --- The third operation, triggered by the mapping access m[b3] behaves like the second, since no length constraint on b3 is made by the program. However, we can see the impact of the --optimistic_hashing flag on the assert command that follows the hash operation: When the flag is set, the assertion will be shown as not violated even though nothing in the program itself prevents b3 from being longer than 300 bytes. This is an example of unsoundness coming from \"optimistic\" assumptions. (When --optimistic_hashing is not set, then we get a violation from any or all assertions, depending on the configuration of the Certora Prover.) Examples for Unbounded Hashing The following collection snippet illustrates the most common use cases for hashing of data that has unbounded length. solidity contract C { mapping(bytes => uint) m; uint x, y, z, start, len; // ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-2", "chunk-uid": "12a6a556aa91", "chunk-page-index": 2, "text": "m[b] = v // ... keccak256(abi.encode(x, y, z)) // ... keccak256(abi.encodePacked(x, y, z)) // ... assembly { keccak(start, len) } // ... } Probably the most common use case is the use of mappings whose keys are an unbounded array (bytes, string, uint[], etc.); any access to such a mapping induces a hash of the corresponding array whose length is often unknown and unbounded. Further use cases include direct calls of the Keccak function, either directly on Solidity or inside an inline assembly snippet. Note that the Certora Prover's static analysis is aware of the ABI encoder. Thus, in many cases, it can figure out that when x, y, z are scalars that keccak256(abi.encode(x, y, z)) is actually a bounded hash of the form hash(x, y, z) as opposed to an unbounded hash of the bytes array that is the result of the encode function. (Background: The Solidity Storage Model) Background: The Solidity Storage Model In this subsection we illustrate the consequences on storage integrity if the \"injectivity with large gaps\" property is not maintained. For instance consider this contract: solidity // solidity contract C { uint i; // slot 0 uint[] a; // slot 1 mapping(uint => uint) m; // slot 2 /** Always returns writeToArray (unless hashing is broken). */ function foo(uint writeToArray, uint writeToMap) public returns (uint) { i = u; // sstore(0, u) a[j] = writeToArray; // sstore(hash(1) + j, writeToArray) m[k] = writeToMap; // sstore(hash(2, k), writeToMap) } return a[j]; } // CVL mepods { foo(uint, uint) return (uint); }; rule storageIntegrity { uint writeToArray, writeToMap; require writeToArray != writeToMap; uint res = foo(writeToArray, writeToMap) assert(res == writeToArray); } The comments of the function foo illustrate how storage is laid out by Solidity. The occurrences of sstore(x, y) in the line comments above denote a storage update of storage address x to value y."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-3", "chunk-uid": "12a6a556aa91", "chunk-page-index": 3, "text": "The scalar i is stored at storage address 0, which is derived from its slot number in the contract (slots are numbered in order of appearance in the source code). The array a is --- stored contiguously, starting from slot hash(1). The entries of mapping m are spread out over storage; their locations are computed as the hash of the mapping's storage slot and the key at which the mapping is being accessed; thus the storage slot used for the entry of m under key k is computed as hash(2, k). We can see that non-collision of hashes is essential for storage integrity. E.g., if hash(1) + j was equal to hash(2, k) then the operations on a and m would interfere with each other, and foo would return the value of writeToMap rather than the value of writeToArray. Conclusion To summarize, the Certora Prover handles hashing in a way that behaves as expected for most hashes. However, it is good to be aware of limitations of the modeling; i.e. that not all properties of the actual Keccak function are preserved but only the ones that are crucial for practical use cases, which are covered by the \"injectivity with large gaps\" property. Furthermore, special attention may be necessary when hashing of unbounded data is required. For this case, Certora Prover relies on user-controlled approximations that are analogous to its handling of loops. hashing Modeling of Hashing in pe Certora Prover In this document we present how the Keccak hash function is modeled in the Certora Prover and how that impacts smart contract verification. Introduction The Keccak hash function is used heavily by Solidity smart contracts in an implicit way. Most prominently, all unbounded data structures in storage (arrays, mappings) receive their storage addresses as values of the Keccak function. It is also possible to call the Keccak hash function explicitly, both through a solidity built-in function and through inline assembly. The Certora Prover does not operate with an actual implementation of the Keccak hash function, since this would make most verification intractable and provide no practical benefits. Instead, the Certora Prover models the properties of the Keccak hash function that are crucial for the function of the smart contracts under verification while abstracting away from implementation details of the actual hash function. Modeling the Keccak function (bounded case) The Certora Prover models the Keccak hash function as an arbitrary function that is injective with large gaps. The hash function hash being injective with large gaps means that on distinct inputs x and y - the hashes hash(x) and hash(y) are also distinct, and - the gap between hash(x) and hash(y) is large enough that every additive term hash(x) + i that occurs in the program is also distinct from hash(y). Furthermore, the initial storage slots and large constants that appear in the code are reserved."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-4", "chunk-uid": "12a6a556aa91", "chunk-page-index": 4, "text": "I.e., we make sure that no hash value ends up colliding with slots 0 to 10000 nor with any constant that is explicitly given in the source code. (The latter constraint is necessary to avoid collisions with hashes that the solidity compiler has precompiled.) These constraints are enough for the Solidity storage model to work as expected. However, this modeling allows the Certora Prover to pick hash functions that show different behavior from the actual Keccak function. For instance, it is unlikely that the individual numeric values or their ordering matches that of the Keccak function. We present some examples in the following subsection. We have not observed a practical use case yet where the numeric values of the hash function play a role, thus we chose this modeling for tractability reasons. --- ## Examples (Imprecision of Modeling) We illustrate the implications of our modeling decisions using a few examples. Modeling does not account for individual values of the Keccak function The Keccak256-hash of the string hello is 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8. However, due to our modeling, the Certora Prover cannot prove that fact. the rule hashOf17Eq will show as \"violated\" since the Prover can pick a function for keccak256 that assigns hello differently. For the same reason the Prover also does not disprove that the hash of 17 is 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8, since we allow it to choose keccak256 appropriately. solidity: contract C { function hash(string x) public returns (bytes32) { return keccak256(bytes(x)); } } CVL: mepods { hash(uint) returns (uint) envfree; } rule hashOf17Eq { assert(hash(\"hello\") == 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8); } rule hashOf17Neq { assert(hash(\"hello\") != 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8); } Modeling does not account for ordering Whichever distinct values we chose for x and y in the example below, on the real Keccak function, one rule would be violated and one rule would not. In the modeling of the Certora Prover, both rules are violated, since the Prover is allowed to \"invent\" a hash function for each rule and will choose one that violates the property whenever there is such a function (as long as that function fulfills the \"injectivity with large gaps\" property). solidity: contract C { function hash(uint x) public returns (bytes32) { // we're assuming presence of some tobytes function here; it's // practical implementation is not relevant here return keccak256(tobytes(x)); } } CVL: mepods { hash(uint) returns (uint) envfree; } definition x() : uint = 12345678 definition y() : uint = 87654321 rule hashXLowerOrEqualToHashY { assert hash(x()) <= hash(y()); } rule hashXLargerThanHashY { assert(hash(x()) > hash(y())); } Constants in code vs hashes A special case in Certora Prover's modeling of hashing is the treatment of constants that appear in the code: The Prover implicitly assumes that the hash function never outputs one of these constants on any of the concrete inputs it gets in that program. For an example, consider this rule and spec: // CVL: methods { function readAtSlotAddress() external returns (uint) envfree; function updateMap(uint k, uint v) external envfree; } rule foo { uint v1 = readAtSlotAddress(); --- updateMap(preImage, x); uint v2 = readAtSlotAddress(); assert(v1 == v2); } // solidity contract C { uint constant slotAddress = 1000000; mapping(uint => uint) map; function updateMap(uint k, uint v) public { map[k] = v; } function readAtSlotAddress() public returns (uint r) { assembly { r := sload(slotAddress) } } The function readAtSlotAddress reads from storage at the slot with the number 1000000. The function updateMap updates a mapping; this means it updates storage at a hash computed from its identifier (here 1, since it is the second field in the contract) and the key k. Now, if k is chosen such that keccak(1, k) equals 1000000, the map update would overwrite that storage slot, and thus the assertion in the rule foo would be violated. However, the Certora Prover will return \"not violated\" for this assertion, since it assumes that no hash ever collides with the constant 1000000, which occurs in the program. On the other hand, if we change the contract to leave slotAddress uninitialized, then Certora Prover will return a violation, since then it can choose the values such that keccak(2, preImage) == slotAddress. Also see this example run for a further illustration of both cases. {note} The reader may wonder at first whether this means that the Certora Prover computes the inverse value of the Keccak function for some image value (which would be a challenging task in and of itself). This is not the case, in practice the Prover makes up any arbitrary function that fulfills the previously described axioms and also maps that single input to an output accordingly. Hashing of unbounded data In the discussion so far we only considered hashes of data whose length is already known before program execution (e.g. a uint variable always has 256 bits). Hashing of unbounded data (typically unbounded arrays, like bytes, uint[], etc.) requires some extra measures, since their implementation requires loops and the Certora Prover {doc}internally eliminates all loops <loops> in order to achieve better tractability. The Certora Prover models unbounded hashing similar to how it eliminates loops. The user specifies an upper length bound up to which unbounded hashing should be modeled precisely (using the CLI option {ref}--hashing_length_bound) as well as whether this bound is to be assumed or to be verified (using the CLI option {ref}--optimistic_hashing). We demonstrate how these flags work using the following program snippet: solidity contract C { mapping(bytes => uint) m; bytes b1, b2, b3; uint u, v, w; // ... require b1.length &lt; 224; m[b1] = u; // ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-5", "chunk-uid": "12a6a556aa91", "chunk-page-index": 5, "text": "// no constraints on b2.length m[b2] = v; // ... // no constraints --- on b3.length m[b3] = v; assert(b3.length &lt; 300, \"b3 is more than 300 bytes long, unexpectedly\") // ...} Let us assume that the --hashing_length_bound flag is set to 224 (which corresponds to 7 machine words). Then, the first hash operation, triggered by the mapping access m[b1], behaves like the hash of a bounded data chunk. The - -optimstic_hashing flag has no impact on this hash operation. The behavior of the second hash operation, triggered by the mapping access m[b2], depends on whether -- optimistic_hashing is set. If the --optimistic_hashing flag is not set, the violation of an internal assertion will be reported by the Prover, stating that a chunk of data is being hashed that may exceed the given bound of 224. The reported message will look like this: text Trying to hash a non-constant length array whose length may exceed the bound (set in option \"--hashing_length_bound\", current value is 224). Optimistic unbounded hashing is currently deactivated (can be activated via option \"--optimistic_hashing\"). If the --optimistic_hashing flag is set, the Prover will internally make an assumption (equivalent to a require statement) on b2 stating that its length cannot exceed 224 bytes. The third operation, triggered by the mapping access m[b3] behaves like the second, since no length constraint on b3 is made by the program. However, we can see the impact of the --optimistic_hashing flag on the assert command that follows the hash operation: When the flag is set, the assertion will be shown as not violated even though nothing in the program itself prevents b3 from being longer than 300 bytes. This is an example of unsoundness coming from \"optimistic\" assumptions. (When --optimistic_hashing is not set, then we get a violation from any or all assertions, depending on the configuration of the Certora Prover.) Examples for Unbounded Hashing The following collection snippet illustrates the most common use cases for hashing of data that has unbounded length. |solidity contract C {|mapping(bytes =&gt; uint) m;|uint x, y, z, start, len;|// ...| |---|---|---|---| |m[b] = v|// ...|keccak256(abi.encode(x, y, z))|// ...| |keccak256(abi.encodePacked(x, y, z))|// ...|assembly { keccak(start, len) }|// ...}| Probably the most common use case is the use of mappings whose keys are an unbounded array (bytes, string, uint[], etc.); any access to such a mapping induces a hash of the corresponding array whose length is often unknown and unbounded. Further use cases include direct calls of the Keccak function, either directly on Solidity or inside an inline assembly snippet. Note that the Certora Prover's static analysis is aware of the ABI encoder. Thus, in many cases, it can figure out that when x, y, z are scalars that keccak256(abi.encode(x, y, z)) is actually a bounded hash of the form hash(x, y, z) as opposed to an unbounded hash of the bytes array that is the result of the encode function. (Background: The Solidity Storage Model)= Background: The Solidity Storage Model In this subsection we illustrate the consequences on storage integrity if the \"injectivity with large gaps\" property is not maintained. For instance consider this contract: solidity // solidity contract C { uint i; // slot 0 uint[] a; // slot 1 mapping(uint =&gt; uint) m; // slot 2 /** Always returns writeToArray (unless hashing is broken). */ function foo(uint writeToArray, uint writeToMap) public returns (uint) { i = u; // sstore(0, u) --- a[j] = writeToArray; // sstore(hash(1) + j, writeToArray) m[k] = writeToMap; // sstore(hash(2, k), writeToMap) } return a[j]; } // CVL methods { foo(uint, uint) return (uint); }; rule storageIntegrity { uint writeToArray, writeToMap; require writeToArray != writeToMap; uint res = foo(writeToArray, writeToMap) assert(res == writeToArray); } ``` The comments of the function foo illustrate how storage is laid out by Solidity. The occurrences of sstore(x, y) in the line comments above denote a storage update of storage address x to value y."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-6", "chunk-uid": "12a6a556aa91", "chunk-page-index": 6, "text": "The scalar i is stored at storage address 0, which is derived from its slot number in the contract (slots are numbered in order of appearance in the source code). The array a is stored contiguously, starting from slot hash(1). The entries of mapping m are spread out over storage; their locations are computed as the hash of the mapping's storage slot and the key at which the mapping is being accessed; thus the storage slot used for the entry of m under key k is computed as hash(2, k). We can see that non-collision of hashes is essential for storage integrity. E.g., if hash(1) + j was equal to hash(2, k) then the operations on a and m would interfere with each other, and foo would return the value of writeToMap rather than the value of writeToArray. Conclusion To summarize, the Certora Prover handles hashing in a way that behaves as expected for most hashes. However, it is good to be aware of limitations of the modeling; i.e. that not all properties of the actual Keccak function are preserved but only the ones that are crucial for practical use cases, which are covered by the \"injectivity with large gaps\" property. Furthermore, special attention may be necessary when hashing of unbounded data is required."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hashing", "id": "12a6a556aa91-7", "chunk-uid": "12a6a556aa91", "chunk-page-index": 7, "text": "For this case, Certora Prover relies on user-controlled approximations that are analogous to its handling of loops."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-0", "chunk-uid": "d5eb857bf406", "chunk-page-index": 0, "text": "## Rule Sanity Checks The --rule_sanity option enables some automatic checks that can warn users about certain classes of mistakes in specifications. There are several kinds of sanity checks: Sanity Checks sanity-vacuity determine wheper rules pass vacuously because pey rule out all models. sanity-assert-tautology determine wheper individual assert statements are tautologies. sanity-trivial-invariant detect invariants pat hold in all states, raper pan just reachable states. sanity-assert-structure detect unnecessarily complex assert statements."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-1", "chunk-uid": "d5eb857bf406", "chunk-page-index": 1, "text": "sanity-redundant-require detect unnecessary require statements. The --rule_sanity option may be followed by one of none, basic, or advanced options to control which sanity checks should be executed: - With --rule_sanity none or without passing --rule_sanity, no sanity checks are performed. - With --rule_sanity basic or just --rule_sanity without a mode, the vacuity check and the trivial invariant check are performed. - With --rule_sanity advanced, all the sanity checks will be performed for all invariants and rules. We recommend starting with the basic mode, since not all rules flagged by the advanced mode are incorrect. When the Prover is run with any of these options, it first checks that the rule passes; if it does pass then the sanity checks are performed. If the sanity checks also pass, the rule is marked as verified with a green checkmark; if the sanity check fails, the rule is marked with a yellow symbol: Screenshot of rule report showing a passing rule, a failing rule, and a sanity failure If a sanity check fails, you can expand the problems view to see the details of the failure: Screenshot of rule report showing the expanded details of a sanity failure The remainder of this document describes these checks in detail. ### Vacuity checks The vacuity sanity check ensures that even when ignoring all the user-provided assertions, the end of the rule is reachable. This check ensures that the combination of require statements does not rule out all possible counterexamples."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-2", "chunk-uid": "d5eb857bf406", "chunk-page-index": 2, "text": "Rules that rule out all possible counterexamples are called vacuous rules. Since they don't actually check any assertions, they are almost certainly incorrect. For example, the following rule would be flagged by the vacuity check: cvl rule vacuous { uint x; require x > 2; require x < 1; assert f(x) == 2, \"f must return 2\"; } Since there are no models satisfying both x > 2 and x < 1, this rule will always pass, regardless of the behavior of the contract. This is an example of a vacuous rule — one that passes only because the preconditions are contradictory. The vacuity check also flags situations where counterexamples are ruled out for reasons other than require statements. A common example comes from reusing env variables. Consider the following poorly-written rule: cvl env e; uint amount; address recipient; require balanceOf(recipient) == 0; require amount > 0; deposit(e, amount); transfer(e, recipient, amount); --- assert balanceOf(recipient) &gt; 0, \"depositing and then transferring makes recipient's balance positive\"; Although it looks like this rule is reasonable, it may actually be vacuous. The problem is that the environment e is reused, and in particular e.msg.value is the same in the calls to deposit and transfer. Since transfer is not payable, it will always revert if e.msg.value != 0. On the other hand, deposit always reverts when e.msg.value == 0. Therefore every example will either cause deposit or transfer to revert, so there are no models that reach the assert statement. ## Assert tautology checks The assert tautology sanity check ensures that individual assert statements are not tautologies. A tautology is a statement that is true on all examples, even if all the require and if conditions are removed. Tautology checks also consider the bodies of the contract functions. For example, assert square(x) &gt;= 0; is a tautology if square is a contract function that squares its input. For example, the following rule would be flagged by the assert tautology check: cvl rule tautology { uint x; uint y; require x != y; ... assert x &lt; 2 || x &gt;= 2, \"x must be smaller than 2 or greater than or equal to 2\"; } Since every uint satisfies the assertion, the assertion is tautological, which may indicate an error in the specification. ## Trivial invariant checks The Trivial invariant sanity check ensures that invariants are not trivial."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-3", "chunk-uid": "d5eb857bf406", "chunk-page-index": 3, "text": "A trivial invariant is one that holds in all possible states, not just in reachable states. For example, the following invariant is trivial: cvl invariant squaresNonNeg(int x) x * x &gt;= 0 While it does hold in every reachable state, it also holds in every non-reachable state. Therefore it could be more efficiently checked as a rule: cvl rule squaresNonNeg(int x) { assert x * x &gt;= 0; } The rule version is more efficient because it can do a single check in an arbitrary state rather than separately checking states after arbitrary method invocations. ## Assertion structure checks The assertion structure sanity check ensures that complex assert statements can't be replaced with simpler ones. If an assertion expression is more complex than necessary, it can pass for misleading reasons. For example, consider the following assertion: cvl uint x; assert (x &lt; 5) =&gt; (x &gt;= 0); In this case, the assertion is true, but only because x is a uint and is therefore always non-negative. The fact that x &gt;= 0 has nothing to do with the fact that x &lt; 5. Therefore this complex assertion could be replaced with the more informative assertion assert x &gt;= 0;. --- Similarly, if the premise of the assertion is always false, then the implication is vacuously true. For example: cvl uint x; assert (x &lt; 0) =&gt; (x &gt;= 5); This assertion will pass, but only because the unsigned integer x is never negative. This may mislead the user into thinking that they have checked that x &gt;= 5 in some interesting situation, when in fact they have not. The simpler assertion assert x &gt;= 0; more clearly describes what is going on. Overly complex assertions like this may indicate a mistake in the rule. In this case, for example, the fact that the user was checking that x &gt;= 0 may indicate that they should have declared x as an int instead of a uint. The assertion structure check tries to prove some complex logical statements by breaking them into simpler parts. The following situations are reported by the assertion structure check: |assert p =&gt; q;|is reported as a sanity violation if p is false whenever the assertion is reached (in which case the simpler assertion assert !p; more clearly describes the situation), or if q is always true (in which case assert q; is a clearer alternative).| |---|---| |assert p &lt;=&gt; q;|is reported as a sanity violation if either p and q are both true whenever the assertion is reached (in which case the simpler assertions assert p; assert q; more clearly describe the situation), or if neither p nor q are ever true (in which case assert !p; assert !q; is a clearer alternative).| |assert p || q;|is reported as a sanity violation if either p is true whenever the assertion is reached (in which case assert p; more clearly describes the situation) or if q is always true (in which case assert q; is a clearer alternative).| Redundant require checks The require redundancy sanity check highlights redundant require statements. A require is considered to be redundant if it does not rule out any models that haven't been ruled out by previous requires. For example, the require-redundancy check would flag the following rule: cvl rule require_redundant { uint x; require x &gt; 3; require x &gt; 2; assert f(x) == 2, \"f must return 2\"; } In this example, the second requirement is redundant, since any x greater than 3 will also be greater than 2. Rule Sanity Checks The --rule_sanity option enables some automatic checks that can warn users about certain classes of mistakes in specifications. There are several kinds of sanity checks: - sanity-vacuity determine whether rules pass vacuously because they rule out all models. - sanity-assert-tautology determine whether individual assert statements are tautologies. - sanity-trivial-invariant detect invariants that hold in all states, rather than just reachable states. - sanity-assert-structure detect unnecessarily complex assert statements."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-4", "chunk-uid": "d5eb857bf406", "chunk-page-index": 4, "text": "- sanity-redundant-require detect unnecessary require statements. The --rule_sanity option may be followed by one of none, basic, or advanced options to control which sanity checks should be executed: * With --rule_sanity none or without passing --rule_sanity, no sanity checks are performed. * --- ## Sanity Checks With --rule_sanity basic or just --rule_sanity without a mode, the vacuity check and the trivial invariant check are performed. With --rule_sanity advanced, all the sanity checks will be performed for all invariants and rules. We recommend starting with the basic mode, since not all rules flagged by the advanced mode are incorrect. When the Prover is run with any of these options, it first checks that the rule passes; if it does pass then the sanity checks are performed. If the sanity checks also pass, the rule is marked as verified with a green checkmark; if the sanity check fails, the rule is marked with a yellow symbol: Screenshot of rule report showing a passing rule, a failing rule, and a sanity failure If a sanity check fails, you can expand the problems view to see the details of the failure: Screenshot of rule report showing pe expanded details of a sanity failure The remainder of this document describes these checks in detail. ### Vacuity checks The vacuity sanity check ensures that even when ignoring all the user-provided assertions, the end of the rule is reachable."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-5", "chunk-uid": "d5eb857bf406", "chunk-page-index": 5, "text": "This check ensures that the combination of require statements does not rule out all possible counterexamples. Rules that rule out all possible counterexamples are called vacuous rules. Since they don't actually check any assertions, they are almost certainly incorrect. For example, the following rule would be flagged by the vacuity check: cvl rule vacuous { uint x; require x > 2; require x < 1; assert f(x) == 2, \"f must return 2\"; } Since there are no models satisfying both x > 2 and x < 1, this rule will always pass, regardless of the behavior of the contract. This is an example of a vacuous rule — one that passes only because the preconditions are contradictory. The vacuity check also flags situations where counterexamples are ruled out for reasons other than require statements. A common example comes from reusing env variables. Consider the following poorly-written rule: cvl env e; uint amount; address recipient; require balanceOf(recipient) == 0; require amount > 0; deposit(e, amount); transfer(e, recipient, amount); assert balanceOf(recipient) > 0, \"depositing and then transferring makes recipient's balance positive\"; Although it looks like this rule is reasonable, it may actually be vacuous. The problem is that the environment e is reused, and in particular e.msg.value is the same in the calls to deposit and transfer. Since transfer is not payable, it will always revert if e.msg.value != 0. On the other hand, deposit always reverts when e.msg.value == 0. Therefore every example will either cause deposit or transfer to revert, so there are no models that reach the assert statement. ### Assert tautology checks The assert tautology sanity check ensures that individual assert statements are not tautologies. A tautology is a statement that is true on all examples, even if all the require and if conditions are removed. Tautology checks also consider the bodies of the contract functions. For example, assert square(x) >= 0; is a tautology if square is a contract function that squares its input. For example, the following rule would be flagged by the assert tautology check: --- cvl rule tautology { uint x; uint y; require x != y; ... assert x < 2 || x >= 2, \"x must be smaller than 2 or greater than or equal to 2\"; } Since every uint satisfies the assertion, the assertion is tautological, which may indicate an error in the specification. ## Trivial invariant checks The Trivial invariant sanity check ensures that invariants are not trivial."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sanity", "id": "d5eb857bf406-6", "chunk-uid": "d5eb857bf406", "chunk-page-index": 6, "text": "A trivial invariant is one that holds in all possible states, not just in reachable states. For example, the following invariant is trivial: cvl invariant squaresNonNeg(int x) x * x >= 0 While it does hold in every reachable state, it also holds in every non-reachable state. Therefore it could be more efficiently checked as a rule: cvl rule squaresNonNeg(int x) { assert x * x >= 0; } The rule version is more efficient because it can do a single check in an arbitrary state rather than separately checking states after arbitrary method invocations. ## Assertion structure checks The assertion structure sanity check ensures that complex assert statements can't be replaced with simpler ones. If an assertion expression is more complex than necessary, it can pass for misleading reasons. For example, consider the following assertion: cvl uint x; assert (x < 5) => (x >= 0); In this case, the assertion is true, but only because x is a uint and is therefore always non-negative. The fact that x >= 0 has nothing to do with the fact that x < 5. Therefore this complex assertion could be replaced with the more informative assertion assert x >= 0;. Similarly, if the premise of the assertion is always false, then the implication is {term}vacuously <vacuous> true. For example: cvl uint x; assert (x < 0) => (x >= 5); This assertion will pass, but only because the unsigned integer x is never negative. This may mislead the user into thinking that they have checked that x >= 5 in some interesting situation, when in fact they have not. The simpler assertion assert x >= 0; more clearly describes what is going on. Overly complex assertions like this may indicate a mistake in the rule. In this case, for example, the fact that the user was checking that x >= 0 may indicate that they should have declared x as an int instead of a uint. The assertion structure check tries to prove some complex logical statements by breaking them into simpler parts. The following situations are reported by the assertion structure check: - assert p => q; is reported as a sanity violation if p is false whenever the assertion is reached (in which case the simpler assertion assert !p; more clearly describes the situation), or if q is always true (in which case assert q; is a clearer alternative). --- assert p <=> q; is reported as a sanity violation if either p and q are both true whenever the assertion is reached (in which case the simpler assertions assert p; assert q; more clearly describe the situation), or if neither p nor q are ever true (in which case assert !p; assert !q; is a clearer alternative). assert p || q; is reported as a sanity violation if either p is true whenever the assertion is reached (in which case assert p; more clearly describes the situation) or if q is always true (in which case assert q; is a clearer alternative). ## Redundant require checks The require redundancy sanity check highlights redundant require statements. A require is considered to be redundant if it does not rule out any {term}models <model> that haven't been ruled out by previous requires. For example, the require-redundancy check would flag the following rule: cvl rule require_redundant { uint x; require x > 3; require x > 2; assert f(x) == 2, \"f must return 2\"; } In this example, the second requirement is redundant, since any x greater than 3 will also be greater than 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "overview", "id": "c91b7a817d96-0", "chunk-uid": "c91b7a817d96", "chunk-page-index": 0, "text": "## Overview In this tutorial, we will cover the basics of the Certora Prover and reach some of the most advanced features available that the Prover offers. You will learn about common specification patterns, diagnosing violations reported by the Prover, and troubleshooting wrong configurations of the Prover. Our running example will be a smart contract implementing a Map."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "overview", "id": "c91b7a817d96-1", "chunk-uid": "c91b7a817d96", "chunk-page-index": 1, "text": "Initially, we will implement a map that doesn't provide much beyond the standard primitive mapping type of Solidity, but as we progress, we will support iteration over the map's keys (slightly akin to OpenZeppelin's EnumerableMap contract)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hooks", "id": "f276ca3d8f16-0", "chunk-uid": "f276ca3d8f16", "chunk-page-index": 0, "text": "## Storage Hooks Note: much of the information that was here has been revised and moved to hooks and tracking-changes. ## Two State Context A two-state context is a scope in which two versions of a variable or ghost function are available, representing two different states of that variable/ghost function. If we are talking about the variable my_var then the old version would be accessed using my_var@old, and the new version would be accessed using my_var@new."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hooks", "id": "f276ca3d8f16-1", "chunk-uid": "f276ca3d8f16", "chunk-page-index": 1, "text": "For ghost functions, we annotate the ghost application. For example, an application of the old version might look like my_ghost@old(x, y), and an application of the new version might look like my_ghost@new(x, y). But how is it that we would have two versions of a variable or ghost function? Currently, the only place that will create these two versions is a havoc-assuming statement. ## Havoc Assuming Sometimes we want to forget everything we know about a variable and allow it to take any value from a certain program point onward. This is when we havoc a variable. For example: cvl rule my_rule(uint256 x) { require x == 2; assert x == 2; // passes havoc x; assert x == 2; // fails } Other times, we'd only like to forget certain things about a variable or ghost function, and sometimes we'd like to learn new things or constrain a variable based on its own value. This is where the havoc assuming statement becomes very useful. The following example should illustrate the idea: cvl rule my_rule(uint256 x) { require x >= 2; havoc x assuming x@new > x@old; assert x > 2; // passes } And a havoc assuming statement with a ghost function might look like the following: cvl ghost contains(uint256 x) returns bool; rule my_rule(uint256 x, uint256 y, uint256 z) { require contains(x); // \"every input that used to return true should still return true // AND y should now return true as well\" havoc contains assuming contains@new(y) && forall uint256 a. contains@old(a) => contains@new(a); assert contains(x) && contains(y); // passes assert contains(z); // fails } Finally, as shown in the section on definitions, a definition with ghosts in two-state form may be used inside the two-state context of a havoc assuming statement. ## A Hook that Modifies Ghost State Above we saw an example where we made sure that the ghost state matched a read of its corresponding concrete state. This did not modify the ghost state but rather further constrained it according to new information. But when the concrete state is changed, we need some way to modify the ghost state. Suppose we have an update to a balance. We can use a havoc assuming statement to assume that all balances not concerned by the update stay the same and that the balance of the account that was changed gets updated: cvl ghost ghostBalances(address) returns uint256; --- hook Sstore balances[KEY address account] uint256 v { havoc ghostBalances assuming ghostBalances@new(account) == v && forall address a. a != account => ghostBalances@new(a) == ghostBalances@old(a); } {caution} In `Sstore` hooks, the old value is read by means of generating an `Sload`. However, any hook that can be matched to the generated `Sload` _does not_ apply within the `Sstore` hook. Storage Hooks Note: much of the information that was here has been revised and moved to {ref}hooks and {ref}tracking-changes. Two State Context A two-state context is a scope in which two versions of a variable or ghost function are available, representing two different states of that variable/ghost function. If we are talking about the variable my_var then the old version would be accessed using my_var@old, and the new version would be accessed using my_var@new."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "hooks", "id": "f276ca3d8f16-2", "chunk-uid": "f276ca3d8f16", "chunk-page-index": 2, "text": "For ghost functions, we annotate the ghost application. For example, an application of the old version might look like my_ghost@old(x, y), and an application of the new version might look like my_ghost@new(x, y) . But how is it that we would have two versions of a variable or ghost function? Currently, the only place that will create these two versions is a havoc-assuming statement. Havoc Assuming Sometimes we want to forget everything we know about a variable and allow it to take any value from a certain program point onward. This is when we havoc a variable. For example: cvl rule my_rule(uint256 x) { require x == 2; assert x == 2; // passes havoc x; assert x == 2; // fails } Other times, we'd only like to forget certain things about a variable or ghost function, and sometimes we'd like to learn new things or constrain a variable based on its own value. This is where the havoc assuming statement becomes very useful. The following example should illustrate the idea: cvl rule my_rule(uint256 x) { require x >= 2; havoc x assuming x@new > x@old; assert x > 2; // passes } and a havoc assuming statement with a ghost function might look like the following: cvl ghost contains(uint256 x) returns bool; rule my_rule(uint256 x, uint256 y, uint256 z) { require contains(x); // \"every input that used to return true should still return true // AND y should now return true as well\" havoc contains assuming contains@new(y) && forall uint256 a. contains@old(a) => contains@new(a); assert contains(x) && contains(y); // passes assert contains(z); // fails } Finally, as shown in the section on definitions, a definition with ghosts in two-state form may be used inside the two-state context of a havoc assuming statement. A Hook that Modifies Ghost State Above we saw an example where we made sure that the ghost state matched a read of its corresponding concrete state. This did not modify the ghost state but rather further constrained it according to new information. But when the concrete state is changed, we need some way to modify the ghost state. Suppose we have an update to a balance. We can use a havoc --- assuming statement to assume that all balances not concerned by the update stay the same and that the balance of the account that was changed gets updated: |cvl|ghost|ghostBalances(address) returns uint256;| |---|---|---| |hook|Sstore balances[KEY address account] uint256 v { havoc ghostBalances assuming ghostBalances@new(account) == v && forall address a. a != account => ghostBalances@new(a) == ghostBalances@old(a); }| | {caution} In `Sstore` hooks, the old value is read by means of generating an `Sload`. However, any hook that can be matched to the generated `Sload` _does not_ apply within the `Sstore` hook."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-0", "chunk-uid": "63f0c595613d", "chunk-page-index": 0, "text": "## Installation These instructions are for Linux and macOS systems. Windows users should use WSL and follow the Linux installation instructions. ### Step 1: Prerequisites - Python3.8.16 or newer Check your Python3 version by executing the following command on the terminal: bash python3 --version If the version is < 3.8.16, follow the Python installation guide to upgrade. - Java Development Kit (JDK) 11 or newer Check your Java version by executing the following command on the terminal: bash java -version If the version is < 11, download and install Java version 11 or later from Oracle. ### Solidity compiler (ideally v0.5 and up) - We recommend using solc-select to download and switch between Solidity compiler versions. - You can also download the Solidity compiler binaries from the official Solidity repository on GitHub. It is best to place all the solc binaries in the same path. - Certora employees can clone the CVT_Executables repository suitable for their OS from GitHub. ### Step 2: Install the Certora Prover package Tip: It is always recommended to use a Python virtual environment, such as venv or virtualenv, when installing a Python package. Execute the following command at the terminal to install the Prover: bash pip3 install certora-cli Caution: Note that the terminal may prompt you with a warning that some files, e.g. python3.x, are not included in the `PATH`, and should be added."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-1", "chunk-uid": "63f0c595613d", "chunk-page-index": 1, "text": "Add these files to `PATH` to avoid errors. The following section presents some, but maybe not all, possible warnings that can arise during installation and how to deal with them: #### macOS --- ## The warning The script certoraRun is installed in /Users/&lt;user name&gt;/Library/Pypon/3.8/bin which is not on PATH. Consider adding pis directory to PATH. Open a terminal and move to the etc/paths.d directory from root: cd /etc/paps.d Use root privileges to create a file with an informative name such as \"PythonForProver\", and open it with your favorite text editor: sudo nano PyponForProver Write the specified path from the warning: /specified/pap/in/warning If needed, more than one path can be added on a single file, just separate the path with a colon (\":\"). Quit the terminal to load the new addition to $PATH, and reopen to check that the $PATH was updated correctly: echo $PATH ## The warning The script certoraRun is installed in /home/&lt;user name&gt;/.local/bin which is not on PATH. Consider adding pis directory to PATH. Open a terminal and make sure you're in the home directory: cd ~ open the .profile file with your favorite text editor: nano .profile At the bottom of the file, add to PATH=\"...\" the specified path --- ### Installing the beta version (optional) If you wish to install a pre-release version, you can do so by installing certora-cli-beta instead of certora-cli. We do not recommend having both packages installed simultaneously, so you should remove the certora-cli package before installing certora-cli-beta: sh pip uninstall certora-cli pip install certora-cli-beta If you wish to easily switch between the beta and the production versions, you can use a python virtual environment: |sh pip install virtualenv|virtualenv certora-beta| |---|---| |source certora-beta/bin/activate|pip3 install certora-cli-beta| You can then switch to the standard CVL release by running deactivate, and back to the beta release using certora-beta/bin/activate. ### Step 3: Set the personal access key as an environment variable The Certora Prover requires a personal access key. You can get a free personal access key by registering on the Certora website. Before running the Prover, you should register your access key as a system variable. To do so on macOS or Linux machines, execute the following command on the terminal: bash export CERTORAKEY=&lt;personal_access_key&gt; This command sets a temporary variable that will be unset once the terminal is closed. We recommended storing the access key in an environment variable named CERTORAKEY. This way, you will no longer need to execute the above command whenever you open a terminal. To set an environment variable permanently, follow the next steps: --- ## Open a terminal and make sure you're in the home directory: cd ~ ## Create a file with the name .zshenv and open it with your favorite text editor: nano .zshenv Write the export command from the beginning of step 3, save and quit (ctrl+x on nano). You can make sure that the file was created correctly by seeing it listed on the directory or by opening it again with the text editor: ls -a OR nano .zshenv Make sure to apply the environment variable you've just created by executing the script: source .zshenv When running the Certora Prover in the Visual Studio Code Extension, you may need to restart VSCode or your computer. ## Linux Open a terminal and make sure you're in pe home directory: cd ~ ## open the .profile file with your favorite text editor: nano .profile At the bottom of the file, under the PATH=\"...\" insert the export command from the beginning of step 3, save and quit (ctrl+x on nano). You can make sure that the file was modified correctly by opening it again with the text editor: ls -a --- ## nano .profile * Make sure to apply the environment variable you've just created by executing the script: source .profile ## Step 4: Install the relevant Solidity compiler versions The Solidity compiler (solc) is a verification requirement. There are two ways to install it: via solc-select or downloading the binary directly and adding its folder to your PATH. Using solc-select ### Details solc-select instructions Open a terminal and install solc-select via pip: pip install solc-select Download the required compiler version. For example, if you want to install version 0.8.0, run: solc-select install 0.8.0 Set solc to point to the required compiler version. For example: solc-select use 0.8.0 Download binaries You can download the solc binaries directly from Solidity's release page on GitHub. To run the Prover, you may find it useful to add the solc executables folder to your PATH. This way you will not need to provide the Prover with the full path to the solc executables folder every time. Downloading binaries ### macOS Open a terminal and move to the /etc/paths.d directory from root: cd /etc/paths.d --- ## Use root privileges to create a file with an informative name such as \"SolidityCertoraProver\", and open it with your favorite text editor: sudo nano SolidityCertoraProver ## Write the full path to the directory that contains the \"solc\" executables: /full/pap/to/solc/executable/folder - If needed, more than one path can be added on a single file, just separate the path with colon a (\":\"). ## Quit the terminal to load the new addition to \"$PATH\", and reopen to check that the \"$PATH\" was updated correctly: echo $PATH ## Linux - Open a terminal and make sure you're in the home directory: cd ~ - Open the .profile file with your favorite text editor: nano .profile - At the bottom of the file, add to \"PATH=...\" the full path to the directory that contains the 'solc' executables. To add an additional path just separate with a colon (\":\"): PATH=\"$PATH:/full/pap/to/solc/executable/folder\" - You can make sure that the file was modified correctly by opening it again with the text editor: nano .profile - Make sure to apply the changes to the \"$PATH\" by executing the script: nano .profile --- ## source .profile {index} single: VS code; extension Step 5 (for VS Code users): Install the Certora Verification Language LSP All users of the Certora Prover can access the tool using the command line interface, or CLI. Those who use Microsoft's Visual Studio Code editor (VS Code) also have the option of using the Certora Verification Language LSP."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-2", "chunk-uid": "63f0c595613d", "chunk-page-index": 2, "text": "This will provide both syntax checking and syntax highlighting for CVL. Congratulations! You have just completed Certora Prover's installation and setup. {caution} We strongly recommend trying the tool on basic examples to verify correct installation. See {doc}`running` for a detailed walkthrough. {index} single: install ## Installation {attention} These instructions are for Linux and macOS systems. Windows users should use WSL and follow the Linux installation instructions. Step 1: prerequisites - Python3.8.16 or newer Check your Python3 version by executing the following command on the terminal: bash python3 --version If the version is < 3.8.16, follow the Python installation guide to upgrade. - Java Development Kit (JDK) 11 or newer Check your Java version by executing the following command on the terminal: bash java -version If the version is < 11, download and install Java version 11 or later from Oracle. {index} single: solc - Solidity compiler (ideally v0.5 and up) We recommend using solc-select to download and switch between Solidity compiler versions. You can also download the Solidity compiler binaries from the official Solidity repository on GitHub. It is best to place all the solc binaries in the same path. Certora employees can clone the CVT_Executables repository suitable for their OS from GitHub. Step 2: Install the Certora Prover package --- ## {tip} It is always recommended to use a Python virtual environment, such as venv or virtualenv, when installing a Python package. Execute the following command at the terminal to install the Prover: bash pip3 install certora-cli ## {caution} Note that the terminal may prompt you with a warning that some files, e.g. python3.x, are not included in the PATH, and should be added."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-3", "chunk-uid": "63f0c595613d", "chunk-page-index": 3, "text": "Add these files to PATH to avoid errors. The following section presents some, but maybe not all, possible warnings that can arise during installation and how to deal with them: ### macOS<br/>The warning The script certoraRun is installed in /Users/&lt;user name&gt;/Library/Python/3.8/bin which is not on PATH. Consider adding this directory to PATH. - Open a terminal and move to the etc/paths.d directory from root: - Use root privileges to create a file with an informative name such as PythonForProver, and open it with your favorite text editor: - Write the specified path from the warning: - If needed, more than one path can be added on a single file, just separate the path with a colon (:). - Quit the terminal to load the new addition to $PATH, and reopen to check that the $PATH was updated correctly: ### Linux<br/>The warning --- ## The warning The script certoraRun is installed in /home/&lt;user name&gt;/.local/bin which is not on PATH. Consider adding this directory to PATH. - Open a terminal and make sure you're in the home directory: cd ~ - open the .profile file with your favorite text editor: nano .profile - At the bottom of the file, add to PATH=\"...\" the specified path from the warning. To add an additional path just separate with a colon (:) : PATH=\"$PATH:/specified/path/in/warning\" - You can make sure that the file was modified correctly by opening it again with the text editor: nano .profile - Make sure to apply the changes to the $PATH by executing the script: source .profile ## Installing the beta version (optional) If you wish to install a pre-release version, you can do so by installing certora-cli-beta instead of certora-cli. We do not recommend having both packages installed simultaneously, so you should remove the certora-cli package before installing certora-cli-beta: pip uninstall certora-cli pip install certora-cli-beta If you wish to easily switch between the beta and the production versions, you can use a python virtual environment: pip install virtualenv virtualenv certora-beta source certora-beta/bin/activate pip3 install certora-cli-beta You can then switch to the standard CVL release by running deactivate, and back to the beta release using certora-beta/bin/activate. --- ## Step 3: Set the personal access key as an environment variable The Certora Prover requires a personal access key. You can get a free personal access key by registering on the Certora website. Before running the Prover, you should register your access key as a system variable. To do so on macOS or Linux machines, execute the following command on the terminal: bash export CERTORAKEY=&lt;personal_access_key&gt; This command sets a temporary variable that will be unset once the terminal is closed. We recommended storing the access key in an environment variable named CERTORAKEY. This way, you will no longer need to execute the above command whenever you open a terminal. To set an environment variable permanently, follow the next steps: macOS - Open a terminal and make sure you're in pe home directory: - Create a file wip pe name .zshenv and open it wip your favorite text editor: - Write pe export command from pe beginning of step 3, save and quit (ctrl+x on nano). - You can make sure pat pe file was created correctly by seeing it listed on pe directory or by opening it again wip pe text editor: - Make sure to apply pe environment variable you've just created by executing pe script: Linux When running pe Certora Prover in pe Visual Studio Code Extension, you may need to restart VSCode or your computer. --- ## Step 4: Install the relevant Solidity compiler versions The Solidity compiler (solc) is a verification requirement. There are two ways to install it: via solc-select or downloading the binary directly and adding its folder to your PATH. Using solc-select Details solc-select instructions Open a terminal and install solc-select via pip: bash pip install solc-select Download pe required compiler version. For example, if you want to install version 0.8.0, run: bash solc-select install 0.8.0 Set solc to point to pe required compiler version. For example: bash solc-select use 0.8.0 --- ## Download binaries You can download the solc binaries directly from Solidity's release page on GitHub. To run the Prover, you may find it useful to add the solc executables folder to your PATH. This way you will not need to provide the Prover with the full path to the solc executables folder every time. macOS 1. Open a terminal and move to pe etc/paps.d directory from root: 2. cd /etc/paps.d Use root privileges to create a file wip an informative name such as SolidityCertoraProver, and open it wip your favorite text editor: 3. sudo nano SolidityCertoraProver Write pe full pap to pe directory pat contains pe solc executables: 4. /full/pap/to/solc/executable/folder If needed, more pan one pap can be added on a single file, just separate pe pap wip colon a (:)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-4", "chunk-uid": "63f0c595613d", "chunk-page-index": 4, "text": "5. Quit pe terminal to load pe new addition to $PATH, and reopen to check pat pe $PATH was updated correctly: Linux 1. Open a terminal and make sure you're in pe home directory: 2. cd ~ open pe .profile file wip your favorite text editor: --- At the bottom of the file, add to PATH=\"...\" the full path to the directory that contains the solc executables. To add an additional path just separate with a colon (:): PATH=\"$PATH:/full/path/to/solc/executable/folder\" You can make sure that the file was modified correctly by opening it again with the text editor: nano .profile Make sure to apply the changes to the $PATH by executing the script: source .profile Step 5 (for VS Code users): Install the Certora Verification Language LSP All users of the Certora Prover can access the tool using the command line interface, or CLI. Those who use Microsoft's Visual Studio Code editor (VS Code) also have the option of using the Certora Verification Language LSP."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "install", "id": "63f0c595613d-5", "chunk-uid": "63f0c595613d", "chunk-page-index": 5, "text": "This will provide both syntax checking and syntax highlighting for CVL. Congratulations! You have just completed Certora Prover's installation and setup. We strongly recommend trying the tool on basic examples to verify correct installation. See running for a detailed walkthrough."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "pitfalls", "id": "44082efbc33a-0", "chunk-uid": "44082efbc33a", "chunk-page-index": 0, "text": "## Common Pitfalls Vacuity Vacuity refers to the state where we have a spec reported to be correct by the Prover, even for assertions that are obviously wrong. To be more precise, an assertion in the spec is effectively not checked because no input satisfies all requirements defined by the spec. An obvious example of vacuity is the following rule: cvl rule vacuous(uint x) { require x != x; assert false; } No input x ever satisfies x != x, but the assert false is expected to trigger a failure. The vacuity of the require statement implies our assertion is not reachable, thus the rule is proven. Vacuity is problematic because it indicates that the spec itself is wrong. Usually, vacuity is not as blatantly visible as in the above example, and thus we should take precautions to avoid writing vacuous specs. Basic vacuity checking Run the certora-cli with the following additional option: --rule_sanity to run a basic vacuity check. This option will instruct the tool to prove each rule twice: First time with the original spec, Second time with all assertions removed, and a single assert false statement in the end instead. If the second run of the rule does not fail, then a successful result of the original run is meaningless."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "pitfalls", "id": "44082efbc33a-1", "chunk-uid": "44082efbc33a", "chunk-page-index": 1, "text": "Below we present a few examples of vacuous specs. Raw arguments (soon to be solved!) The calldataarg type represents the full byte array passed as calldata to the EVM bytecode. It includes, in particular, the 4-byte sighash used by the ABI specification to identify the high-level function executed. Therefore, the following spec will pass vacuously: cvl rule dontForgetThe4Bytes { env e; calldataarg args; foo@norevert(e, args); bar@norevert(e, args); assert false; } foo() and bar() have different sighashes, thus a single calldataarg cannot be used to run both. lastReverted updates The lastReverted keyword is updated every time a Solidity function is invoked. Therefore, it may be confusing what invocation lastReverted refers to. For example: cvl rule bad { foo(); assert bar() => lastReverted; } The spec writer intended to check that foo() reverted if bar() returns true. But since bar() appears before lastReverted, it means lastReverted refers to whether bar() reverted or not. A corrected version of the spec should like this: cvl rule good1 { foo(); bool fooReverted = lastReverted; assert bar() => fooReverted; } There are cases where we can evaluate bar() either before or after foo(). In these cases, the following rewrite can be fitting too: cvl rule good2 { bool barHolds = bar(); foo(); assert barHolds => lastReverted; } --- ## Common Pitfalls Vacuity Vacuity refers to the state where we have a spec reported to be correct by the Prover, even for assertions that are obviously wrong. To be more precise, an assertion in the spec is effectively not checked because no input satisfies all requirements defined by the spec. An obvious example of vacuity is the following rule: cvl rule vacuous(uint x) { require x != x; assert false; } No input x ever satisfies x != x, but the assert false is expected to trigger a failure. The vacuity of the require statement implies our assertion is not reachable, thus the rule is proven. Vacuity is problematic because it indicates that the spec itself is wrong. Usually, vacuity is not as blatantly visible as in the above example, and thus we should take precautions to avoid writing vacuous specs. Basic vacuity checking Run the certora-cli with the following additional option: --rule_sanity to run a basic vacuity check. This option will instruct the tool to prove each rule twice: First time with the original spec, Second time with all assertions removed, and a single assert false statement in the end instead. If the second run of the rule does not fail, then a successful result of the original run is meaningless."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "pitfalls", "id": "44082efbc33a-2", "chunk-uid": "44082efbc33a", "chunk-page-index": 2, "text": "Below we present a few examples of vacuous specs. Raw arguments (soon to be solved!) The calldataarg type represents the full byte array passed as calldata to the EVM bytecode. It includes, in particular, the 4-byte sighash used by the ABI specification to identify the high-level function executed. Therefore, the following spec will pass vacuously: cvl rule dontForgetThe4Bytes { env e; calldataarg args; foo@norevert(e, args); bar@norevert(e, args); assert false; } foo() and bar() have different sighashes, thus a single calldataarg cannot be used to run both. lastReverted updates The lastReverted keyword is updated every time a Solidity function is invoked. Therefore, it may be confusing what invocation lastReverted refers to. For example: cvl rule bad { foo(); assert bar() => lastReverted; } The spec writer intended to check that foo() reverted if bar() returns true. But since bar() appears before lastReverted, it means lastReverted refers to whether bar() reverted or not. A corrected version of the spec should like this: cvl rule good1 { foo(); bool fooReverted = lastReverted; assert bar() => fooReverted; } There are cases where we can evaluate bar() either before or after foo(). In these cases, the following rewrite can be fitting too: cvl rule good2 { bool barHolds = bar(); foo(); assert barHolds => lastReverted; }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "update", "id": "1f88131a11dd-0", "chunk-uid": "1f88131a11dd", "chunk-page-index": 0, "text": "## Syntax Update: Ghost Variables and Ghost Mappings Variable-style declarations CVL now allows for top-level declarations of ghosts that follow the common scheme for variable declarations. Ghost variables can be scalars (uint etc.) or mappings. cvl ghost uint myGhost; ghost mapping(uint => uint) myGhostMapping; Nested (multi-dimensional) ghost mappings are supported, too. cvl ghost mapping(uint => mapping(uint => uint)) myTwoDimensionalGhostMapping Background: Semantically there is no difference between the new variable-style and the old function-style declarations. I.e., the declaration ghost uint myGhost creates the same semantic object as the declaration ghost myGhost() returns uint. Variable-style access Ghosts that have been declared as scalar variables are accessed like normal variables, e.g. : cvl y = myGhost; myGhost = x; Ghosts that have been declared as mapping variables are accessed like normal mappings: cvl y = myGhostMapping[i]; myGhostMapping[j] = x; Mapping-style updates The update syntax myGhostMapping[j] = x can replace many uses of the havoc .. assuming .. syntax. In particular, the old syntax cvl havoc myGhostMapping assuming forall k. k = j ? myGhostMapping@new[k] = x : myGhostMapping@new[k] = myGhostMapping@old[k]; can be replaced by cvl myGhostMapping[j] = x; Note that this syntax avoids the quantifiers also internally, so it is strongly recommended to use it if possible. --- Background: Semantically there is no difference between the new variable-style and the old function-style declarations. I.e., the declaration ghost uint myGhost creates the same semantic object as the declaration ghost myGhost() returns uint. Variable-style access Ghosts that have been declared as scalar variables are accessed like normal variables, e.g. : cvl y = myGhost; myGhost = x; Ghosts that have been declared as mapping variables are accessed like normal mappings: cvl y = myGhostMapping[i]; myGhostMapping[j] = x; Mapping-style updates The update syntax myGhostMapping[j] = x can replace many uses of the havoc .. assuming .."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "update", "id": "1f88131a11dd-1", "chunk-uid": "1f88131a11dd", "chunk-page-index": 1, "text": "syntax. In particular, the old syntax cvl havoc myGhostMapping assuming forall k. k = j ? myGhostMapping@new[k] = x : myGhostMapping@new[k] = myGhostMapping@old[k]; can be replaced by cvl myGhostMapping[j] = x; Note that this syntax avoids the quantifiers also internally, so it is strongly recommended to use it if possible."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation", "id": "5f4c8e634022-0", "chunk-uid": "5f4c8e634022", "chunk-page-index": 0, "text": "Mutation Testing Mutation testing refers to changing the verified code in a way that is likely to cause a bug, and then checking that the modified code does not pass verification. Learn more about how Certora uses mutation testing here. Mutation Testing Mutation testing refers to changing the verified code in a way that is likely to cause a bug, and then checking that the modified code does not pass verification."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "mutation", "id": "5f4c8e634022-1", "chunk-uid": "5f4c8e634022", "chunk-page-index": 1, "text": "Learn more about how Certora uses mutation testing here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-0", "chunk-uid": "8951e3708e40", "chunk-page-index": 0, "text": "## CVL2 Migration Guide This section gives a step-by-step process for migrating your specs from CVL 1 to CVL 2. It only addresses the changes that are most likely to arise; for full details see changes. Here is an outline of the migration process: If you have any questions, please ask for help! ### Step 0: Install CVL 2 The certora-cli python package will use CVL 2 starting with version 4.0.0. If you aren't ready to migrate your specs yet, Certora will continue supporting CVL 1 for three months after the official release of CVL 2. You can keep using CVL 1 after the release of certora-cli-4.0.0 by pinning your certora-cli package to version 3.6.5: pip install 'certora-cli&lt;4.0.0' If you want to switch between the two versions, see the instructions for setting up a virtual environment in beta-install. ### Step 1: Skim CVL 2 changes We recommend at least skimming changes to familiarize yourself with the changes introduced by CVL 2. ### Step 2: Run the migration script Certora has written a simple script to aid in the conversion from CVL 1 to CVL 2. You can download the script here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-1", "chunk-uid": "8951e3708e40", "chunk-page-index": 1, "text": "The script will automatically modify all .spec files in a directory. The script will modify the files in place, so make sure that you commit your files before running it. To run the script, place it in a file called CVL1_to_CVL2.0_syntax_update.py and run it using the following command: python3 CVL1_to_CVL2.0_syntax_update.py -d &lt;path&gt; -r Run python3 CVL1_to_CVL2.0_syntax_update.py --help for further instructions. The migration script only handles simple cases, and is not guaranteed to work."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-2", "chunk-uid": "8951e3708e40", "chunk-page-index": 2, "text": "Some manual work and adjustment may be needed after running the script."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-3", "chunk-uid": "8951e3708e40", "chunk-page-index": 3, "text": "The script may also make odd mistakes. The script will attempt to make the following changes: - replace sinvoke f(...) with f(...) - replace invoke f(...) with f@withrevert(...) - replace f(...).selector with sig:f(...).selector - ensure that rules start with rule - replace static_assert with assert - replace static_require with require - add ; to the end of pragma, import, using, and use statements - add a ; to the end of a methods block entry if it doesn't seem to continue to the next line - add function to the beginning of a methods block entry - add external to unsummarized or DISPATCHER methods block entries - change function f(...) to function _.f(...) for summarized external functions In particular, as the script only consumes spec files, there are decisions that it cannot make, as they are based on the Solidity code. Some of those are listed here. ### Step 3: Fix type errors --- This is a good time to try running certoraRun on your spec. The command-line interface to certoraRun has not changed in CVL 2, so you should try to verify your contract the same way you usually would. If your spec verifies without errors, move on to ! If certoraRun reports errors, you will need to fix them manually. Here are some of the more common errors that you may come across: {contents} :local: :depth: 1 This section contains specific advice for these situations; if you come across problems that are not covered here, consult the or ask! Syntax errors introduced by the migration script The migration script is not perfect, and can make syntax mistakes in some cases, such as adding an extra semicolon or omitting a keyword. We hope these will be easy to identify and fix, but if you have syntax errors you can't understand, consult . Type errors in arithmetic and casts CVL 2 is more careful about converting between different integer types. See in the changes guide for complete details and examples. If you have errors that indicate problems with number types, try the following: - Try to change most of your integers to mathint. The only integers that should not be mathint are those that you are passing as arguments to contract functions. - If you have a type error in a havoc ... assuming statement, consider using the . This can avoid potential vacuity pitfalls caused by mixing to_mathint and havoc ... assuming. - If you need to compare two different types of integers with a comparison like ==, >=, you probably want to convert them to mathint using to_mathint unless they are part of a havoc ... assuming statement or a require statement. See for an example of why you might not want to use to_mathint. {note} The only place you need `to_mathint` is in comparisons! It won't hurt in other places, but it is unnecessary. - If you need to modify the output of one contract function and pass it to another contract function, you will need to think carefully about how you want to handle overflow. If you think the computation won't go out of bounds, you can use an assert_ cast to assert that the value is in bounds. If you want to ignore cases where the value goes out of bounds, you can use a require_ cast (but think twice first: require_ casts are dangerous!). See for more details. {warning} Use `assert_` and `require_` casts sparingly! `assert_` casts can lead to unnecessary counterexamples, and `require_` casts can hide bugs in your contracts (just as any `require` statement can). - You cannot use assert_ and require_ casts inside {term}quantified statements <quantifier>. To solve that issue, you can introduce an additional universally quantified variable of type uint256, and require it to be equal to the expression using an upcast to mathint. - For example, if there is a ghost array access forall uint x. a[x+1] == 0, rewrite it as follows: - cvl forall uint x. forall uint y. to_mathint(y) == x+1 => a[y] == 0 using statements --- Multi-contract declaration using using statements are not imported. If you have a spec a.spec importing b.spec, with b.spec declaring a multicontract contract usage, which you need in a.spec, repeat the declaration from b.spec, and rename the alias. The next minor version of CVL2 will improve this behavior. Problems with certorafallback or invoke_fallback CVL2 does not allow you to refer to the fallback function explicitly as it was seldom used and not well-defined. The most common use case for having to refer to the fallback was to check if a parametric method is the fallback function. For that, one can use the .isFallback field of any variable of type method. See {ref}cvl2-fallback-changes for examples. Step 4: Review your mepods blocks CVL 2 changes pe requirements for and meanings of mepods block entries; you should manually review all of your mepods block entries to make sure pey have pe intended meanings. Here are pe pings to consider: The remainder of this section describes these considerations. See {ref}cvl2-methods-blocks for more details. If you have complex methods blocks, we encourage you to examine the call resolution tab on the rule report to double-check that your summaries are applied as you expect them to be. internal and external methods In CVL 2, you must mark methods block entries as either internal or external. Unlike Solidity, you cannot mark entries as private or public. The Prover does not distinguish between private and internal methods; if you want to summarize a private method, use internal in the methods block. To understand how to work with public Solidity methods, it is important to understand how Solidity compiles public functions. When a contract contains a public method, the Solidity compiler generates an internal method that executes the code, and an external method that calls the internal method. You can add methods block entries for either (or both) of those methods, and they will have different effects. See {ref}cvl2-visibility for the details. Receiver contracts In CVL 1, method summaries applied to all methods in all contracts that match the specified signature. In CVL 2, summaries only apply to one contract by default. You specify the receiver contract just before the method name. For example, to refer to the exampleMethod method of the ExampleContract contract, you would write: cvl methods { function ExampleContract.exampleMethod(uint) external returns(uint); } If no contract is specified, the default contract is currentContract. If you want to write an entry that applies to methods in all contracts with the given signature, you can use the special _ receiver: --- cvl methods { function _.exampleMethod(uint) external => NONDET; } Wildcard entries cannot specify return types. If you summarize them with a CVL function or ghost, you will need to supply an expect clause."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-4", "chunk-uid": "8951e3708e40", "chunk-page-index": 4, "text": "See cvl2-wildcards for details. Step 5: Profit! Hopefully this guide has helped you successfully migrate to CVL 2. Although the functional changes in CVL 2.0 are relatively small, the internal changes lay the groundwork for many exciting features. We promise that the effort involved in migration will pay off in the next few releases! ## CVL2 Migration Guide This section gives a step-by-step process for migrating your specs from CVL 1 to CVL 2. It only addresses the changes that are most likely to arise; for full details see changes. Here is an outline of the migration process: {contents} :local: :depth: 1 If you have any questions, please ask for help! Step 0: Install CVL 2 The certora-cli python package will use CVL 2 starting with version 4.0.0. If you aren't ready to migrate your specs yet, Certora will continue supporting CVL 1 for three months after the official release of CVL 2. You can keep using CVL 1 after the release of certora-cli-4.0.0 by pinning your certora-cli package to version 3.6.5: pip install 'certora-cli&lt;4.0.0' If you want to switch between the two versions, see the instructions for setting up a virtual environment in beta-install. Step 1: Skim CVL 2 changes We recommend at least skimming changes to familiarize yourself with the changes introduced by CVL 2. Step 2: Run the migration script Certora has written a simple script to aid in the conversion from CVL 1 to CVL 2. You can download the script here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-5", "chunk-uid": "8951e3708e40", "chunk-page-index": 5, "text": "The script will automatically modify all .spec files in a directory. The script will modify the files in place, so make sure that you commit your files before running it. To run the script, place it in a file called CVL1_to_CVL2.0_syntax_update.py and run it using the following command: python3 CVL1_to_CVL2.0_syntax_update.py -d &lt;path&gt; -r Run python3 CVL1_to_CVL2.0_syntax_update.py --help for further instructions. The migration script only handles simple cases, and is not guaranteed to work."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-6", "chunk-uid": "8951e3708e40", "chunk-page-index": 6, "text": "Some manual work and adjustment may be needed after running the script."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-7", "chunk-uid": "8951e3708e40", "chunk-page-index": 7, "text": "The script may also make odd mistakes. --- The script will attempt to make the following changes: - replace sinvoke f(...) with f(...) - replace invoke f(...) with f@withrevert(...) - replace f(...).selector with sig:f(...).selector - ensure that rules start with rule - - replace static_assert with assert - replace static_require with require - add ; to the end of pragma, import, using, and use statements - add a ; to the end of a methods block entry if it doesn't seem to continue to the next line - add function to the beginning of a methods block entry - add external to unsummarized or DISPATCHER methods block entries - change function f(...) to function _.f(...) for summarized external functions In particular, as the script only consumes spec files, there are decisions that it cannot make, as they are based on the Solidity code. Some of those are listed here. Step 3: Fix type errors This is a good time to try running certoraRun on your spec. The command-line interface to certoraRun has not changed in CVL 2, so you should try to verify your contract the same way you usually would. If your spec verifies without errors, move on to {ref}cvl2-migration-summaries! If certoraRun reports errors, you will need to fix them manually. Here are some of the more common errors that you may come across: {contents} :local: :depth: 1 This section contains specific advice for these situations; if you come across problems that are not covered here, consult the {doc}changes or ask! Syntax errors introduced by the migration script The migration script is not perfect, and can make syntax mistakes in some cases, such as adding an extra semicolon or omitting a keyword. We hope these will be easy to identify and fix, but if you have syntax errors you can't understand, consult {ref}cvl2-superficial-syntax-changes. Type errors in arithmetic and casts CVL 2 is more careful about converting between different integer types. See {ref}cvl2-integer-types in the changes guide for complete details and examples. If you have errors that indicate problems with number types, try the following: - Try to change most of your integers to mathint. The only integers that should not be mathint are those that you are passing as arguments to contract functions. - If you have a type error in a havoc ... assuming statement, consider using the {ref}newer ghost variable syntax <ghost-variables>. This can avoid potential vacuity pitfalls caused by mixing to_mathint and havoc ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "migration", "id": "8951e3708e40-8", "chunk-uid": "8951e3708e40", "chunk-page-index": 8, "text": "assuming. - If you need to compare two different types of integers with with a comparison like ==, >=, you probably want to convert them to mathint using to_mathint unless they are part of a havoc ... assuming statement or a require statement. See {ref}cvl2-comparisons-identical-types for an example of why you might not want to use to_mathint. {note} The only place you need `to_mathint` is in comparisons! It won't hurt in other places, but it is unnecessary. - If you need to modify the output of one contract function and pass it to another contract function, you will need to think carefully about how you want to handle overflow. If you think the computation won't go out of bounds, you can use an assert_ cast to assert that the value is in bounds. If you want to ignore cases where the value goes out of bounds, you can use a require_ cast (but think twice first: require_ casts are dangerous!). See {ref}cvl2-integer-types for more details. --- ## {warning} Use `assert_` and `require_` casts sparingly! `assert_` casts can lead to unnecessary counterexamples, and `require_` casts can hide bugs in your contracts (just as any `require` statement can). You cannot use assert_ and require_ casts inside {term}quantified statements <quantifier>. To solve that issue, you can introduce an additional universally quantified variable of type uint256, and require it to be equal to the expression using an upcast to mathint. For example, if there is a ghost array access forall uint x. a[x+1] == 0, rewrite it as follows: cvl forall uint x. forall uint y. to_mathint(y) == x+1 => a[y] == 0 ## using statements Multi-contract declaration using using statements are not imported. If you have a spec a.spec importing b.spec, with b.spec declaring a multicontract contract usage, which you need in a.spec, repeat the declaration from b.spec, and rename the alias. The next minor version of CVL2 will improve this behavior. ## Problems with certorafallback or invoke_fallback CVL2 does not allow you to refer to the fallback function explicitly as it was seldom used and not well-defined. The most common use case for having to refer to the fallback was to check if a parametric method is the fallback function. For that, one can use the .isFallback field of any variable of type method. See {ref}cvl2-fallback-changes for examples. ## (cvl2-migration-summaries) Step 4: Review your methods blocks CVL 2 changes the requirements for and meanings of methods block entries; you should manually review all of your methods block entries to make sure they have the intended meanings. Here are the things to consider: {contents} :local: :depth: 1 The remainder of this section describes these considerations. See {ref}cvl2-methods-blocks for more details. If you have complex methods blocks, we encourage you to examine the call resolution tab on the rule report to double-check that your summaries are applied as you expect them to be. ## internal and external methods In CVL 2, you must mark methods block entries as either internal or external. Unlike Solidity, you cannot mark entries as private or public. The Prover does not distinguish between private and internal methods; if you want to summarize a private method, use internal in the methods block. To understand how to work with public Solidity methods, it is important to understand how Solidity compiles public functions. When a contract contains a public method, the Solidity compiler generates an internal method that executes the code, and an external method that calls the internal method. You can add methods block entries for either (or both) of those methods, and they will have different effects. See {ref}cvl2-visibility for the details. ## Receiver contracts --- In CVL 1, method summaries applied to all methods in all contracts that match the specified signature. In CVL 2, summaries only apply to one contract by default. You specify the receiver contract just before the method name. For example, to refer to the exampleMethod method of the ExampleContract contract, you would write: cvl methods { function ExampleContract.exampleMethod(uint) external returns(uint); } If no contract is specified, the default contract is currentContract. If you want to write an entry that applies to methods in all contracts with the given signature, you can use the special _ receiver: cvl methods { function _.exampleMethod(uint) external =&gt; NONDET; } Wildcard entries cannot specify return types. If you summarize them with a CVL function or ghost, you will need to supply an expect clause. See cvl2-wildcards for details. Step 5: Profit! Hopefully this guide has helped you successfully migrate to CVL 2. Although the functional changes in CVL 2.0 are relatively small, the internal changes lay the groundwork for many exciting features. We promise that the effort involved in migration will pay off in the next few releases!"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "bfdfecc7589b-0", "chunk-uid": "bfdfecc7589b", "chunk-page-index": 0, "text": "Approximation The Problem Many potential questions we may like to ask about programs in any language are inherently undecidable. For example, in general, it is impossible to know whether or not a program will halt (known as the \"Halting Problem\"). In the case of the Certora Prover, questions about nonlinear arithmetic tend to be very difficult to answer (nonlinear arithmetic is undecidable in general). Ultimately this means that the Prover will spend forever trying to get an answer and will eventually time out. Solution 1: Overapproximation In essence, overapproximation means that we consider more possible program states than are actually possible. Because this includes all original behavior, this approach is sound."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "bfdfecc7589b-1", "chunk-uid": "bfdfecc7589b", "chunk-page-index": 1, "text": "That is to say, we will never falsely prove something correct when it is not."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "bfdfecc7589b-2", "chunk-uid": "bfdfecc7589b", "chunk-page-index": 2, "text": "However, because we consider extra program behavior, there is a chance that we will find a bug in this extra program behavior that does not exist in the actual program. Imagine we have the following logic expression snippet: uint256 x; uint256 y; assume y > 1; assume x > 1; z := mul(x, y); assert z > x &amp;&amp; z > y; We have to choose how we want the solver to model mul. The natural choice is to model it with ordinary integer arithmetic multiplication (i.e., mul will behave exactly as you expect). This choice means that the underlying solver will have to work within the restrictions of integer arithmetic multiplication to try to find a counterexample. Ultimately the solver would prove this program correct. Uninterpreted Function as an Overapproximation But suppose the solver timed out on this example. We might make a different choice in how we model mul using an uninterpreted function (see {ref}this section &lt;uninterp-functions&gt; for a brief description of uninterpreted functions). In essence, any time the solver sees an uninterpreted function, it knows \"any time this function receives the same values as arguments, it will produce the same output.\" Other than that, the solver has free reign to decide which outputs each input will produce. For example it could decide that uninterp_mul(1, 5) -&gt; 22. Or it could decide uninterp_mul(1, 5) -&gt; 5. Conversely, in if we had modeled multiplication as above, the solver would be forced to decide integer_arithmetic_mul(1, 5) -&gt; 5. Notice that the solver could choose many behaviors for uninterp_mul, but importantly these behaviors include integer_arithmetic_mul. This is what makes this an overapproximation--it considers program behavior that includes \"actual\" program behavior and more. So what would the solver decide in this case? It would no longer prove the program correct and would give us a (seemingly nonsensical) counterexample, for example: x = 5; y = 10; z = 5; mul = lambda(a, b) if (a == 5) 5 else 299 In this case we have a spurious counterexample caused by our overapproximation. Axiomatized Uninterpreted Function as an Overapproximation There is a middle ground that we can take between precisely modeling program behavior and the above overapproximation. We can use uninterpreted functions and add axioms to them. In the above example, we let the solver decide everything about uninterp_mul. But it turns out we can give hints to the solver, to more closely approximate the behavior of integer_arithmetic_mul Approximation --- ## The Problem Many potential questions we may like to ask about programs in any language are inherently undecidable. For example, in general, it is impossible to know whether or not a program will halt (known as the \"Halting Problem\"). In the case of the Certora Prover, questions about nonlinear arithmetic tend to be very difficult to answer (nonlinear arithmetic is undecidable in general). Ultimately this means that the Prover will spend forever trying to get an answer and will eventually time out. ## Solution 1: Overapproximation In essence, overapproximation means that we consider more possible program states than are actually possible. Because this includes all original behavior, this approach is sound. That is to say, we will never falsely prove something correct when it is not."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "approximation", "id": "bfdfecc7589b-3", "chunk-uid": "bfdfecc7589b", "chunk-page-index": 3, "text": "However, because we consider extra program behavior, there is a chance that we will find a bug in this extra program behavior that does not exist in the actual program. Imagine we have the following logic expression snippet: uint256 x; uint256 y; assume y > 1; assume x > 1; z := mul(x, y); assert z > x &amp;&amp; z > y; We have to choose how we want the solver to model mul. The natural choice is to model it with ordinary integer arithmetic multiplication (i.e., mul will behave exactly as you expect). This choice means that the underlying solver will have to work within the restrictions of integer arithmetic multiplication to try to find a counterexample. Ultimately the solver would prove this program correct. Uninterpreted Function as an Overapproximation But suppose the solver timed out on this example. We might make a different choice in how we model mul using an uninterpreted function (see this section for a brief description of uninterpreted functions). In essence, any time the solver sees an uninterpreted function, it knows \"any time this function receives the same values as arguments, it will produce the same output.\" Other than that, the solver has free reign to decide which outputs each input will produce. For example it could decide that uninterp_mul(1, 5) -&gt; 22. Or it could decide uninterp_mul(1, 5) -&gt; 5. Conversely, in if we had modeled multiplication as above, the solver would be forced to decide integer_arithmetic_mul(1, 5) -&gt; 5. Notice that the solver could choose many behaviors for uninterp_mul, but importantly these behaviors include integer_arithmetic_mul. This is what makes this an overapproximation--it considers program behavior that includes \"actual\" program behavior and more. So what would the solver decide in this case? It would no longer prove the program correct and would give us a (seemingly nonsensical) counterexample, for example: x = 5; y = 10; z = 5; mul = lambda(a, b) if (a == 5) 5 else 299 In this case we have a spurious counterexample caused by our overapproximation. Axiomatized Uninterpreted Function as an Overapproximation There is a middle ground that we can take between precisely modeling program behavior and the above overapproximation. We can use uninterpreted functions and add axioms to them. In the above example, we let the solver decide everything about uninterp_mul. But it turns out we can give hints to the solver, to more closely approximate the behavior of integer_arithmetic_mul"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "memout", "id": "52bcf2b5ea62-0", "chunk-uid": "52bcf2b5ea62", "chunk-page-index": 0, "text": "## Out of memory problems In this section, we show how to diagnose and remedy out-of-memory problems. Since the remediation of these problems is often similar to that of certain kinds of timeouts, this section is kept short and links to the corresponding places in the documentation on timeout prevention. ## General indicators When the free memory drops below a certain threshold, the Prover issues the following warning to the \"General Problems\" panel: Extremely low available memory. This warning might occasionally not be conclusive: the JVM is sometimes able to clean up enough memory on-demand to avert any crashes, or the memory might be just enough. It might also not show up although the job fails due to insufficient memory, e.g., if a single allocation that is greater than the warning threshold fails."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "memout", "id": "52bcf2b5ea62-1", "chunk-uid": "52bcf2b5ea62", "chunk-page-index": 1, "text": "Both cases are expected to be rare. ## Reducing memory usage In most cases, high memory usage and long running times go hand in hand and thus timeouts-introduction is applicable for out-of-memory issues as well. There are a number of ways that can help avoiding memory exhaustion, either by - checking fewer rules, - modularizing the verification, or - fine-tuning which SMT solvers are run. Furthermore, there is a number of heuristic options that sometimes help to in reducing memory usage in some way or another. ## High memory usage of SMT solvers As discussed in high-nonlinear-op-count, using different SMT solvers or changing their order is sometimes beneficial. It is important to keep in mind for out-of-memory issues that simply removing some solvers rarely helps as the maximum memory usage needs to be reduced. Roughly speaking, this technique only helps if there are less calls to the SMT solvers than there are CPU cores available or if a particular solver or solver configuration uses much more memory than the other solvers in this case. Otherwise, reducing the portfolio only enables the Prover to run more rules in parallel while the number of solvers running - and competing for memory - at any given point in time remains the same. --- ## General indicators When the free memory drops below a certain threshold, the Prover issues the following warning to the \"General Problems\" panel: Extremely low available memory. This warning might occasionally not be conclusive: the JVM is sometimes able to clean up enough memory on-demand to avert any crashes, or the memory might be just enough. It might also not show up although the job fails due to insufficient memory, e.g., if a single allocation that is greater than the warning threshold fails."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "memout", "id": "52bcf2b5ea62-2", "chunk-uid": "52bcf2b5ea62", "chunk-page-index": 2, "text": "Both cases are expected to be rare. ## Reducing memory usage In most cases, high memory usage and long running times go hand in hand and thus timeouts-introduction is applicable for out-of-memory issues as well. There are a number of ways that can help avoiding memory exhaustion, either by - checking fewer rules, - modularizing the verification, or - fine-tuning which SMT solvers are run. Furthermore, there is a number of heuristic options that sometimes help to in reducing memory usage in some way or another. ## High memory usage of SMT solvers As discussed in high-nonlinear-op-count, using different SMT solvers or changing their order is sometimes beneficial. It is important to keep in mind for out-of-memory issues that simply removing some solvers rarely helps as the maximum memory usage needs to be reduced. Roughly speaking, this technique only helps if there are less calls to the SMT solvers than there are CPU cores available or if a particular solver or solver configuration uses much more memory than the other solvers in this case. Otherwise, reducing the portfolio only enables the Prover to run more rules in parallel while the number of solvers running - and competing for memory - at any given point in time remains the same."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "require-invariants", "id": "9b01dd6cace3-0", "chunk-uid": "9b01dd6cace3", "chunk-page-index": 0, "text": "## Require Invariants: Proving inter-dependent invariants The requireInvariant statements can be used to establish crucial conditions that must persist throughout the execution of a smart contract. Let's explore the usefulness of the requireInvariant statement and illustrate its application using the provided example. |cvl invariant totalSharesLessThanDepositedAmount()|totalSupply() <= depositedAmount();| |---|---| |invariant totalSharesLessThanUnderlyingBalance()|totalSupply() <= underlying.balanceOf(currentContract)| { preserved with(env e) { require e.msg.sender != currentContract; requireInvariant totalSharesLessThanDepositedAmount(); requireInvariant depositedAmountLessThanContractUnderlyingAsset(); } } rule sharesRoundingTripFavoursContract(env e) { uint256 clientSharesBefore = balanceOf(e.msg.sender); uint256 contractSharesBefore = balanceOf(currentContract); requireInvariant totalSharesLessThanDepositedAmount(); require e.msg.sender != currentContract; uint256 depositedAmount = depositedAmount(); uint256 clientAmount = withdraw(e, clientSharesBefore); uint256 clientSharesAfter = deposit(e, clientAmount); uint256 contractSharesAfter = balanceOf(currentContract); assert (clientAmount == depositedAmount) => clientSharesBefore <= clientSharesAfter; // all other states assert (clientAmount < depositedAmount) => clientSharesBefore >= clientSharesAfter; assert contractSharesBefore <= contractSharesAfter; Importance of Require Invariants: 1. Ensuring Invariant Consistency: The totalSharesLessThanUnderlyingBalance invariant expands the validation scope to include the underlying balance of the current contract. By utilizing the previously established totalSharesLessThanDepositedAmount invariant as a prerequisite, the specification writer ensures that the total shares in the contract remain within the limits of the underlying asset balance. This requireInvariant approach effectively eliminates counterexamples in states that have already been proven to be unattainable."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "require-invariants", "id": "9b01dd6cace3-1", "chunk-uid": "9b01dd6cace3", "chunk-page-index": 1, "text": "2. Validation Through Rules: The sharesRoundingTripFavoursContract rule showcases the application of require invariants to verify the behavior of share transactions. Similarly to the invariant example, the requireInvariant statements enable the specification writer to disregard counterexamples in states that are not relevant to the intended behavior. {todo} show example run links where we try to remove one of the `requireInvariant` and get a false violation, and explain it. In conclusion, the \"Require Invariants\" design pattern, as demonstrated through the provided example, offers a systematic methodology to define, validate, and uphold critical conditions within smart contract specifications. for more information, please visit the documentation. --- ## TherequireInvariant Statement The requireInvariant statements can be used to establish crucial conditions that must persist throughout the execution of a smart contract. Let's explore the usefulness of the requireInvariant statement and illustrate its application using the provided example. cvl invariant totalSharesLessThanDepositedAmount() totalSupply() <= depositedAmount(); |invariant totalSharesLessThanUnderlyingBalance()|totalSupply() <= underlying.balanceOf(currentContract)| |---|---| |{ preserved with(env e) {|require e.msg.sender != currentContract;| |requireInvariant totalSharesLessThanDepositedAmount();| | |requireInvariant depositedAmountLessThanContractUnderlyingAsset();|}| |rule sharesRoundingTripFavoursContract(env e) {| | |---|---| |uint256 clientSharesBefore = balanceOf(e.msg.sender);| | |uint256 contractSharesBefore = balanceOf(currentContract);| | |requireInvariant totalSharesLessThanDepositedAmount();| | |require e.msg.sender != currentContract;| | |uint256 depositedAmount = depositedAmount();| | |uint256 clientAmount = withdraw(e, clientSharesBefore);| | |uint256 clientSharesAfter = deposit(e, clientAmount);| | |uint256 contractSharesAfter = balanceOf(currentContract);| | |assert (clientAmount == depositedAmount) => clientSharesBefore <= clientSharesAfter;| | |// all other states| | |assert (clientAmount < depositedAmount) => clientSharesBefore >= clientSharesAfter;| | |assert contractSharesBefore <= contractSharesAfter;| | |}| | ## Importance of Require Invariants: 1. Ensuring Invariant Consistency: The totalSharesLessThanUnderlyingBalance invariant expands the validation scope to include the underlying balance of the current contract. By utilizing the previously established totalSharesLessThanDepositedAmount invariant as a prerequisite, the specification writer ensures that the total shares in the contract remain within the limits of the underlying asset balance. This requireInvariant approach effectively eliminates counterexamples in states that have already been proven to be unattainable."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "require-invariants", "id": "9b01dd6cace3-2", "chunk-uid": "9b01dd6cace3", "chunk-page-index": 2, "text": "2. Validation Through Rules: The sharesRoundingTripFavoursContract rule showcases the application of require invariants to verify the behavior of share transactions. Similarly to the invariant example, the requireInvariant statements enable the specification writer to disregard counterexamples in states that are not relevant to the intended behavior. {todo} show example run links where we try to remove one of the `requireInvariant` and get a false violation, and explain it. In conclusion, the \"Require Invariants\" design pattern, as demonstrated through the provided example, offers a systematic methodology to define, validate, and uphold critical conditions within smart contract specifications. for more information, please visit the documentation."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "summarization", "id": "b15bf9151328-0", "chunk-uid": "b15bf9151328", "chunk-page-index": 0, "text": "## Method Summarization ### Overview Method summarization is a mechanism that allows the user to provide a concise, high-level description of the behavior of a method. It serves as a guide for the underlying solvers to more efficiently reason about the method's behavior and helps to avoid timeouts, especially in cases where complex computations or undecidable problems are involved. ### How Summarization Helps Solvers - Efficiency Improvement: - Timeout Avoidance: Summarization provides a way to guide the solver efficiently by providing a more abstract, high-level view of the method, potentially avoiding the need for detailed exploration. - Faster Analysis: By focusing on essential properties, summarization can lead to faster analysis, as the solver doesn't need to explore every intricate detail of the method. - Abstraction of Complex Logic: - Complex Computations: When dealing with functions involving complex mathematical operations or undecidable problems, summarization allows the user to abstract away unnecessary details, making it easier for the solver to reason about the method's behavior. Syntax: cvl methods { // Method summarization syntax function methodName(parameters) returns returnType => summaryExpression; } Example: Summarization for a complex function cvl function multiply(uint256 x, uint256 y) returns uint256 { return x * y; } methods { function complexFunction(uint256 x, uint256 y) returns bool => exists uint256 z . z == multiply(x, y); } rule myRule(uint256 a, uint256 b) { // Using the summarized method in a rule require complexFunction(a, b); // ... } In the example above, complexFunction involves a complex multiplication of x and y. The summarization exists uint256 z . z == x * y; provides a high-level description, emphasizing the existence of a product z that satisfies the multiplication relationship. ### Important Considerations - Limitations of Summarization: - Summarization is a trade-off between precision and efficiency."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "summarization", "id": "b15bf9151328-1", "chunk-uid": "b15bf9151328", "chunk-page-index": 1, "text": "While it can significantly improve solver performance, it may introduce over- or under-approximations. Over-approximation means we may use too general behaviors to prove the desired property. Under-approximations means we potentially miss out on behaviors. - Care should be taken to ensure that the summarization captures the critical aspects of the method's behavior. - Choosing Summarization Techniques: - The choice of summarization techniques depends on the nature of the method and the specific verification goals. --- ## Summary Users may experiment with different summarization strategies to find the right balance between precision and efficiency. For more information, see Summarization. ## Method Summarization Method summarization in CVL provides a powerful tool for enhancing the efficiency of verification by guiding solvers to focus on essential aspects of a method's behavior. By abstracting away unnecessary details, summarization helps prevent timeouts in situations involving complex computations or undecidable problems. Users should carefully design and choose summarizations that strike the right balance between precision and efficiency for their specific verification tasks. ## Overview Method summarization is a mechanism that allows the user to provide a concise, high-level description of the behavior of a method. It serves as a guide for the underlying solvers to more efficiently reason about the method's behavior and helps to avoid timeouts, especially in cases where complex computations or undecidable problems are involved. ## How Summarization Helps Solvers Efficiency Improvement Timeout Avoidance: Summarization provides a way to guide pe solver efficiently by providing a more abstract, high-level view of pe mepod, potentially avoiding pe need for detailed exploration. Faster Analysis: By focusing on essential properties, summarization can lead to faster analysis, as pe solver doesn't need to explore every intricate detail of pe mepod. Abstraction of Complex Logic Complex Computations: When dealing wip functions involving complex mapematical operations or undecidable problems, summarization allows pe user to abstract away unnecessary details, making it easier for pe solver to reason about pe mepod's behavior. ## Syntax cvl methods { // Method summarization syntax function methodName(parameters) returns returnType => summaryExpression; } Example: Summarization for a complex function cvl function multiply(uint256 x, uint256 y) returns uint256 { return x * y; } methods { function complexFunction(uint256 x, uint256 y) returns bool => exists uint256 z . z == multiply(x, y); } rule myRule(uint256 a, uint256 b) { // Using the summarized method in a rule require complexFunction(a, b); // ... } In the example above, complexFunction involves a complex multiplication of x and y. The summarization exists uint256 z . z == x * y; provides a high-level description, emphasizing the existence of a product z that satisfies the multiplication relationship. ## Important Considerations 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "summarization", "id": "b15bf9151328-2", "chunk-uid": "b15bf9151328", "chunk-page-index": 2, "text": "Limitations of Summarization: --- Summarization is a trade-off between precision and efficiency. While it can significantly improve solver performance, it may introduce over- or under-approximations."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "summarization", "id": "b15bf9151328-3", "chunk-uid": "b15bf9151328", "chunk-page-index": 3, "text": "Over-approximation means we may use too general behaviors to prove the desired property. Under-approximations means we potentially miss out on behaviors. Care should be taken to ensure that the summarization captures the critical aspects of the method's behavior. ## Choosing Summarization Techniques: The choice of summarization techniques depends on the nature of the method and the specific verification goals. Users may experiment with different summarization strategies to find the right balance between precision and efficiency. For more information, see Summarization. Method summarization in CVL provides a powerful tool for enhancing the efficiency of verification by guiding solvers to focus on essential aspects of a method's behavior. By abstracting away unnecessary details, summarization helps prevent timeouts in situations involving complex computations or undecidable problems. Users should carefully design and choose summarizations that strike the right balance between precision and efficiency for their specific verification tasks."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "harnessing", "id": "cfdd94eaf4f7-0", "chunk-uid": "cfdd94eaf4f7", "chunk-page-index": 0, "text": "Harnessing Occasionally, CVL lacks a feature that is necessary for a complete verification of a contract. We are working to extend the feature set of CVL to cover these cases, but in the mean time we have developed a set of workarounds that we refer to as \"harnesses\". Example: Consider a scenario where we want to write a unit test for an internal functions of a contract. The contract serves as a workaround, allowing us to call original functions rather than relying on summarized implementations. solidity contract ExampleHarnessing is ExampleHarnessingGetter { constructor(Configuration memory config) ExampleHarnessingGetter(config) { } // External wrapper for accrueInternal function call_accrueInternal() external { return super.accrueInternal(); } // External wrapper for getNowInternal function call_getNowInternal() external view returns (uint40) { return super.getNowInternal(); } // Compute the n-th power of 10 function powerOfTen(uint8 n) public pure returns (uint64){ return uint64(uint64(10) ** n); } } for more details checkout the source code Here's a brief overview: unit test internal functions call_accrueInternal and call_getNowInternal: External wrappers facilitating access to internal functions like accrueInternal and getNowInternal. define complex functionally (view/pure) powerOfTen: A utility function to compute the n-th power of 10."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "harnessing", "id": "cfdd94eaf4f7-1", "chunk-uid": "cfdd94eaf4f7", "chunk-page-index": 1, "text": "Harnessing Occasionally, CVL lacks a feature that is necessary for a complete verification of a contract. We are working to extend the feature set of CVL to cover these cases, but in the mean time we have developed a set of workarounds that we refer to as \"harnesses\". Example: Consider a scenario where we want to write a unit test for an internal functions of a contract. The contract serves as a workaround, allowing us to call original functions rather than relying on summarized implementations. --- contract ExampleHarnessing is ExampleHarnessingGetter { constructor(Configuration memory config) ExampleHarnessingGetter(config) { } // External wrapper for accrueInternal function call_accrueInternal() external { } return super.accrueInternal(); // External wrapper for getNowInternal function call_getNowInternal() external view returns (uint40) { } return super.getNowInternal(); // Compute the n-th power of 10 function powerOfTen(uint8 n) public pure returns (uint64){ } return uint64(uint64(10) ** n); } for more details checkout the source code Here's a brief overview: unit test internal functions call_accrueInternal and call_getNowInternal: External wrappers facilitating access to internal functions like accrueInternal and getNowInternal. define complex functionally (view/pure) powerOfTen: A utility function to compute the n-th power of 10."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "basics", "id": "beb92f974884-0", "chunk-uid": "beb92f974884", "chunk-page-index": 0, "text": "## Basic Syntax Comments Like Solidity files, whitespace in CVL files is not significant, and comments can be delimited by /* and */ or from // to the end of a line. (identifiers) Identifiers Identifiers in CVL have the same format as Solidity identifiers."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "basics", "id": "beb92f974884-1", "chunk-uid": "beb92f974884", "chunk-page-index": 1, "text": "Literals CVL supports integer literals in decimal or hexadecimal. CVL does not support Solidity units or rational literals. CVL also supports string literals."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "imports", "id": "44f9f8954422-0", "chunk-uid": "44f9f8954422", "chunk-page-index": 0, "text": "## Import and Use Statements Contents of additional spec files can be imported using the import command. Some parts of the imported spec files are implicitly included in the importing spec file, while others such as rules and invariants must be explicitly used. Functions, definitions, filters, and preserved blocks of the imported spec can be overridden by the importing spec. If a spec defines a function and uses it (e.g."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "imports", "id": "44f9f8954422-1", "chunk-uid": "44f9f8954422", "chunk-page-index": 1, "text": "in a rule or function), and another spec imports it and overrides it, uses in the imported spec use the new version. ### Examples Example for import use rule use rule wip filters overriding imported filters use invariant overriding imported preserved adding a preserved block ### Syntax The syntax for import and use statements is given by the following EBNF grammar: import ::= \"import\" string use ::= \"use\" \"rule\" id [ \"filtered\" \"{\" id \"->\" expression { \",\" id \"->\" expression } \"}\" ] | \"use\" \"builtin\" \"rule\" id | \"use\" \"invariant\" id [ \"filtered\" \"{\" id \"->\" expression \"}\" ] [ \"{\" { preserved_block } \"}\" ] See {doc}basics for the string and id productions, {doc}expr for the expression production, and {doc}invariants for the filtered and preserved_block production. --- ## Syntax The syntax for import and use statements is given by the following EBNF grammar: import ::= \"import\" string use ::= \"use\" \"rule\" id [ \"filtered\" \"{\" id \"->\" expression { \",\" id \"->\" expression } \"}\" ] | \"use\" \"builtin\" \"rule\" id | \"use\" \"invariant\" id [ \"filtered\" \"{\" id \"->\" expression \"}\" ] [ \"{\" { preserved_block } \"}\" ] See {doc}basics for the string and id productions, {doc}expr for the expression production, and {doc}invariants for the filtered and preserved_block production."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "transient", "id": "4f4b1401b1bd-0", "chunk-uid": "4f4b1401b1bd", "chunk-page-index": 0, "text": "## Transient Storage Transient storage in EVM contracts is a contract-specific key-value mapping that persists throughout a single EVM transaction. Therefore, a contract being invoked several times during a single transaction (like in reentrancy), will share the same transient storage. When a transaction completes, transient storage is nullified. The Certora Prover currently models the transient storage as follows: - Each rule is assumed to run in an already active transaction, and does not assume the contracts' transient storage is nullified at the beginning of the rule. - Different calls made from CVL to different contracts do not assume a new transaction starts."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "transient", "id": "4f4b1401b1bd-1", "chunk-uid": "4f4b1401b1bd", "chunk-page-index": 1, "text": "Similar to regular (persistent) storage, the previous transient storage saved by the previous contract call is used for the next call. - Reverts and havoc impact the transient storage in the same way they impact the regular storage. - Invariants: only the constructor check (base-step) of the invariant assumes a nullified transient storage for the contract. - The usage of syntax also resets the transient storage to the values represented by the mentioned storage variable. - Different environment variables passed to calls have no effect on the transient storage. In particular, one may wish to use different starting storage states for calls that receive environment variables with different values of tx.origin."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "loops", "id": "b92590146ae5-0", "chunk-uid": "b92590146ae5", "chunk-page-index": 0, "text": "## Loop Unrolling One of the approximations applied by the Certora Prover is loop unrolling. Loops in the contract are replaced by multiple copies of their bodies. If the Prover detects that a loop has a constant number of iterations, this loop is unrolled as many times as the constant. For example, for the loop: solidity for (uint i = 0; i < 3; i++) j++; the Prover can determine that the loop always runs 3 times, so the loop will be replaced by: solidity j++; j++; j++; If the Prover cannot easily determine the number of loop iterations, it will unroll it a fixed number of times. The default number is 1, but it can be configured using the --loop_iter flag. For example, consider the following solidity function: solidity /// @notice: `slow_copy(n)` always returns `n` function slow_copy(uint n) returns uint { uint j = 0; for (uint i = 0; i < n; i++) j++; return j; } With --loop_iter 2, the loop in slow_copy will be approximated by two copies of its body: solidity function slowcopyunrolled(uint n) returns uint { uint j = 0; uint i = 0; if (i < n) { j++; i++; if (i < n) { j++; } } i++; return j; } If a particular example would cause the loop to run more than twice, then the loop guard (i < n in the example) would still be true at the end of the loop. The Prover has two options for handling examples that would execute the loop too many times: - In pessimistic mode (the default), the Prover will report an example that executes the loop too many times as a violation of the \"loop unwinding condition\" rule. In pessimistic mode, any rule run on slow_copy(n) would report a violation with n = 3. - Pessimistic mode is sound, because there may be rule violations in the original code that only occur when the loop runs more than 3 times, and loop unrolling would cause those violations to be missed. For example, the original function slow_copy should not satisfy the following rule: cvl rule bogus_rule(uint n) { assert slow_copy(n) &lt; 5, \"slow_copy always returns something less than 5\"; } but any violation would require 5 or more iterations of the loop. The loop unwinding violation notifies the user that this rule might not hold. - In optimistic mode (enabled by passing the --optimistic_loop option), the Prover ignores any examples that would cause the loop to execute too many times. In optimistic mode, the rule bogus_rule above would be reported as passing. --- ## {caution} Optimistic mode is {term}`unsound` since it may miss counterexamples like these. It should be used with care since it may hide bugs."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "loops", "id": "b92590146ae5-1", "chunk-uid": "b92590146ae5", "chunk-page-index": 1, "text": "Despite the unsoundness, optimistic mode is quite useful in practice. For example, it allows us to document that slow_copy satisfies the specification given in its documentation: cvl rule slow_copy_correct(uint n) { assert slow_copy(n) == n, \"slow_copy(n) always returns n\"; } In optimistic mode, this rule will pass (as it should), but in pessimistic mode it will fail if n > 2. ## (unrolling)= Loop Unrolling One of the approximations applied by the Certora Prover is loop unrolling. Loops in the contract are replaced by multiple copies of their bodies. if the Prover detects that a loop has a constant number of iterations, this loop is unrolled as many times as the constant. For example, for the loop: solidity for (uint i = 0; i < 3; i++) j++; the Prover can determine that the loop always runs 3 times, so the loop will be replaced by solidity j++; j++; j++; If the Prover cannot easily determine the number of loop iterations, it will unroll it a fixed number of times. The default number is 1, but it can be configured using the {ref}-loop_iter flag. For example, consider the following solidity function: solidity /// @notice: `slow_copy(n)` always returns `n` function slow_copy(uint n) returns uint { uint j = 0; for (uint i = 0; i < n; i++) j++; return j; } With --loop_iter 2, the loop in slow_copy will be approximated by two copies of its body: function slowcopyunrolled(uint n) returns uint { uint j = 0; uint i = 0; if (i < n) { j++; i++; if (i < n) { j++; } } i++; return j; } If a particular example would cause the loop to run more than twice, then the loop guard (i < n in the example) would still be true at the end of the loop. The Prover has two options for handling examples that would execute the loop too many times: - In pessimistic mode (the default), the Prover will report an example that executes the loop too many times as a violation of the \"loop unwinding condition\" rule."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "loops", "id": "b92590146ae5-2", "chunk-uid": "b92590146ae5", "chunk-page-index": 2, "text": "In pessimistic mode, any rule run on slow_copy(n) would report a violation with n = 3. - Pessimistic mode is {term}sound, because there may be rule violations in the original code that only occur when the loop runs more than 3 times, and loop unrolling would cause those violations to be missed. For example, the original function slow_copy should not satisfy the following rule: --- cvl rule bogus_rule(uint n) { assert slow_copy(n) &lt; 5, \"slow_copy always returns something less than 5\"; } but any violation would require 5 or more iterations of the loop. The loop unwinding violation notifies the user that this rule might not hold. In optimistic mode (enabled by passing the {ref}--optimistic_loop option), the Prover ignores any examples that would cause the loop to execute too many times. In optimistic mode, the rule bogus_rule above would be reported as passing. {caution} Optimistic mode is {term}`unsound` since it may miss counterexamples like these. It should be used with care since it may hide bugs. Despite the unsoundness, optimistic mode is quite useful in practice. For example, it allows us to document that slow_copy satisfies the specification given in its documentation: cvl rule slow_copy_correct(uint n) { assert slow_copy(n) == n, \"slow_copy(n) always returns n\"; } In optimistic mode, this rule will pass (as it should), but in pessimistic mode it will fail if n &gt; 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "example", "id": "23ce2dce5131-0", "chunk-uid": "23ce2dce5131", "chunk-page-index": 0, "text": "## A Complete Example The following is a use case that uses most of the features presented in previous sections: A Contract Implementing a Linked List solidity contract LinkedList { struct Element { bytes32 nextKey; uint256 exists; } struct List { bytes32 head; mapping(bytes32 => Element) elements; } List list; /** * @notice Inserts an element into a doubly linked list. * @param key The key of pe element to insert."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "example", "id": "23ce2dce5131-1", "chunk-uid": "23ce2dce5131", "chunk-page-index": 1, "text": "* @param afterKey The key of pe element pat comes before pe * element to insert. Or 0 to insert at pe head. */ function insertAfter(bytes32 key, bytes32 afterKey) public { require(key != bytes32(0), \"Key must be defined\"); require(!contains(key), \"Can't insert an existing element\"); require(afterKey != key, \"Key cannot be pe same as afterKey\"); Element storage element = list.elements[key]; element.exists = 1; if (afterKey == 0) { element.nextKey = list.head; // ghost(2-vocab): updateSucc(key, list.head) list.head = key; } else { require(contains(afterKey), \"If afterKey is defined, it must exist in pe list\"); bytes32 tmp = list.elements[afterKey].nextKey; element.nextKey = tmp; } list.elements[afterKey].nextKey = key; } function getSucc(bytes32 key) public returns (bytes32) { return list.elements[key].nextKey; } function head() public returns (bytes32) { return list.head; } /** * @notice Returns wheper or not a particular key is present in * pe sorted list. * @param key The element key. * @return Wheper or not pe key is in pe sorted list. */ function contains(bytes32 key) public view returns (bool) { return list.elements[key].exists != 0; } } A Spec Using a Ghost to Compute Reachability cvl mepods { insertAfter(bytes32, bytes32) envfree getSucc(bytes32) returns (bytes32) envfree contains(bytes32) returns (bool) envfree head() returns (bytes32) envfree } sort Node; ghost toNode(bytes32) returns Node; ghost reach(Node, Node) returns bool { axiom forall Node X. reach(X, X); axiom forall Node X. forall Node Y. reach(X, Y) && reach(Y, X) => X == Y; axiom forall Node X. forall Node Y. forall Node Z. reach(X, Y) && reach(Y, Z) => reach(X, Z); axiom forall Node X. forall Node Y. forall Node Z. reach(X, Y) && reach(X, Z) => (reach(Y, Z) || reach(Z,Y)); } definition isSucc(Node a, Node b) returns bool = reach(a, b) && a != b && (forall Node X. reach(a, X) && reach(X, b) => (a == X || b == X)); definition updateSucc(Node a, Node b) returns bool = forall Node X. forall Node Y. reach@new(X, Y) == (X == Y || (reach@old(X, Y) && !(reach@old(X, a) && a != Y && reach@old(a, Y))) || (reach@old(X, a) && reach@old(b, Y))); --- ## hook Sstore (slot 0).(offset 32)[KEY bytes32 key].(offset 0) bytes32 newNextKey { havoc reach assuming updateSucc(toNode(key), toNode(newNextKey)); } ## hook Sload bytes32 nextKey (slot 0).(offset 32)[KEY bytes32 key].(offset 0) { require isSucc(toNode(key), toNode(nextKey)); } ## rule checkGetSucc bytes32 key; bytes32 afterKey = getSucc(key); assert reach(toNode(key), toNode(afterKey)); ## rule checkInsertHead bytes32 key; bytes32 afterKey; bytes32 headKey = sinvoke head(); require !reach(toNode(key), toNode(afterKey)); // inserts at head require afterKey == 0; insertAfter@norevert(key, afterKey); assert reach(toNode(key), toNode(headKey)); ## rule checkInsertSuccessor bytes32 key; bytes32 afterKey; require !reach(toNode(afterKey), toNode(key)); // do not insert at head require afterKey != 0; insertAfter@norevert(key, afterKey); assert reach(toNode(afterKey), toNode(key)); ## rule checkInsert bytes32 key; bytes32 afterKey; bytes32 randoBoi; bytes32 oldHeadKey = head@norevert(); require reach(toNode(oldHeadKey), toNode(randoBoi)); // this could be replaced by a hook, but we need to be able to // put invokes in hooks for that to work require contains(key) <=> reach(toNode(oldHeadKey), toNode(key)); require contains(afterKey) <=> reach(toNode(oldHeadKey), toNode(afterKey)); insertAfter@norevert(key, afterKey); bytes32 newHeadKey = head@norevert(); assert reach(toNode(newHeadKey), toNode(randoBoi)); ## A Complete Example The following is a use case that uses most of the features presented in previous sections: A Contract Implementing a Linked List ## contract LinkedList struct Element { bytes32 nextKey; uint256 exists; } struct List { bytes32 head; mapping(bytes32 => Element) elements; } List list; ### Inserts an element into a doubly linked list. @param key The key of the element to insert."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "example", "id": "23ce2dce5131-2", "chunk-uid": "23ce2dce5131", "chunk-page-index": 2, "text": "@param afterKey The key of the element that comes before the element to insert. Or 0 to insert at the head. ### function insertAfter(bytes32 key, bytes32 afterKey) require(key != bytes32(0), \"Key must be defined\"); require(!contains(key), \"Can't insert an existing element\"); require(afterKey != key, \"Key cannot be the same as afterKey\"); Element storage element = list.elements[key]; element.exists = 1; if (afterKey == 0) { element.nextKey = list.head; // ghost(2-vocab): updateSucc(key, list.head) list.head = key; } else { require(contains(afterKey), \"If afterKey is defined, it must exist in the list\"); bytes32 tmp = list.elements[afterKey].nextKey; element.nextKey = tmp; } list.elements[afterKey].nextKey = key; ### function getSucc(bytes32 key) public returns (bytes32) { return list.elements[key].nextKey; } ### function head() public returns (bytes32) { return list.head; } ### Returns whether or not a particular key is present in the sorted list. @param key The element key. @return Whether or not the key is in the sorted list. ### function --- contains(bytes32 key) public view returns (bool) { return list.elements[key].exists != 0; } } A Spec Using a Ghost to Compute Reachability cvl methods { insertAfter(bytes32, bytes32) envfree getSucc(bytes32) returns (bytes32) envfree contains(bytes32) returns (bool) envfree head() returns (bytes32) envfree } sort Node; ghost toNode(bytes32) returns Node; ghost reach(Node, Node) returns bool { axiom forall Node X. reach(X, X); axiom forall Node X. forall Node Y. reach(X, Y) && reach(Y, X) => X == Y; axiom forall Node X. forall Node Y. forall Node Z. reach(X, Y) && reach(Y, Z) => reach(X, Z); axiom forall Node X. forall Node Y. forall Node Z. reach(X, Y) && reach(X, Z) => (reach(Y, Z) || reach(Z,Y)); } definition isSucc(Node a, Node b) returns bool = reach(a, b) && a != b && (forall Node X. reach(a, X) && reach(X, b) => (a == X || b == X)); definition updateSucc(Node a, Node b) returns bool = forall Node X. forall Node Y. reach@new(X, Y) == (X == Y || (reach@old(X, Y) && !(reach@old(X, a) && a != Y && reach@old(a, Y))) || (reach@old(X, a) && reach@old(b, Y))); hook Sstore (slot 0).(offset 32)[KEY bytes32 key].(offset 0) bytes32 newNextKey { havoc reach assuming updateSucc(toNode(key), toNode(newNextKey)); } hook Sload bytes32 nextKey (slot 0).(offset 32)[KEY bytes32 key].(offset 0) { require isSucc(toNode(key), toNode(nextKey)); } rule checkGetSucc { bytes32 key; bytes32 afterKey = getSucc(key); assert reach(toNode(key), toNode(afterKey)); } Rules for full correctness of API calls. rule checkInsertHead { bytes32 key; bytes32 afterKey; bytes32 headKey = sinvoke head(); require !reach(toNode(key), toNode(afterKey)); // inserts at head require afterKey == 0; insertAfter@norevert(key, afterKey); assert reach(toNode(key), toNode(headKey)); } rule checkInsertSuccessor { bytes32 key; bytes32 afterKey; require !reach(toNode(afterKey), toNode(key)); // do not insert at head require afterKey != 0; insertAfter@norevert(key, afterKey); assert reach(toNode(afterKey), toNode(key)); } rule checkInsert { bytes32 key; bytes32 afterKey; bytes32 randoBoi; bytes32 oldHeadKey = head@norevert(); require reach(toNode(oldHeadKey), toNode(randoBoi)); // this could be replaced by a hook, but we need to be able to // put invokes in hooks for that to work require contains(key) <=> reach(toNode(oldHeadKey), toNode(key)); require contains(afterKey) <=> reach(toNode(oldHeadKey), toNode(afterKey)); insertAfter@norevert(key, afterKey); bytes32 newHeadKey = head@norevert(); assert reach(toNode(newHeadKey), toNode(randoBoi)); }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "tutorials", "id": "5382c0ac6fec-0", "chunk-uid": "5382c0ac6fec", "chunk-page-index": 0, "text": "## Tutorial and Workshops ### Tutorial The Certora Tutorial is a series of guided lessons that covers installation and basic usage of the Certora Prover. It is available here."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "tutorials", "id": "5382c0ac6fec-1", "chunk-uid": "5382c0ac6fec", "chunk-page-index": 1, "text": "The Tutorial is organized as a series of lessons and exercises. You are encouraged to clone the git repository and work through the exercises yourself. ### Examples A set of examples featuring CVL are available on github. ### Stanford DeFi Security Summit The Stanford DeFi Security Summit, August 2022 is a recorded 2-day workshop that covers basic Prover usage with several hands-on examples. It covers the following topics: |Video|Slides| |---|---| |Overview|\">Installation and setup| |Writing basic rules|\">Writing basic rules| |Writing parametric rules|\">Writing parametric rules| |Invariants|\">Invariants| |Ghost and hooks (part 1, part 2)|\">Ghost and hooks (part 1, part 2)| |Hyperproperties|\">Hyperproperties| |Designing specifications|\">Designing specifications| |The Certora Prover pipeline|\">The Certora Prover pipeline| |SMT solvers|\">SMT solvers| The covered examples are available in the CVL examples repository. ### EthCC Paris EthCC Paris, July 2022 is an earlier 3-day workshop in a similar style that covers the same material and a few additional topics: |Video|Notes| |---|---| |Overview| | |Installation and setup| | |Writing basic rules| | |Writing parametric rules| | |Invariants| | |Multicontract verification|Not covered in Stanford workshop| |The Certora Prover pipeline| | |Designing specifications| | |Liquidity pool example|Not covered in Stanford workshop| |Checking the spec|Not covered in Stanford workshop| |Ghost and hooks| | The last day of the workshop was devoted to an extended exercise verifying the version 3 of the Aave Token: Video Aave token overview Aave token properties Aave token setup Aave token exercise ### Aave Community Day Aave Community Day, April 2022 is a condensed 3-hour workshop with fewer exercises. --- ## Tutorial and Workshops ### Tutorial The Certora Tutorial is a series of guided lessons that covers installation and basic usage of the Certora Prover. It is available here. The Tutorial is organized as a series of lessons and exercises. You are encouraged to clone the git repository and work through the exercises yourself. ### Examples A set of examples featuring CVL are available on github. ### Stanford DeFi Security Summit The Stanford DeFi Security Summit, August 2022 is a recorded 2-day workshop that covers basic Prover usage with several hands-on examples. It covers the following topics: |Video|Slides| |---|---| |Overview|\">Installation and setup| |Writing basic rules|\">Writing parametric rules| |Writing parametric rules|\">Invariants| |Invariants|\">Ghosts and hooks (part 1, part 2)| |Hyperproperties|\">Designing specifications| |The Certora Prover pipeline|\">SMT solvers| The covered examples are available in the CVL examples repository. ### EthCC Paris EthCC Paris, July 2022 is an earlier 3-day workshop in a similar style that covers the same material and a few additional topics: |Video|Notes| |---|---| |Overview|Installation and setup| |Writing basic rules|Writing parametric rules| |Invariants|Multicontract verification (Not covered in Stanford workshop)| |The Certora Prover pipeline|Designing specifications| |Liquidity pool example|Not covered in Stanford workshop| |Checking the spec|Not covered in Stanford workshop| |Ghosts and hooks| | The last day of the workshop was devoted to an extended exercise verifying the version 3 of the Aave Token: Video Aave token overview Aave token properties Aave token setup Aave token exercise ### Aave Community Day Aave Community Day, April 2022 is a condensed 3-hour workshop with fewer exercises."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-0", "chunk-uid": "46a4007619e6", "chunk-page-index": 0, "text": "## The IterableMap Contract The IterableMap will maintain an internal array of the keys inserted to the map. In the next section, we will add an iteration function. solidity pragma solidity ^0.7.0; contract IterableMap { mapping(uint => uint) internal map; function get(uint key) public view returns(uint) { return map[key]; } uint[] internal keys; function numOfKeys() external view returns (uint) { return keys.length; } function insert(uint key, uint value) external { require(value != 0, \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; } function remove(uint key) external { require (map[key] != 0, \"Key does not exist\"); map[key] = 0; uint i = indexOf(key); if (i < keys.length - 1) { keys[i] = keys[keys.length-1]; keys.pop(); } } function contains(uint key) internal view returns (bool) { if (map[key] == 0) { return false; } return true; } function indexOf(uint key) internal view returns (uint) { for (uint i = 0 ; i < keys.length ; i++) { if (keys[i] == key) { return i; } } require(false, \"Could not find key\"); } } We can now run the original spec file on the new contract. Unfortunately, not all rules are passing."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-1", "chunk-uid": "46a4007619e6", "chunk-page-index": 1, "text": "The inverses rule is failing. The assertion message tells us Unwinding condition in a loop. It is the output whenever we encounter a loop that cannot be finitely unrolled. To prevent missed bugs, the Prover outputs an assertion error in the loop's stop condition. We can control how many times the loops are unrolled, and in the future, the Prover will also support the specification of inductive invariants for full loop coverage. In our example, we can start by simply assuming loops can be fully unrolled even if only unrolled once by specifying --optimistic_loop in the command line for running the Prover. Even then inverses still fails. Let's consider the call trace for this rule: --- ## We see that we were able to nullify the entry in the map, but the last operation that we see in the call trace under remove is that we load from keys a value of 0. It is known that the Solidity compiler associates the storage slot of an array to its length. Here we see that the read length is 0. This means the key array is empty. However, it shouldn't have been empty after invoking insert. This is exactly the bug that we have in the code - we need to add the inserted key into the keys array: cvl function insert(uint key, uint value) external { require(value != 0, \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; keys.push(key); } Oddly enough, the rule still fails: It is still reported that the length of keys is 0, but this is unexpected. We examine the operations performed by insert, and we see that it loaded a length of ff....ff, and then stored a length of 0. That is, our array filled-up and reached the length of max uint256. This may look absurd or unrealistic, but that's where the power of the Prover lies - it doesn't miss any edge case. If we believe it is unrealistic for the length of keys to reach the maximum value, we should: - assume that the length of the array is less than max uint256. - assert that it is indeed infeasible to directly overwrite the length slot, or to increment the length by more than 1 in each operation. We start by adding a simple assumption in the rule. (We will later replace it with an assumption of an invariant, that will also assert that reaching max uint256 is infeasible.) cvl rule inverses(uint key, uint value) { uint max_uint = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; require numOfKeys() < max_uint; env e; insert(e, key, value); env e2; require e2.msg.value == 0; remove@wiprevert(e2, key); bool removeSucceeded = !lastReverted; assert removeSucceeded, \"remove after insert must succeed\"; assert get(key) != value, \"value of removed key must not be pe inserted value\"; } (don't forget to add numOfKeys to our envfree declarations!) Adding iteration Our goal in adding the keys variable was to allow iteration over the keys. We start with an extremely simple example, that sets all keys' values to 100: cvl function iterate() external { for (uint i = 0 ; i < keys.lengp ; i++) { uint key = keys[i]; doSomeping(key, get(key)); } } function doSomeping(uint key, uint value) virtual internal { map[key] = 100; } We also want to add a basic check rule: cvl rule checkIterate() { env e; iterate(e); uint someKey; require contains(someKey); assert get(someKey) == 100; } The rule fails with the following call trace: Let's unpack what can be seen here. First, the length of the keys array is 1, and we read a key 22f2. We then write 100 to it in the map and then iterate function is done. We then note that someKey, the key we want to check for, is not 22f2, but rather 20c9. While we assumed that it is contained in the map by using the contains function, it is not contained in the keys array. This is expected since the Prover's starting state can be completely arbitrary, subject to constraints that we specify on it. We wish to leave the contains function to be an O(1) complexity function, and rather provide the tool with the invariants that will allow it to see only states that \"make sense\", or in more precise terms, we only want to see states where the keys array contains exactly the same elements as the non-zero valued keys in the map. In mathematical terms, the invariant that our IterableMap contract should satisfy is: --- $$∀x.(map(x)≠0⟺∃i.0≤i≤keys.length∧keys[i]=x)$$ This invariant can be encoded directly in the spec file, as follows (for convenience we assume keys is public and has a getter): cvl invariant inMapIffInArray(uint x) get(x) != 0 <=> (exists uint i. 0 <= i && i < getNumOfKeys() && keys(i) == x) It is not recommended to invoke the underlying contract directly within quantified expressions (such as exists uint i. ...)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-2", "chunk-uid": "46a4007619e6", "chunk-page-index": 2, "text": "The complexity of the underlying bytecode might lead to timeouts, and thus it is recommended to move to ghost variables. Ghost variables, once properly instrumented, allow us to write specs that are separated from the many technicalities of low-level bytecode and are thus a powerful abstraction tool. A soft introduction to ghosts We will write the above invariant using ghost variables exclusively (see {doc}/docs/cvl/ghosts for complete information about ghosts). First, we will declare ghost variables for the underlying map structure. cvl ghost mapping(uint => uint) _map; The above declaration declares a ghost mapping. The ghost mapping takes a uint argument (representing a key in the map) and returns a uint value. We want _map to return for each given key the same value as the map in the code. We can state this property as an invariant: cvl invariant checkMapGhost(uint someKey) get(someKey) == _map[someKey] Currently, the rule fails for all state-mutating functions, and even in the contract's initial state after constructor (rule checkMapGhost_instate): This is unsurprising. There is nothing in the spec that links the value of the ghost to its Solidity counterpart."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-3", "chunk-uid": "46a4007619e6", "chunk-page-index": 3, "text": "To make that link, we write hooks. Hooks allow us to instrument the verified code, that is, to wrap a bytecode operation with our own code, defined in the spec file. For example, we can hook on SSTORE operations that write to the underlying map as follows: cvl hook Sstore map[KEY uint k] uint v { _map[k] = v; } This hook will match every storage write to map[k], denoting the written value by v. Optionally, and not shown in the syntax above, we can also specify the overwritten value of map[k]. The body of the hook is the injected code. It will update the _map ghost. If we run checkMapGhost with only the SSTORE hook, the rule will pass for all functions but fail in the initial state, where no values were written. It is possible to specify initial state axioms on ghosts. Similarly, one could define SLOAD hooks: cvl hook Sload uint v map[KEY uint k] { require _map[k] == v; } This hook says that every time the Prover encounters an SLOAD operation that reads the value v from map[k], it will inject the code within the hook body after the SLOAD. This will make our checkMapGhost rule pass, but it's also become a tautology, because it's always true: by calling get we're already calling instrumented code that requires _map[k] == v whenever we load an arbitrary value v from the key k. The IterableMap Contract The IterableMap will maintain an internal array of the keys inserted to the map. In the next section, we will add an iteration function. --- ### solidity pragma solidity ^0.7.0; contract IterableMap { mapping(uint => uint) internal map; function get(uint key) public view returns(uint) { return map[key]; } uint[] internal keys; function numOfKeys() external view returns (uint) { return keys.length; } function insert(uint key, uint value) external { require(value != 0, \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; } function remove(uint key) external { require (map[key] != 0, \"Key does not exist\"); map[key] = 0; uint i = indexOf(key); if (i < keys.length - 1) { keys[i] = keys[keys.length-1]; keys.pop(); } function contains(uint key) internal view returns (bool) { if (map[key] == 0) { return false; } return true; } function indexOf(uint key) internal view returns (uint) { for (uint i = 0 ; i < keys.length ; i++) { if (keys[i] == key) { } } return i; require(false, \"Could not find key\"); } We can now run the original spec file on the new contract. Unfortunately, not all rules are passing."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-4", "chunk-uid": "46a4007619e6", "chunk-page-index": 4, "text": "The inverses rule is failing. The assertion message tells us Unwinding condition in a loop. It is the output whenever we encounter a loop that cannot be finitely unrolled. To prevent missed bugs, the Prover outputs an assertion error in the loop's stop condition. We can control how many times the loops are unrolled, and in the future, the Prover will also support the specification of inductive invariants for full loop coverage. In our example, we can start by simply assuming loops can be fully unrolled even if only unrolled once by specifying --optimistic_loop in the command line for running the Prover. Even then inverses still fails. Let's consider the call trace for this rule: We see that we were able to nullify the entry in the map, but the last operation that we see in the call trace under remove is that we load from keys a value of 0. It is known that the Solidity compiler associates the storage slot of an array to its length. Here we see that the read length is 0. This means the key array is empty. However, it shouldn't have been empty after invoking insert. This is exactly the bug that we have in the code - we need to add the inserted key into the keys array: --- ## cvl function insert(uint key, uint value) external require(value != 0, \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; keys.push(key); Oddly enough, the rule still fails: It is still reported that the length of keys is 0, but this is unexpected. We examine the operations performed by insert, and we see that it loaded a length of ff....ff, and then stored a length of 0. That is, our array filled-up and reached the length of max uint256. This may look absurd or unrealistic, but that's where the power of the Prover lies - it doesn't miss any edge case. If we believe it is unrealistic for the length of keys to reach the maximum value, we should: - assume that the length of the array is less than max uint256. - assert that it is indeed infeasible to directly overwrite the length slot, or to increment the length by more than 1 in each operation. We start by adding a simple assumption in the rule. (We will later replace it with an assumption of an invariant, that will also assert that reaching max uint256 is infeasible.) ## cvl rule inverses(uint key, uint value) uint max_uint = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; require numOfKeys() &lt; max_uint; env e; insert(e, key, value); env e2; require e2.msg.value == 0; remove@withrevert(e2, key); bool removeSucceeded = !lastReverted; assert removeSucceeded, \"remove after insert must succeed\"; assert get(key) != value, \"value of removed key must not be the inserted value\"; (don't forget to add numOfKeys to our envfree declarations!) Adding iteration Our goal in adding the keys variable was to allow iteration over the keys. We start with an extremely simple example, that sets all keys' values to 100: ```cvl function iterate() external { for (uint i = 0 ; i &lt; keys.length ; i++) { uint key = keys[i]; doSomething(key, get(key)); } } function doSomething(uint key, uint value) virtual internal { map[key] = 100; } ``` We also want to add a basic check rule: ## cvl rule checkIterate() env e; iterate(e); uint someKey; require contains(someKey); assert get(someKey) == 100; The rule fails with the following call trace: Let's unpack what can be seen here. First, the length of the keys array is 1, and we read a key 22f2. We then write 100 to it in the map and then iterate function is done. We then note that someKey, the key we want to check for, is not 22f2, but rather 20c9. While we assumed that it is contained in the map by using the contains function, it is not contained in the keys array. This is expected since the Prover's starting state can be completely arbitrary, subject to constraints that we specify on it. We wish to leave the contains function to be an O(1) complexity function, and rather provide the tool with the invariants that will allow it to see only states that \"make sense\", or in more precise terms, we only want to see states where the keys array contains exactly the same elements as the non-zero valued keys in the map. In mathematical terms, the invariant that our IterableMap contract should satisfy is: $$∀x.(map(x)≠0⟺∃i.0≤i≤keys.length∧keys[i]=x)$$ This invariant can be encoded directly in the spec file, as follows (for convenience we assume keys is public and has a getter): --- cvl invariant inMapIffInArray(uint x) get(x) != 0 <=> (exists uint i. 0 <= i && i < getNumOfKeys() && keys(i) == x) It is not recommended to invoke the underlying contract directly within quantified expressions (such as exists uint i. ...)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-5", "chunk-uid": "46a4007619e6", "chunk-page-index": 5, "text": "The complexity of the underlying bytecode might lead to timeouts, and thus it is recommended to move to ghost variables. Ghost variables, once properly instrumented, allow us to write specs that are separated from the many technicalities of low-level bytecode and are thus a powerful abstraction tool. A soft introduction to ghosts We will write the above invariant using ghost variables exclusively (see {doc}/docs/cvl/ghosts for complete information about ghosts). First, we will declare ghost variables for the underlying map structure. cvl ghost mapping(uint => uint) _map; The above declaration declares a ghost mapping. The ghost mapping takes a uint argument (representing a key in the map) and returns a uint value. We want _map to return for each given key the same value as the map in the code. We can state this property as an invariant: cvl invariant checkMapGhost(uint someKey) get(someKey) == _map[someKey] Currently, the rule fails for all state-mutating functions, and even in the contract's initial state after constructor (rule checkMapGhost_instate): This is unsurprising. There is nothing in the spec that links the value of the ghost to its Solidity counterpart."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "iterable", "id": "46a4007619e6-6", "chunk-uid": "46a4007619e6", "chunk-page-index": 6, "text": "To make that link, we write hooks. Hooks allow us to instrument the verified code, that is, to wrap a bytecode operation with our own code, defined in the spec file. For example, we can hook on SSTORE operations that write to the underlying map as follows: cvl hook Sstore map[KEY uint k] uint v { _map[k] = v; } This hook will match every storage write to map[k], denoting the written value by v. Optionally, and not shown in the syntax above, we can also specify the overwritten value of map[k]. The body of the hook is the injected code. It will update the _map ghost. If we run checkMapGhost with only the SSTORE hook, the rule will pass for all functions but fail in the initial state, where no values were written. It is possible to specify initial state axioms on ghosts. Similarly, one could define SLOAD hooks: cvl hook Sload uint v map[KEY uint k] { require _map[k] == v; } This hook says that every time the Prover encounters an SLOAD operation that reads the value v from map[k], it will inject the code within the hook body after the SLOAD. This will make our checkMapGhost rule pass, but it's also become a tautology, because it's always true: by calling get we're already calling instrumented code that requires _map[k] == v whenever we load an arbitrary value v from the key k."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "report", "id": "dd98b57edc1a-0", "chunk-uid": "dd98b57edc1a", "chunk-page-index": 0, "text": "# Certora Verification Reports Understanding counter-examples There could be many reasons for false counterexamples, but here are a few common ones. A counterexample that looks fishy does not rule out a potential bug that the rule can uncover. 1. External call havocs. Look for warnings in the Call Resolution table - this could indicate havocs. Havocs are a common cause of counterexamples that seem to come out of nowhere! 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "report", "id": "dd98b57edc1a-1", "chunk-uid": "dd98b57edc1a", "chunk-page-index": 1, "text": "Links are not applied as expected. Note that if you use --link to link, you may sometimes need to require that the field is equal to the linked-to contract's address within the rule itself. (Dispatcher links do not have this issue.) 3. Bitwise operations. By default, the tool will overapproximate bitwise operations applied in a non-standard way (xor, or, and non 2^n-1 masks for and). Try to look over the dump and look for red-background lines. You may be able to solve these by passing the --prover_arsg -useBitVectorTheory option on the command line 4. Aliasing. Be on the lookout if your environment’s msg.sender is the same as currentContract or any linked contract. The tool should report these more clearly but read the call trace carefully. Also, note trivial assignments like 0. 5. Correct storage modeling. Suppose you have a rule that calls some getter, then you call a function that’s expected to affect the results of that getter, but in the counterexample it stays the same. It could be that the code invoked is not reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function. --- ### Bitwise operations By default, the tool will overapproximate bitwise operations applied in a non-standard way (xor, or, and non 2^n-1 masks for and). Try to look over the dump and look for red-background lines. You may be able to solve these by passing the --prover_arsg -useBitVectorTheory option on the command line. ### Aliasing Be on the lookout if your environment’s msg.sender is the same as currentContract or any linked contract. The tool should report these more clearly but read the call trace carefully."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "report", "id": "dd98b57edc1a-2", "chunk-uid": "dd98b57edc1a", "chunk-page-index": 2, "text": "Also, note trivial assignments like 0. ### Correct storage modeling Suppose you have a rule that calls some getter, then you call a function that’s expected to affect the results of that getter, but in the counterexample it stays the same. It could be that the code invoked is not reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sorts", "id": "de589df102de-0", "chunk-uid": "de589df102de", "chunk-page-index": 0, "text": "Uninterpreted Sorts Syntax for Uninterpreted Sorts CVL specifications support bop Solidity primitives (uint256, address, etc.) and custom types (e.g., mapint). Solidity types are interpreted, meaning pey have specific semantics, such as aripmetic or comparison operations. However, in some cases, it is beneficial to use uninterpreted sorts, which do not carry pe semantics associated wip interpretation. To declare an uninterpreted sort in CVL, use pe following syntax: cvl sort MyUninterpSort; sort Foo; These uninterpreted sorts can be utilized in various ways wipin a CVL specification: 1. Declare Variables: cvl Foo x; 2. Test Equality: cvl Foo x; Foo y; assert x == y; 3. Use in Signatures: cvl ghost myGhost(uint256, Foo) returns Foo; Example Usage Consider the following example: cvl sort Foo; ghost bar(Foo, Foo) returns Foo; rule myRule { Foo x; Foo y; Foo z = bar(x, y); assert x == y && y == z; } This example demonstrates the use of an uninterpreted sort Foo. The bar ghost function takes two arguments of type Foo and returns a value of the same type. The myRule rule declares variables x, y, and z, and asserts that they are all equal. Using Uninterpreted Sorts with Ghosts Uninterpreted sorts can also be employed in ghosts, as shown in the following example: cvl ghost mapping(uint256 => Node) toNode; ghost mapping(Node => mapping(Node => bool)) reach { // Axioms for reachability relation axiom forall Node X. reach[X][X]; axiom forall Node X."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sorts", "id": "de589df102de-1", "chunk-uid": "de589df102de", "chunk-page-index": 1, "text": "forall Node Y. reach[X][Y] && reach[Y][X] => X == Y; axiom forall Node X. forall Node Y. forall Node Z. reach[X][Y] && reach[Y][Z] => reach[X][Z]; axiom forall Node X. forall Node Y. forall Node Z. reach[X][Y] && reach[X][Z] => (reach[Y][Z] || reach[Z][Y]); } definition isSucc(Node a, Node b) returns bool = // Definition for successor relationship reach[a][b] && a != b && (forall Node X. reach[a][X] && reach[X][b] => (a == X || b == X)); rule checkGetSucc { uint256 key; uint256 afterKey = getSucc(key); assert reach[toNode[key]][toNode[afterKey]]; } This example demonstrates the use of uninterpreted sorts (Node) in ghost mappings and functions, emphasizing their application in specifying relationships and properties without being bound by specific interpretations. In summary, uninterpreted sorts in CVL provide a versatile tool for declaring abstract types and relationships, allowing for greater expressiveness in specification design. --- CVL specifications support both Solidity primitives (uint256, address, etc.) and custom types (e.g., mathint). Solidity types are interpreted, meaning they have specific semantics, such as arithmetic or comparison operations. However, in some cases, it is beneficial to use uninterpreted sorts, which do not carry the semantics associated with interpretation. Syntax for Uninterpreted Sorts To declare an uninterpreted sort in CVL, use the following syntax: cvl sort MyUninterpSort; sort Foo; These uninterpreted sorts can be utilized in various ways within a CVL specification: 1. Declare Variables: cvl Foo x; 2. Test Equality: cvl Foo x; Foo y; assert x == y; 3. Use in Signatures: cvl ghost myGhost(uint256, Foo) returns Foo; Example Usage Consider the following example: cvl sort Foo; ghost bar(Foo, Foo) returns Foo; rule myRule { Foo x; Foo y; Foo z = bar(x, y); assert x == y &amp;&amp; y == z; } This example demonstrates the use of an uninterpreted sort Foo. The bar ghost function takes two arguments of type Foo and returns a value of the same type. The myRule rule declares variables x, y, and z, and asserts that they are all equal. Using Uninterpreted Sorts with Ghosts Uninterpreted sorts can also be employed in ghosts, as shown in the following example: cvl ghost mapping(uint256 =&gt; Node) toNode; ghost mapping(Node =&gt; mapping(Node =&gt; bool)) reach { // Axioms for reachability relation axiom forall Node X. reach[X][X]; axiom forall Node X."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "sorts", "id": "de589df102de-2", "chunk-uid": "de589df102de", "chunk-page-index": 2, "text": "forall Node Y. reach[X][Y] &amp;&amp; reach[Y][X] =&gt; X == Y; axiom forall Node X. forall Node Y. forall Node Z. reach[X][Y] &amp;&amp; reach[Y][Z] =&gt; reach[X][Z]; axiom forall Node X. forall Node Y. forall Node Z. reach[X][Y] &amp;&amp; reach[X][Z] =&gt; (reach[Y][Z] || reach[Z][Y]); } definition isSucc(Node a, Node b) returns bool = // Definition for successor relationship reach[a][b] &amp;&amp; a != b &amp;&amp; (forall Node X. reach[a][X] &amp;&amp; reach[X][b] =&gt; (a == X || b == X)); rule checkGetSucc { uint256 key; uint256 afterKey = getSucc(key); assert reach[toNode[key]][toNode[afterKey]]; } This example demonstrates the use of uninterpreted sorts (Node) in ghost mappings and functions, emphasizing their application in specifying relationships and properties without being bound by specific interpretations. In summary, uninterpreted sorts in CVL provide a versatile tool for declaring abstract types and relationships, allowing for greater expressiveness in specification design."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout-theory", "id": "286c0d6bea63-0", "chunk-uid": "286c0d6bea63", "chunk-page-index": 0, "text": "## Timeouts in Certora Prover - Theoretical Background In this section, we will discuss some background of timeouts happening in the Certora Prover. We try to answer questions like \"Why do you build a tool that times out?\" and \"Will there be an automatic program verifier that never times out?\". For more practical advice on timeout prevention, please consult the other parts of our documentation on managing timeouts. ## Complexity of the SMT problem As described in the white paper, Certora Prover is roughly similar in architecture to a compiler. However, instead of executables, Certora Prover outputs SMT formulas. These formulas are then sent to an SMT solver, and the result is translated back to a counterexample call trace, or a \"Not Violated\" result. All SMT solvers share a general architecture."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout-theory", "id": "286c0d6bea63-1", "chunk-uid": "286c0d6bea63", "chunk-page-index": 1, "text": "At the center of an SMT solver, there is a SAT solver. The SAT solver operates on a Boolean abstraction of the input formula, and communicates with theory solvers to refine the abstraction according to the theories used by the formula. The problem of solving propositional formulas (aka SAT) is famously NP-complete. In practice this means that there are classes of propositional formulas for which all known SAT solvers show exponential run-time behavior. Exponential running time is usually equated with intractability (\"we have an algorithm, but it's impractical because it runs too long\"). Most of the theories involved are at least NP-complete, already in their conjunctive fragments (which SMT theory solvers use). In fact, with the addition of nonlinear integer arithmetic the SMT problem is undecidable, meaning that there is no algorithm that can correctly solve all possible formulas. ## Usefulness of worst-case intractable problems When seeing the complexity results of the previous section, it is easy to give up on the problems of SAT and SMT. Indeed, there were long periods in computer science history when SAT was considered unsolvable. However, it is important to understand that these complexity results describe the worst case behavior. It turns out that there is a large class of formulas where SAT is tractable, even on inputs with millions of variables, and SAT solvers have been used with great success in industries like chip design for decades now. For the usage of Certora Prover this means that timeouts can happen, but that often there are slight variations on the input that do not impact the property being proven and that make the problem tractable."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout-theory", "id": "286c0d6bea63-2", "chunk-uid": "286c0d6bea63", "chunk-page-index": 2, "text": "This practice is likely to require experience, which we collect in the timeout-prevention section. We can use the parts of an SMT solver that we discussed before for some intuition on different kinds of complexity explosions. |Difficulty|Solver parts| |---|---| |Path count|SAT| |Storage/memory|SAT| |Arithmetic|LIA / NIA| |bitwise operations|SAT, UF, LIA| Since control flow is encoded into Boolean logic by the Certora Prover, it weighs most heavily on the SAT-solving part of the SMT solver. Storage or Memory accesses lead to case splits, which are also Boolean in nature. On the other hand, arithmetic is resolved by specialized solvers; different algorithms are required for the linear and the nonlinear cases. ## Further reading There is a large body of literature on the topics of logics, complexity, and SMT. Here are some links as an entry point for further reading: The Wikipedia articles on SMT, and the more basic problem known as SAT give an overview on the fundamentals of these problems, and the existing solving algorithms. Programming Z3 provides a guide to the z3 SMT solver that also provides a good overview of the architecture and components of an SMT solver, including some algorithms, and further references. --- ## Timeouts in Certora Prover - Theoretical Background In this section, we will discuss some background of timeouts happening in the Certora Prover. We try to answer questions like \"Why do you build a tool that times out?\" and \"Will there be an automatic program verifier that never times out?\". For more practical advice on timeout prevention, please consult the other parts of our documentation on managing timeouts. ### Complexity of the SMT problem As described in the white paper, Certora Prover is roughly similar in architecture to a compiler. However, instead of executables, Certora Prover outputs SMT formulas. These formulas are then sent to an SMT solver, and the result is translated back to a counterexample call trace, or a \"Not Violated\" result. All SMT solvers share a general architecture."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "timeout-theory", "id": "286c0d6bea63-3", "chunk-uid": "286c0d6bea63", "chunk-page-index": 3, "text": "At the center of an SMT solver, there is a SAT solver. The SAT solver operates on a Boolean abstraction of the input formula, and communicates with theory solvers to refine the abstraction according to the theories used by the formula. The problem of solving propositional formulas (aka SAT) is famously NP-complete. In practice this means that there are classes of propositional formulas for which all known SAT solvers show exponential run-time behavior. Exponential running time is usually equated with intractability (\"we have an algorithm, but it's impractical because it runs too long\"). Most of the theories involved are at least NP-complete, already in their conjunctive fragments (which SMT theory solvers use). In fact, with the addition of nonlinear integer arithmetic the SMT problem is undecidable, meaning that there is no algorithm that can correctly solve all possible formulas. ### Usefulness of worst-case intractable problems When seeing the complexity results of the previous section, it is easy to give up on the problems of SAT and SMT. Indeed, there were long periods in computer science history when SAT was considered unsolvable. However, it is important to understand that these complexity results describe the worst case behavior. It turns out that there is a large class of formulas where SAT is tractable, even on inputs with millions of variables, and SAT solvers have been used with great success in industries like chip design for decades now. For the usage of Certora Prover this means that timeouts can happen, but that often there are slight variations on the input that do not impact the property being proven and that make the problem tractable. This practice is likely to require experience, which we collect in the timeout-prevention section. We can use the parts of an SMT solver that we discussed before for some intuition on different kinds of complexity explosions. |Difficulty|Solver parts| |---|---| |Path count|SAT| |Storage/memory|SAT| |Arithmetic|LIA / NIA| |bitwise operations|SAT, UF, LIA| Since control flow is encoded into Boolean logic by the Certora Prover, it weighs most heavily on the SAT-solving part of the SMT solver. Storage or Memory accesses lead to case splits, which are also Boolean in nature. On the other hand, arithmetic is resolved by specialized solvers; different algorithms are required for the linear and the nonlinear cases. ### Further reading There is a large body of literature on the topics of logics, complexity, and SMT. Here are some links as an entry point for further reading: The Wikipedia articles on SMT, and the more basic problem known as SAT give an overview on the fundamentals of these problems, and the existing solving algorithms. Programming Z3 provides a guide to the z3 SMT solver that also provides a good overview of the architecture and components of an SMT solver, including some algorithms, and further references."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-0", "chunk-uid": "c28733236d43", "chunk-page-index": 0, "text": "## Gambit: Mutant Generation for Solidity Gambit is a state-of-the-art mutation system for Solidity. By applying predefined syntax transformations called mutation operators (for example, convert a + b to a - b) to a Solidity program's source code, Gambit generates variants of the program called mutants. Mutants can be used to evaluate test suites or specs used for formal verification: each mutant represents a potential bug in the program, and stronger test suites and specifications should detect more mutants. ### Requirements - Gambit is written in Rust. You'll need to install Rust and Cargo to build Gambit. - Gambit uses solc, the Solidity compiler, to generate mutants. You'll need to have a solc binary that is compatible with the project you are mutating (see the --solc option in gambit mutate --help) ### Installation You can download prebuilt Gambit binaries for Linux x86-64 and Mac from our releases page. For Windows and Linux ARM, you must build Gambit from source. Building Gambit from source To build Gambit from source, clone the Gambit repository and run cargo install --path . from this repository's root. This will build Gambit and install it to a globally visible location on your PATH. You can also build gambit with cargo build --release from the root of this repository. This will create a gambit binary in gambit/target/release/ which you can manually place on your path or invoke directly (e.g., by calling path/to/gambit/target/release/gambit). ### Usage Gambit has two main commands: mutate and summary. gambit mutate is responsible for mutating code, and gambit summary is a convenience command for summarizing generated mutants in a human-readable way. Running gambit mutate will invoke solc, so make sure it is visible on your PATH. Alternatively, you can specify where Gambit can find the Solidity compiler with the option --solc path/to/solc, or specify a solc binary (e.g., solc8.12) with the option --solc solc8.12. Note: All tests (cargo test) are currently run using solc8.13. Your tests may fail if your solc points at a different version of the compiler. Running gambit mutate The gambit mutate command expects either a --filename argument or a --json argument. Using --filename allows you to specify a specific Solidity file to mutate: bash gambit mutate --filename file.sol However, if you want to mutate multiple files or apply a more complex set of parameters, we recommend using a configuration file via the --json option instead: bash gambit mutate --json gambit_conf.json --- Run gambit --help for more information. {note} All relative paths specified in a JSON configuration file are interpreted to be relative to the configuration file's parent directory. In the following section we provide examples of how to run Gambit using both --filename and --json. We provide more complete documentation in the {ref}configuration-files and {ref}cli-options sections below."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-1", "chunk-uid": "c28733236d43", "chunk-page-index": 1, "text": "Examples Unless otherwise noted, examples use code from benchmarks/ and are run from the root of the Gambit repository. Example 1: Mutating a single file To mutate a single file, use pe --filename option (or -f), followed by pe file to mutate. bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol This will generate: Generated 34 mutants in 0.69 seconds {note} The mutated file must be located wipin your current working directory or one of its subdirectories. If you want to mutate code in an arbitrary directory, use pe `--sourceroot` option. Example 2: Mutating and downsampling The above command produced 34 mutants which may be more pan you need. Gambit provides a way to randomly downsample pe number of mutants wip pe --num_mutants or -n option: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 3 which will generate: Generated 3 mutants in 0.15 seconds Example 3: Viewing Gambit results {note} This example assumes you've just completed Example 2. Gambit outputs all of its results in gambit_out: bash tree -L 2 gambit_out This produces: gambit_out ├── gambit_results.json ├── input_json │ ├── BinaryOpMutation.sol_json.ast │ └── BinaryOpMutation.sol_json.ast.json ├── mutants │ ├── 1 │ ├── 2 │ └── 3 └── mutants.log See the {ref}results-directory section for a detailed explanation of this layout. The gambit summary command pretty prints each mutant for easy inspection: The output of gambit summary By default gambit summary prints info on all mutants. If you are interested in particular mutants you can specify a subset of mutant ids with the --mids flag. For instance, gambit summary --mids 3 4 5 will only print info for mutant ids 3 through 5. Example 4: Specifying solc pass-through arguments The Solidity compiler (solc) may need some extra information to successfully run on a file or a project. Gambit enables this with pass-through arguments that, as the name suggests, are passed directly through to the solc compiler. --- ## For projects that have complex dependencies and imports, you may need to: Specify base paths: To specify the Solidity --base-path argument, use --solc_base_path: bash gambit mutate --filename path/to/file.sol --solc_base_path base/path/dir Specify remappings: To indicate where Solidity should find libraries, use solc's import remapping syntax with --solc_remappings: bash gambit mutate --filename path/to/file.sol \\ --solc_remappings @openzeppelin=node_modules/@openzeppelin @foo=node_modules/@foo {warning} The paths should NOT end with a trailing / Specify allow paths: To include additional allowed paths via solc's --allow-paths argument, use --solc_allow_paths: bash gambit mutate --filename path/to/file.sol \\ --solc_allow_paths PATH1 --solc_allow_paths PATH2 ... Specify include-path: To make an additional source directory available to the default import callback via solc's [--include-path][included] argument, use --solc_include_path: bash gambit mutate --filename path/to/file.sol --solc_include_path PATH Use optimization: To run the Solidity compiler with optimizations (solc's --optimize argument), use --solc_optimize: bash gambit mutate --filename path/to/file.sol --solc_optimize ## Example 5: The --sourceroot option Gambit needs to track the location of source files that it mutates within a project: for instance, imagine there are files foo/Foo.sol and bar/Foo.sol. These are separate files, and their path prefixes are needed to determine this."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-2", "chunk-uid": "c28733236d43", "chunk-page-index": 2, "text": "Gambit addresses this with the --sourceroot option: the source root indicates to Gambit the root of the files that are being mutated, and all source file paths (both original and mutated) are reported relative to this source root. {note} If Gambit encounters a source file that does not belong to the source root it will print an error message and exit. When running gambit mutate with the --filename option, source root defaults to the current working directory. When running gambit mutate with the --json option, source root defaults to the directory containing the configuration JSON. Here are some examples of using the --sourceroot option: 1. From the root of the Gambit repository, run: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 cat gambit_out/mutants.log find gambit_out/mutants -name \"*.sol\" This should output the following: Generated 1 mutants in 0.13 seconds 1,BinaryOpMutation,benchmarks/BinaryOpMutation/BinaryOpMutation.sol,23:10, % ,* gambit_out/mutants/1/benchmarks/BinaryOpMutation/BinaryOpMutation.sol The first command generates a single mutant, and its source path is relative to ., the default source root. We can see that the reported paths in mutants.log, and the mutant file path in gambit_out/mutants/1, are the relative to this source root: benchmarks/BinaryOpMutation/BinaryOpMutation.sol 2. Suppose we want our paths to be reported relative to benchmarks/BinaryOpMutation. We can run --- bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 --sourceroot benchmarks/BinaryOpMutation cat gambit_out/mutants.log find gambit_out/mutants -name \"*.sol\" which will output: Generated 1 mutants in 0.13 seconds 1,BinaryOpMutation,BinaryOpMutation.sol,23:10, % ,* gambit_out/mutants/1/BinaryOpMutation.sol The reported filenames, and the offset path inside of gambit_out/mutants/1/, are now relative to the source root that we specified. Finally, suppose we use a source root that doesn't contain the source file: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 --sourceroot scripts This will try to find the specified file inside of scripts, and since it doesn't exist Gambit reports the error: [ERROR gambit] [!!] Illegal Configuration: Resolved filename `/Users/USER/Gambit/benchmarks/BinaryOpMutation/BinaryOpMutation.sol` is not prefixed by the derived source root /Users/USER/Gambit/scripts Gambit prints an error and exits. ## Example 6: Running Gambit using a configuration file To run gambit with a configuration file, use the --json argument: bash gambit mutate --json benchmarks/config-jsons/test1.json The configuration file is a JSON file containing the command line arguments for gambit and additional configuration options: json { \"filename\": \"../10Power/TenPower.sol\", \"sourceroot\": \"..\", \"solc_remappings\": [ \"@openzeppelin=node_modules/@openzeppelin\" ], } In addition to specifying the command line arguments, you can list the specific mutants that you want to apply, the specific functions you wish to mutate, and more. See the benchmark/config-jsons directory for examples."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-3", "chunk-uid": "c28733236d43", "chunk-page-index": 3, "text": "Note: Any paths provided by the configuration file are resolved relative to the configuration file's parent directory."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-4", "chunk-uid": "c28733236d43", "chunk-page-index": 4, "text": "## Configuration Files Configuration files allow you to save complex configurations and perform multiple mutations at once. Gambit uses a simple JSON object format to store mutation options, where each --option VALUE specified on the CLI is represented as a \"option\": VALUE key/value pair in the JSON object. Boolean --flags are enabled by storing them as true: \"flag\": true. For instance, --no_overwrite would be written as \"no_overwrite\": true. As an example, consider the command from Example 1: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol To execute this using a configuration file you would write the following to example-1.json to the root of this repository and run gambit mutate --json example-1.json json { \"filename\": \"benchmarks/BinaryOpMutation/BinaryOpMutation.sol\" } --- ## Gambit Configuration Gambit also supports using multiple configurations in the same file: instead of a single JSON object, your configuration file should contain an array of objects: json { \"filename\": \"Foo.sol\", \"contract\": \"C\", \"functions\": [\"bar\", \"baz\"], \"solc\": \"solc8.12\", \"solc_optimize\": true } { \"filename\": \"Blip.sol\", \"contract\": \"D\", \"functions\": [\"bang\"], \"solc\": \"solc8.12\", \"mutations\": [ \"binary-op-mutation\", \"swap-arguments-operator-mutation\" ] } This configuration file will perform all mutations on Foo.sol's functions bar and baz in the contract C, and only binary-op-mutation and swap-arguments-operator-mutation mutations on the function bang in the contract D. Both will compile using the Solidity compiler version solc5.12. Paths in Configuration Files Relative paths in a Gambit configuration file are relative to the parent directory of the configuration file. So if the JSON file listed above was moved to the benchmarks/ directory the \"filename\" would need to be updated to BinaryOpMutation/BinaryOpMutation.sol. ## Results Directory gambit mutate produces all results in an output directory (default: gambit_out). Here is an example: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 5 tree gambit_out -L 2 which produces: Generated 5 mutants in 0.15 seconds gambitout - gambitresults.json: a JSON file with detailed results - input_json/: intermediate files produced by solc that are used during mutation - mutants/: exported mutants. Each mutant is in its own directory named after its mutant ID (mid) 1, 2, 3, ... - mutants.log: a log file with all mutant information. This is similar to results.json but in a different format and with different information ## CLI Options gambit mutate supports the following options; for a comprehensive list, run gambit mutate --help: |Option|Description| |---|---| |-o, --outdir|specify Gambit's output directory (defaults to gambit_out)| |--no_overwrite|do not overwrite an output directory; if the output directory exists, print an error and exit| |-n, --num_mutants|randomly downsample to a given number of mutants.| |-s, --seed|specify a random seed. For reproducibility, Gambit defaults to using the seed 0."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-5", "chunk-uid": "c28733236d43", "chunk-page-index": 5, "text": "To randomize the seed use --random_seed| |--random_seed|use a random seed. Note that this overrides any value specified by --seed| |--contract|specify a specific contract name to mutate; by default mutate all contracts| |--functions|specify one or more functions to mutate; by default mutate all functions| |--mutations|specify one or more mutation operators to use; only generates mutants that are created using the specified operators| |--skip_validate|only generate mutants without validating them by compilation| Gambit also supports pass-through arguments, which are arguments that are passed directly to the Solidity compiler. All pass-through arguments are prefixed with solc_: --- |Option|Description| |---|---| |solc_allow_paths|passes a value to solc's --allow-paths argument| |--solc_base_path|passes a value to solc's --base-path argument| |--solc_include_path|passes a value to solc's --include-path argument| |--solc_remappings|passes a value to directly to solc: this should be of the form prefix=path.| Mutation Operators Gambit implements the following mutation operators |Mutation Operator|Description|Example| |---|---|---| |binary-op-mutation|Replace a binary operator with another|a+b -&gt; a-b| |unary-operator-mutation|Replace a unary operator with another|~a -&gt; -a| |require-mutation|Alter the condition of a require statement|require(some_condition()) -&gt; require(true)| |assignment-mutation|Replaces the right hand side of an assignment|x = foo(); -&gt; x = -1;| |delete-expression-mutation|Replaces an expression with a no-op (assert(true))|foo(); -&gt; assert(true);| |if-cond-mutation|Mutate the conditional of an if statement|if (C) {...} -&gt; if (true) {...}| |swap-arguments-operator-mutation|Swap the order of non-commutative operators|a - b -&gt; b - a| |elim-delegate-mutation|Change a delegatecall() to a call()|_c.delegatecall(...) -&gt; _c.call(...)| |function-call-mutation|(Disabled) Changes arguments of a function|add(a, b) -&gt; add(a, a)| |swap-arguments-function-mutation|(Disabled) Swaps the order of a function's arguments|add(a, b) -&gt; add(b, a)| For more details on each mutation type, refer to the full documentation. Gambit: Mutant Generation for Solidity Gambit is a state-of-the-art mutation system for Solidity. By applying predefined syntax transformations called mutation operators (for example, convert a + b to a - b) to a Solidity program's source code, Gambit generates variants of the program called mutants. Mutants can be used to evaluate test suites or specs used for formal verification: each mutant represents a potential bug in the program, and stronger test suites and specifications should detect more mutants. Requirements 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-6", "chunk-uid": "c28733236d43", "chunk-page-index": 6, "text": "Gambit is written in Rust. You'll need to install Rust and Cargo to build Gambit. 2. Gambit uses solc, the Solidity compiler, to generate mutants. You'll need to have a solc binary that is compatible with the project you are mutating (see the --solc option in gambit mutate --help) Installation You can download prebuilt Gambit binaries for Linux x86-64 and Mac from our releases page. For Windows and Linux ARM, you must build Gambit from source. Building Gambit from source To build Gambit from source, clone the Gambit repository and run cargo install --path . from this repository's root. This will build Gambit and install it to a globally visible location on your PATH. You can also build gambit with cargo build --release from the root of this repository. This will create a gambit binary in gambit/target/release/ which you can manually place on your path or invoke directly (e.g., by calling path/to/gambit/target/release/gambit). --- ## Usage Gambit has two main commands: mutate and summary. gambit mutate is responsible for mutating code, and gambit summary is a convenience command for summarizing generated mutants in a human-readable way. Running gambit mutate will invoke solc, so make sure it is visible on your PATH. Alternatively, you can specify where Gambit can find the Solidity compiler with the option --solc path/to/solc, or specify a solc binary (e.g., solc8.12) with the option --solc solc8.12. {note} All tests (cargo test) are currently run using solc8.13. Your tests may fail if your solc points at a different version of the compiler. Running gambit mutate The gambit mutate command expects either a --filename argument or a --json argument. Using --filename allows you to specify a specific Solidity file to mutate: bash gambit mutate --filename file.sol However, if you want to mutate multiple files or apply a more complex set of parameters, we recommend using a configuration file via the --json option instead: bash gambit mutate --json gambit_conf.json Run gambit --help for more information. {note} All relative paths specified in a JSON configuration file are interpreted to be relative to the configuration file's parent directory. In the following section we provide examples of how to run Gambit using both --filename and --json. We provide more complete documentation in the configuration-files and cli-options sections below. ## Examples Unless otherwise noted, examples use code from benchmarks/ and are run from the root of the Gambit repository. Example 1: Mutating a single file To mutate a single file, use the --filename option (or -f), followed by the file to mutate. bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol This will generate: Generated 34 mutants in 0.69 seconds {note} The mutated file must be located within your current working directory or one of its subdirectories. If you want to mutate code in an arbitrary directory, use the --sourceroot option. Example 2: Mutating and downsampling The above command produced 34 mutants which may be more than you need. Gambit provides a way to randomly downsample the number of mutants with the --num_mutants or -n option: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 3 which will generate: Generated 3 mutants in 0.15 seconds Example 3: Viewing Gambit results --- ## {note} This example assumes you've just completed Example 2. Gambit outputs all of its results in gambit_out: bash tree -L 2 gambit_out This produces: gambit_out ├── gambit_results.json ├── input_json │ ├── BinaryOpMutation.sol_json.ast │ └── BinaryOpMutation.sol_json.ast.json ├── mutants │ ├── 1 │ ├── 2 │ └── 3 └── mutants.log See the results-directory section for a detailed explanation of this layout. The gambit summary command pretty prints each mutant for easy inspection: The output of gambit summary By default gambit summary prints info on all mutants. If you are interested in particular mutants you can specify a subset of mutant ids with the --mids flag. For instance, gambit summary --mids 3 4 5 will only print info for mutant ids 3 through 5. ## Example 4: Specifying solc pass-through arguments The Solidity compiler (solc) may need some extra information to successfully run on a file or a project. Gambit enables this with pass-through arguments that, as the name suggests, are passed directly through to the solc compiler. For projects that have complex dependencies and imports, you may need to: - Specify base paths: To specify the Solidity -base-path argument, use --solc_base_path: bash gambit mutate --filename path/to/file.sol --solc_base_path base/path/dir - Specify remappings: To indicate where Solidity should find libraries, use solc's import remapping syntax with --solc_remappings: bash gambit mutate --filename path/to/file.sol \\ --solc_remappings @openzeppelin=node_modules/@openzeppelin @foo=node_modules/@foo {warning} The paths should ***NOT*** end with a trailing / Specify allow paths: To include additional allowed paths via solc's --allow-paths argument, use -- solc_allow_paths: bash gambit mutate --filename path/to/file.sol \\ --solc_allow_paths PATH1 --solc_allow_paths PATH2 ... Specify include-path: To make an additional source directory available to the default import callback via solc's [-- include-path][included] argument, use --solc_include_path: bash gambit mutate --filename path/to/file.sol --solc_include_path PATH Use optimization: To run the Solidity compiler with optimizations (solc's --optimize argument), use -- solc_optimize: bash gambit mutate --filename path/to/file.sol --solc_optimize ## Example 5: The --sourceroot option Gambit needs to track the location of source files that it mutates within a project: for instance, imagine there are files foo/Foo.sol and bar/Foo.sol. These are separate files, and their path prefixes are needed to determine this."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "gambit", "id": "c28733236d43-7", "chunk-uid": "c28733236d43", "chunk-page-index": 7, "text": "Gambit addresses this with the --sourceroot option: the source root indicates to Gambit the root of the files that are being mutated, and all source file paths (both original and mutated) are reported relative to this source root. --- ## {note} If Gambit encounters a source file that does not belong to the source root it will print an error message and exit. When running gambit mutate with the --filename option, source root defaults to the current working directory. When running gambit mutate with the --json option, source root defaults to the directory containing the configuration JSON. Here are some examples of using the --sourceroot option: 1. From pe root of pe Gambit repository, run: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 cat gambit_out/mutants.log find gambit_out/mutants -name \"*.sol\" This should output the following: Generated 1 mutants in 0.13 seconds 1,BinaryOpMutation,benchmarks/BinaryOpMutation/BinaryOpMutation.sol,23:10, % ,* gambit_out/mutants/1/benchmarks/BinaryOpMutation/BinaryOpMutation.sol The first command generates a single mutant, and its source path is relative to ., the default source root. We can see that the reported paths in mutants.log, and the mutant file path in gambit_out/mutants/1, are relative to this source root: benchmarks/BinaryOpMutation/BinaryOpMutation.sol 2. Suppose we want our paps to be reported relative to benchmarks/BinaryOpMutation. We can run: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 --sourceroot benchmarks/BinaryOpMutation cat gambit_out/mutants.log find gambit_out/mutants -name \"*.sol\" which will output: Generated 1 mutants in 0.13 seconds 1,BinaryOpMutation,BinaryOpMutation.sol,23:10, % ,* gambit_out/mutants/1/BinaryOpMutation.sol The reported filenames, and the offset path inside of gambit_out/mutants/1/, are now relative to the source root that we specified. 3. Finally, suppose we use a source root pat doesn't contain pe source file: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 1 --sourceroot scripts This will try to find the specified file inside of scripts, and since it doesn't exist Gambit reports the error: [ERROR gambit] [!!] Illegal Configuration: Resolved filename `/Users/USER/Gambit/benchmarks/BinaryOpMutation/BinaryOpMutation.sol` is not prefixed by the derived source root /Users/USER/Gambit/scripts Gambit prints an error and exits. ## Example 6: Running Gambit using a configuration file To run gambit with a configuration file, use the --json argument: bash gambit mutate --json benchmarks/config-jsons/test1.json The configuration file is a JSON file containing the command line arguments for gambit and additional configuration options: json { \"filename\": \"../10Power/TenPower.sol\", \"sourceroot\": \"..\", \"solc_remappings\": [ \"@openzeppelin=node_modules/@openzeppelin\" ], } --- In addition to specifying the command line arguments, you can list the specific mutants that you want to apply, the specific functions you wish to mutate, and more. See the benchmark/config-jsons directory for examples. Configuration Files Configuration files allow you to save complex configurations and perform multiple mutations at once. Gambit uses a simple JSON object format to store mutation options, where each --option VALUE specified on the CLI is represented as a \"option\": VALUE key/value pair in the JSON object. Boolean --flags are enabled by storing them as true: \"flag\": true. For instance, --no_overwrite would be written as \"no_overwrite\": true. As an example, consider the command from Example 1: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol To execute this using a configuration file you would write the following to example-1.json to the root of this repository and run gambit mutate --json example-1.json json { \"filename\": \"benchmarks/BinaryOpMutation/BinaryOpMutation.sol\" } Gambit also supports using multiple configurations in the same file: instead of a single JSON object, your configuration file should contain an array of objects: json [ { \"filename\": \"Foo.sol\", \"contract\": \"C\", \"functions\": [\"bar\", \"baz\"], \"solc\": \"solc8.12\", \"solc_optimize\": true }, { \"filename\": \"Blip.sol\", \"contract\": \"D\", \"functions\": [\"bang\"], \"solc\": \"solc8.12\" \"mutations\": [ \"binary-op-mutation\", \"swap-arguments-operator-mutation\" ] } ] This configuration file will perform all mutations on Foo.sol's functions bar and baz in the contract C, and only binary-op-mutation and swap-arguments-operator-mutation mutations on the function bang in the contract D. Both will compile using the Solidity compiler version solc5.12. Paths in Configuration Files Relative paths in a Gambit configuration file are relative to the parent directory of the configuration file. So if the JSON file listed above was moved to the benchmarks/ directory the \"filename\" would need to be updated to BinaryOpMutation/BinaryOpMutation.sol. Results Directory gambit mutate produces all results in an output directory (default: gambit_out). Here is an example: bash gambit mutate -f benchmarks/BinaryOpMutation/BinaryOpMutation.sol -n 5 tree gambit_out -L 2 which produces: Generated 5 mutants in 0.15 seconds gambitout ├── gambitresults.json ├── input_json ├── mutants │ ├── 1 │ ├── 2 │ ├── 3 │ ├── 4 │ └── 5 └── mutants.log --- ## CLI Options |Option|Description| |---|---| |-o, --outdir|specify Gambit's output directory (defaults to gambit_out)| |--no_overwrite|do not overwrite an output directory; if the output directory exists, print an error and exit| |-n, --num_mutants|randomly downsample to a given number of mutants.| |-s, --seed|specify a random seed. For reproducibility, Gambit defaults to using the seed 0. To randomize the seed use --random_seed| |--random_seed|use a random seed. Note that this overrides any value specified by --seed| |--contract|specify a specific contract name to mutate; by default mutate all contracts| |--functions|specify one or more functions to mutate; by default mutate all functions| |--mutations|specify one or more mutation operators to use; only generates mutants that are created using the specified operators| |--skip_validate|only generate mutants without validating them by compilation| ## Mutation Operators |Mutation Operator|Description|Example| |---|---|---| |binary-op-mutation|Replace a binary operator with another|a+b -> a-b| |unary-operator-mutation|Replace a unary operator with another|~a -> -a| |require-mutation|Alter the condition of a require statement|require(some_condition()) -> require(true)| |assignment-mutation|Replaces the right hand side of an assignment|x = foo(); -> x = -1;| |delete-expression-mutation|Replaces an expression with a no-op (assert(true))|foo(); -> assert(true);| |if-cond-mutation|Mutate the conditional of an if statement|if (C) {...} -> if (true) {...}| |swap-arguments-operator-mutation|Swap the order of non-commutative operators|a - b -> b - a| |elim-delegate-mutation|Change a delegatecall() to a call()|_c.delegatecall(...) -> _c.call(...)| |function-call-mutation|(Disabled) Changes arguments of a function|add(a, b) -> add(a, a)| |swap-arguments-function-mutation|(Disabled) Swaps the order of a function's arguments|add(a, b) -> add(b, a)|"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-0", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 0, "text": "## Certora Technology White Paper June 29, 2022 Certora is a leading provider of technology and services for eliminating vulnerabilities in smart contracts. This white paper outlines the technology that makes Certora unique, explaining both its power and its current limitations. We assume readers are familiar with the basic ideas of smart contracts. More details of the examples mentioned in this document can be found in the demo area of our website. ### Certora Tool Suite Certora offers a suite of tools for auditing smart contracts, including both the detection of vulnerabilities and the generation of assurances that essential properties always hold. The core of the tool suite is the Certora Prover, a verification tool that takes a low-level EVM bytecode program and a specification written in CVL (Certora Verification Language). The Prover analyzes the code and the spec together to identify scenarios where the code deviates from the specification. The technology automatically locates critical vulnerabilities that even the best auditor may miss and increases confidence in code security by proving that certain key properties are satisfied. At a high level, the Certora Prover is essentially a sophisticated compiler, translating the smart contract bytecode and the specified properties into a mathematical formula that concisely defines the exact conditions under which the program may violate the expected behavior specified in the properties. This formula is fed into state-of-the-art open source solvers that examine the infinite space of possible executions and find any violating scenarios, which are then translated back by the compiler into the domain of the smart contract. Additionally, Certora also has tools for analyzing the complexity of contracts, specification checking using mutations and vacuity detection, and a fuzzer for light-weight verification. ### Verification vs. Auditing Since a vulnerability in a smart contract can expose the creator of the contract and its users to huge losses, contract developers are eager to eliminate vulnerabilities before their contracts are deployed. Many security companies provide services based on manual auditing, either performing the auditing with their own experts or outsourcing it through a vulnerability bounty program. Manual audits, while essential, have serious limitations. Certora's tool suite complements them in many ways: 1. Automatic Rechecking. Every time the code changes, a new audit is needed which requires hiring the same team of external auditors. Scheduling recurring audits ahead of time at a predetermined cadence can be a significant operational challenge; different versions of the same project may therefore end up with different auditors because of which the historical context of project codebase / concerns is lost. In contrast, Certora's approach lets developers specify critical properties early in the development process which can then be automatically rechecked whenever the code changes --- Specify Once, Verify Often! 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-1", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 1, "text": "Collaborative Codification. Auditing is usually performed by external security personnel who have extensive general experience but may lack a deep prior understanding of the specific contract at hand. Certora's property-based approach lets developers and auditors work together to formulate properties that codify security-relevant aspects of the contract, allowing more application-specific and deeper logical flaws to be detected. 3."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-2", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 2, "text": "Stronger Guarantees. Any small mistake or oversight from an auditor can cause a critical vulnerability to be missed. The Certora tool suite has found major vulnerabilities even after extensive auditing. This is not surprising because errors are --- practically inevitable in manual audits. A user of the Certora tool on the other hand, focuses all their attention on specifying the properties themselves. Since the checking of the properties is fully automated, a successful check guarantees mathematically that the property holds: the Prover, unlike a human auditor, never makes reasoning errors. A failed check helps the developer by pinpoint a failing scenario."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-3", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 3, "text": "(4) Ready Availability. The best auditors are typically booked 18 months in advance. Due to the steep learning curve, lack of structured onboarding resources/initiatives, and high expectations from auditors, Ethereum may continue to endure a significant shortage of code security professionals in the foreseeable future. Because Certora’s approach leverages automatic verification techniques to reduce the amount of repetitive effort needed, its services are more readily available to developers/experts who can specify properties on their code. (5) Shift Left. The Secure Software Development Lifecycle in Web3 has unfortunately been reduced to a 3-step “Build-Audit(s)-Launch” linear timeline where there are enormous and unrealistic expectations from the audit phase(s) which is unsustainable. Specifying and checking of security properties by developers/experts using Certora's tools will catalyze a “Shift Left” effort where security will be better addressed and significantly improved at earlier stages of the application lifecycle. Preliminary experience suggests that auditing and formal verification work well together. Manual audits can help specify or identify missing rules in formal verification while formal verification can identify corner cases missed by manual audits, especially when code is continuously modified over time. Verification vs. Testing Like any software, smart contracts need to be tested. But testing may not be sufficient for exposing security flaws due to a few limitations. (1) Path Explosion. Every if-statement in a function potentially doubles the number of paths that an execution can take. So paths typically grow exponentially with the size of the code. Testing is rarely able to cover even a high proportion of paths, let alone all of them, so some paths are omitted, leaving dangerous gaps in analysis. Tools based on verification, such as the Certora Prover, consider every path. (2) State Explosion. The number of states of a contract likewise grows exponentially with the number of state components. A tester will usually try and pick some representative states to test, along with some outliers and some that are suspected to be tricky cases. But these will only cover a tiny proportion of the states that can arise in practice. Tools based on verification, such as the Certora Prover, consider every state. (3) Test Suite Cost. A comprehensive test suite is very tedious and difficult to write, maintain, and comprehend. Expected properties, which are the basis of Certora's technology, are usually much more compact because a single property generalizes over a large number of test cases. Experience to Date Certora has analyzed hundreds of smart contracts for a variety of clients, finding serious vulnerabilities, which, if undetected, might have led to major losses. Below is a small select set of interesting vulnerabilities that the Certora Prover has detected: - Transfer-related. When the sender's address is the same as the receiver's (to), a contract might allow a transaction in which the sender transfers assets to their own account. Contrary to what one might expect, a typical transfer code will produce the wrong results in this case, allowing the sender to create assets out of thin air: function transfer(address to, uint amount) public { uint srcBalance = balances[msg.sender]; uint dstBalance = balances[to]; balances[msg.sender] = srcBalance - amount; balances[to] = dstBalance + amount; } Solvency-related. A common class of vulnerabilities that the Certora Prover has successfully detected in multiple contracts is when a user receives assets for free without paying any money in return. We have found this problem in some ERC20 contracts. The KashiPair case study described in the following section is an example of this vulnerability. Staking-related."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-4", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 4, "text": "Systems based on proof-of-stake distribute rewards based on time periods. They calculate the current rewards to be sent out using the value of elapsed time: block.timestamp - lastTimestamp. But if lastTimestampis not initialized to block.timestamp when creating the contract or when starting to distribute rewards, this measure of --- time will be equal to block.timestamp - 0, which is a huge number, and the amount of rewards to be distributed will be a lot more than expected. Edge case-related."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-5", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 5, "text": "CVL's expressivity is particularly well suited for writing properties about mathematical formulae appearing in smart contracts. An example of this is the famous Maker DAO case study described in the following section. Relatedly, the Certora Prover has also found vulnerabilities due to overflow / underflow in computations. ## Case Studies To give a sense of Certora's impact in practice, this section presents three case studies that demonstrate how the Certora Prover was able to find Vulnerabilities in real and complex smart contracts. ### Constant Product Pool Trident is SushiSwap’s platform for launching and running liquidity pools and managing their interactions with users; it is expected to handle billions of dollars worth of SUSHI tokens. The Certora Prover found a pool-draining exploit in the Trident protocol which was subsequently fixed by SushiSwap. The exploit concerns the automated market maker contract for Constant Product Pools (CPPs). In a CPP, Liquidity Providers (LPs) deposit two types of underlying tokens (Token0 and Token1) in exchange for LP tokens. They can later \"burn\" (or exchange) LP tokens to reclaim a proportional amount of Token0 and Token1. Trident users can swap one underlying token for the other by transferring some tokens of one type to the pool and receiving some number of the other token. To determine the exchange rate, the pool returns enough tokens to ensure that (reserves0 ⋅ reserves1)pre (reserves0 ⋅ reserves1)post where reserves0 and reserves1 are the reserves for Token0 and Token1 respectively. The ability to burn LP tokens into underlying tokens suggests an important invariant: if there are any LP tokens (the totalSupply > 0), then neither reserves0 nor reserves1 should ever become zero (otherwise the pool could not produce the underlying tokens). More formally, the CVL property we wrote was: (totalSupply = 0 <=> reserves0 = 0) && (totalSupply = 0 <=> reserves1 = 0) We ran the Certora Prover on the Trident Protocol to verify this invariant and found that an operation called burn-single violates it. The burn-single operation combines a burn and a swap: it first burns LP tokens to produce both kinds of underlying tokens, then swaps one type for the other (producing only a single kind of underlying token). Even though the swap() and burn() operations maintain the invariant, the combined operation had a flaw that allowed a malicious user to drain the pool."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-6", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 6, "text": "More details on this can be found in our blog post. ### Kashi Pair We used the Certora Prover to verify the KashiPair contract, which allows users to deposit assets as collateral and to borrow other assets against them with flexible oracles and interest rates based on the utilization of the system. The Certora Prover found multiple vulnerabilities in KashiPair. Here we discuss one of the properties that KashiPair violated, called the antimotonicity of liquidation. Consider the liquidate method shown below."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-7", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 7, "text": "It is called as part of the batchCalls method, which invokes multiple transactions. /* * Liquidation of a user that is in insolvent state. * user - address to liquidate * to - address to receive collateral */ function liquidate(address user, address to) public { require(!_isSolvent(user), \"user is solvent\"); uint256 borrow = userBorrowAmount[user]; uint256 collateral = userCollateralAmount[user]; userBorrowAmount[user] = 0; userCollateralAmount[user] = 0; --- // msg.sender gives borrowToken to the system and this contract // sends collateralToken to 'to' borrowToken.transferFrom(msg.sender, address(this), borrow); collateralToken.transfer(to, collateral); } /* * Allows calling a few functions in a batch mode * and interact with other contracts. */ function batchCalls(address[] calldata callee, bytes[] calldata datas) external { ... callee[i].call(datas[i]); } ``` One important properties of liquidate is that borrow and collateral must be inversely proportional, i.e., ``` // before calling liquidate {b = borrowToken.balanceOf(system) /\\ c = collateralToken.balanaceOf(system)} liquidate(x, y) // after calling liquidate {borrowToken.balanceOf(system) > b <=> collateralToken.balanaceOf(system) < c} `` This property was written in CVL (see later sections in \"Rules\" for more details on how to write these properties) by the Certora team together with the SushiSwap team, and a violation was found. It turns out that in this version ofliquidate, it is possible to usebatchCallsto invoke a call toliquidatewheremsg.senderis set to the current contract's address which allows the system to transfer the collateral to the current contract without the latter paying any amount in return. This vulnerability was later fixed by the SushiSwap team by adding an additional requirement at the top of theliquidatemethod that does not allowmsg.sender` to be the same as the current contract's address. require(msg.sender != address(this)); More details can be found in our verification report. Maker DAO The Maker protocol consists of the smart contracts that create and sustain the DAI stablecoin. DAI is backed by debt. Debt is either assigned to a Vault, meaning it is associated with a lien against some collateral asset, or it is “unbacked”, meaning it is the protocol’s (i.e., MKR holders’) responsibility. These two sources of debt, when added, should equal the sum of all DAI balances. This crucial invariant is called the “Fundamental Equation of DAI” (FEoD): dai == vice + sumOfVaultDebt where dai is the sum over all DAI balances and vice is the total unbacked debt. The FEoD is the most famous Multi-Collateral DAI “invariant”, known since at least 2018, and until recently it was believed to be mathematically provable. The Maker team together with Certora wrote down this invariant in CVL and used the Certora Prover to prove it."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-8", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 8, "text": "Surprisingly, the Prover found a violation of this invariant and generated a concrete counterexample showing that the property did not hold after the execution of the so-called init() function. Crucially, the counterexample showed that the property was true in the \"prestate\" (before init() was invoked) but it was no longer true in the \"post-state\" (after init()'s execution). Such a counterexample is known as a counterexample to induction, i.e., it shows a scenario in which the system transitioned from a state where the property was true to a state where it is not true (see {ref}later sections <whitepaper- technical> for more details on invariants). It is possible that the counterexample is not a \"true\" counterexample, i.e., the starting state of the \"bad\" transition may not actually be reachable. This happens if the invariant's definition failed to account for some system property."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-9", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 9, "text": "This was however not the case here. The Maker team in fact identified a sequence of function invocations that could lead to this violation in practice. The next deployment of the protocol will have a fix to ensure that the invariant is satisfied. More details including the CVL features used in writing the specification can be found in a recent blog post."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-10", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 10, "text": "Key Features 1. Fully Automated Verification The Certora Prover offers push-button verification. The user writes the specification and invokes the Certora Prover with the smart contract to be verified and the specification as arguments. From there on, the user is not required to intervene in the verification process. Ultimately, the Certora Prover produces a user-friendly report listing both properties that were satisfied and those that were not. 2. Generation of Counterexample Scenarios Merely knowing that a property was not satisfied by the smart contract is not sufficient for a user to understand where the contract might have vulnerabilities. Therefore, the Certora Prover makes it easier to interpret the verification result by presenting the user with a counterexample. The counterexample represents a concrete state of the smart contract which helps the user narrow down the root cause of the specification violation. --- ### Rich Specification Language Unlike traditional unit tests, which describe the output for a particular input, the Certora Prover considers the entire (potentially infinite) space of possible inputs. Instead of writing a large number of test cases, one writes a more compact and general specification in CVL. CVL supports invariants, parametric functions, uninterpreted functions, \"ghost\" functions that can model contract states not explicitly present in the contract, and relational properties. This allows reasoning about infinite behaviors, and also allows equivalence checking between programs (for example that a code refactoring doesn't introduce new behaviors). ### Powerful Interactive Support Since formal verification is an undecidable problem, there will always be properties that cannot be verified automatically for some programs. The Certora Prover provides a rich set of features for approximating difficult-to-verify code, giving users fine-grained tools for trading soundness for completeness. These include: (1) bounding the number of executed loop iterations or providing checked loop invariants (2) breaking large code into several pieces which are modularly verified. ### Spec Checking One of the hardest challenges in formal verification is coming up with the right specification. Errors in a specification can lead users to incorrectly conclude that their contracts are correctly implemented. Therefore, Certora implements techniques for preventing certain patterns of bad specifications. For example, a tautology invariant of the form x = 5 ==> x > 0 will be flagged as a potentially incorrect specification by the system. Certora also offers a mutation verification tool that automatically generates and verifies variations of the original contract, generated by mutating the code. Mutants that pass verification may indicate that the specification had loopholes that can be fixed. ## Design Principles Certora's approach is guided by a number of design principles: 1. Verify What You Execute. The tool suite is built on the EVM bytecode instead of the Solidity code. This decision significantly increases security as we verify the code that is actually executed. In particular, it does not trust the compiler (e.g., Solidity compiler) that generates EVM bytecode from the source. This decision does complicate the verification problem as the compiler often generates sophisticated, optimized code. Certain information is lost in the translation, which adds to the verification complexity, and complicates diagnosability when verification fails. The Certora Prover is able, however, to perform a static program analysis to reconstruct this information when possible to aid users in diagnosing counterexamples. 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-11", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 11, "text": "Trust But Verify. The EVM provides a rich interface. Moreover, the compilers that generate EVM bytecode from the source code utilize dynamic loading, making general-purpose verification nearly impossible. Therefore, we place certain restrictions on the analyzed EVM bytecode to make verification scalable. Our static analysis algorithm enforces these restrictions. When the static analysis algorithm fails, we analyze the failure. In some cases, this reflects a vulnerability in the Solidity compiler, which is reported to the Solidity team. We are constantly working to improve and generalize the static analyses to handle more smart contracts. 3."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-12", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 12, "text": "Separate The Specification From The Code. The CVL specification is written in a separate file, making it usable across different code versions of the same contract. Additionally, Certora has curated a database of general correctness properties that can be easily adapted for different contracts. Having a separate specification language also makes it easier to use the properties across different smart contract languages like Vyper, and other blockchains like Solana. ## Technical Details This section provides more details about how properties are specified and checked using the Certora tool suite. ### Formal Specification One of the biggest challenges in software development is specifying the intended behavior of the program. Developers often use unit tests to specify the expected outputs for given inputs, but unit tests can only enumerate a finite number of input scenarios to be tested. In contrast to unit tests, specifications in CVL describe the expected output for every possible input. Since this article describes only some of the mechanisms used in CVL specifications; we refer readers to the reference manual that contains complete details. --- ## Inductive Invariants A program is a description of a state transition system. A specification of a program is a predicate that should hold on all reachable states of the state transition system. That specification is an invariant if it does in fact hold on all reachable states. If it does not hold on all reachable states, the program has a vulnerability. An input which causes the program to reach a state that does not satisfy the specification is a counterexample. It shows that the specification is not an invariant for the program. For example, in a contract that keeps bank account balances, an invariant may require that the total balance is equal to the sum of all balances. Inductive invariants are invariants that are preserved by arbitrary executions. An inductive invariant must hold at all initial states of the transition system. Additionally, when a transition is executed in an arbitrary state, s, that satisfies the invariant, and s steps to state, s', the invariant must hold at s'. Inductive invariants can guarantee that a program is correct irrespective of the number of instructions executed. A counterexample to induction is a transition from a state satisfying the invariant into a bad state violating the invariant. Unlike a regular counterexample described earlier, a counterexample to induction does not necessarily indicate that the program has a vulnerability, because it may reflect a state that may be impossible for the program to reach; it may only indicate that the specification is not inductive. Such specifications can be made inductive by strengthening."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-13", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 13, "text": "This mimics proofs by induction. To learn more about inductive invariants, we refer the reader to the presentation Inductive Reasoning about Smart Contracts Safety. You can learn more about invariants in CVL in the documentation. ## Rules A rule in CVL describes properties of possible transitions of the system. In smart contracts, such transitions can be made by invoking functions. A rule can therefore be viewed as a \"wrapper\" around functions invoked from the smart contract being verified. The call is \"wrapped\" by predicates that must hold before and after the function call is made. A rule must describe: (1) the state before the transition, (2) the transition, (3) and the state after the transition. Describing a state means setting requirements on the set of possible states. Describing a transition means specifying which function is invoked and what conditions the inputs satisfy. Using the notation of Hoare triples, a rule can be written as: { state before }; f(function inputs); { state after }; For example, we might want to track the change in the balance of user Alice when user Bob performs a deposit call to a pool contract. The triple above can take the form: { uint256 x = BalanceOf(Alice) }; Deposit(Bob, amount); { BalanceOf(Alice) == x }; Verification via Constraint Solving The Certora Prover compares the behavior of the bytecode and the spec to find vulnerabilities and formally prove their absence. Intuitively, the idea is to model both the semantics of the EVM and the specifications as logical formulas in a language known as SMT (Satisfiability Modulo Theories)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-14", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 14, "text": "SMT formulas are constraints over symbolic variables. Symbolic variables are very different from program variables - their value can be arbitrary. For example, the formula x * x > 4 is satisfiable, e.g., for x = 3. However, the formula x * x + 1 < 0 is not satisfiable. A solver for SMT can generate a formal proof that this formula is not satisfiable for any x and it can also generate a model for the former formula that is satisfiable. ## Boolean Satisfiability A classic problem in computer science is boolean satisfiability: given a boolean (0, 1) formula over logical variables: v1, v2, ..., vk, is there a value to the logical variables that makes the formula true. For example, a && !a is false for both a = 0 and a = 1, so it is not satisfiable. The satisfiability problem for n variables can be solved by enumerating all the $2^n$ combinations of values. This becomes rapidly intractable as n grows. Worse, a famous theoretical result of computer science demonstrated that this problem is inherently intractable: there are no algorithms that can solve every instance more efficiently than brute force enumeration. In practice, however, it was discovered that most instances of the problem that actually arise can be solved efficiently, and an --- extensive ecosystem of tools known as SAT solvers has been developed. A state of the art SAT solver can often find a solution to a formula with thousands of variables in seconds. Formal Verification by Reduction to Satisfiability Given a loop free program and an assertion about it, one can verify the assertion using Boolean Satisfiability (SAT). For example, Figure 1 shows the control flow of a small program. In order to determine if the assertion at the end of the program holds, we check the SAT query: ((a && x) \\/ (!a && !x)) /\\ ((b && y) \\/ (!b && !y)) /\\ ((x && !y) \\/ (!x && y)) Notice how this formula compactly defines 4 paths of the program. The SAT solver identifies that for a = 0 and b = 1, the values of x and y are 0 and 1 respectively, which shows a violation of the assertion. Figure 1: A program's control flow wip an assertion X == Y pat is not always true. Modern SAT solvers can also determine that formulas are not satisfiable, often in clever ways without enumerating all values. They enable formally verifying the program on all paths."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-15", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 15, "text": "For example, Figure 2 shows a code fragment with a valid assertion. Figure 2: An example wip a valid assertion. In this case, the SAT query ((a && x && b) \\/ (!a && !x && !b)) /\\ ((b && y) \\/ (!b && !y)) /\\ ((x && !y) \\/ (!x && y)) is not satisfiable for all the values of a, b, x, and y. Therefore, the assertion is valid. Beyond Booleans: SMT Boolean formulas are only good for representing finite state spaces. For a smart contract, the state space typically comprises structures (such as arrays) that are unbounded, so a richer notion of satisfiability is needed. SMT(Satisfiability Modulo Theories) were developed for exactly this purpose, and extend the kind of constraint solving previously applied to SAT to more general formulas. There exist many open source software for solving SMT constraints, including Z3, CVC5, Yices, and Vampire. The Certora verifier utilizes all of these solvers. These solvers can generate counterexamples and formal proofs in many interesting cases. Speeding Up Constraint Solving with Static Analysis Smart contracts often use complex mathematical formulae which involve non-linear arithmetic. SMT solvers struggle to solve these queries. Furthermore, the Solidity compiler generates nontrivial instructions that manipulate memory in nontrivial ways, often using dynamic loading to hide the program's control flow. These strategies make formal reasoning about program correctness using SMT solvers even harder by requiring the solvers to infer complex facts about the program. To mitigate this, Certora has developed sophisticated static analysis algorithms (also known as abstract interpretation) for automatically inferring nontrivial invariants from the bytecode in a preprocessing phase. For many common programs, Certora's static analysis algorithm can mitigate the complexity of SMT solving without sacrificing coverage. For example, consider the following EVM code snippet: ``` l1: mem[index] = “foo()”; l2: mem[index + 4] = x; l3: mem[otherIndex] = 44; l4: send(contract, mem[index .. index + 36]) ``` The Solver needs to ensure that the only invoked method in the send command on line l4 is foo. This requires proving that the writes to memory on lines l2 and l3 do not change the content of mem[index]`. This is in general an undecidable problem, and a technique that reasons about this is called pointer analysis. The Certora Prover implements pointer analysis which enforces invariants on the patterns of memory access generated by the compiler in order to solve the problem in many cases. --- ## Modularity Automatically verifying that a contract satisfies a specification is an undecidable problem in theory and can have high complexity in practice. To reduce the resources required to complete the proof, a user of the Certora Prover can take several approaches to simplify the problem. An important class of techniques is based on modularity, i.e., splitting the verification problem into multiple independent subproblems. Under modular verification, the user selects some methods from the smart contract to summarize. A summary approximates the behavior of the method. By replacing the method with its summary, the user simplifies the overall verification problem for the Certora Prover. Many different kinds of summarization are possible. For example, the body of the method could be summarized as returning an arbitrary value, a constant, some ghost state, or some other simplified description of the method's behavior. With summaries, instead of verifying the entire program in one pass, the problem is broken down into two kinds of subproblems. First, in the entire verification condition of the program instead of using the method's definition, we use its summary. Second, we check that the method's summary is a correct approximation of the actual method definition. In practice, it is sometimes useful to omit the second check to give rule writers maximum flexibility. ## The Certora Prover Architecture The Certora Prover implements a sophisticated tool chain for verifying low level code. It currently supports EVM bytecode but its tool chain is generic and can be adapted to other bytecodes, e.g., eBPF and Web Assembly. Figure 1 depicts the Certora Prover architecture. It operates on EVM bytecode which is a stack-based language. A decompiler maps each stack location into a symbolic value, called a register, and then converts the bytecode instructions into instructions over registers. A similar technique was implemented in Soot."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-16", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 16, "text": "A static analysis algorithm then infers sound invariants about the code, drastically simplifying the verification task. Then, the VC generator outputs a set of mathematical constraints which describes the conditions under which the program can violate the rules. Finally, the Certora Prover invokes off-the-shelf SMT solvers that automatically search for solutions to the mathematical constraints which represent violations of the rules. As described earlier, this is an undecidable problem and these solvers can fail in certain cases by timing out with an inconclusive answer. The Certora Prover takes the result from the solver, processes it to generate a detailed report, and presents it to the client/user of the Prover. ## Related Tools and Other Approaches Smart contract correctness has received considerable attention in industry and Academia."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-17", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 17, "text": "Below are some related tools that use approaches both similar and orthogonal to Certora's. ### Unit Testing and Fuzzing Testing and fuzzing of smart contracts can be very effective in tools like Foundry, MythX, Manticore, and Echidna. The Certora Prover improves coverage beyond these tools by using the powerful CVL specifications and harnessing SMT solvers for identifying potentially rare paths showing cases where violations occur. ### Traditional Static Analysis Lightweight static analysis tools that work directly on source code like Slither can also be used to identify potential vulnerabilities in smart contracts. The Certora Prover, on the other hand, works at the bytecode level and can provide stronger guarantees. It provides witnesses for rule violations and formal correctness guarantees for rules that are verified, both of which are beyond the scope of simple static analyses that do not take into account control flow. This however, makes the Certora Prover much more computationally expensive and slower to run on larger contracts. ### Proof Assistants --- ## Proof assistants Proof assistants such as K, Coq, and Isabelle/HOL implement a radically different approach for obtaining provably correct code. The programmer writes a mathematical proof about the model and additional tools extract code from the proofs. Instead, using the Certora Prover might feel similar to unit testing and fuzzing. In the Certora Prover, the ground truth against which the bytecode is verified is the high-level CVL specification. ## Conclusions The Certora Prover supports reasoning about all executions of an Ethereum bytecode program. The Prover takes as input the bytecode program along with a specification written in CVL. The goal of the Prover is to check whether all executions of the bytecode satisfy the specification. The Prover achieves this by analyzing the bytecode and converting it, together with the specification, into a system of constraints. These constraints are then solved by a suite of underlying SMT solvers. The solvers either report that all executions are correct, or they return a specific input that causes an execution that violates the specification. In either case, the information is translated into a high-level format and shown to the user. The main challenge with using any formal verification technology is complexity. For practical contracts and specifications, the constraints generated by the Prover can be very challenging for the solvers. In these cases, the user can break down the proof by summarizing complex pieces of code. With good summaries, each piece of the proof can be handled by the solver, and the pieces add up to a proof of the original specification. ## Certora Technology White Paper June 29, 2022 Certora is a leading provider of technology and services for eliminating vulnerabilities in smart contracts. This white paper outlines the technology that makes Certora unique, explaining both its power and its current limitations. We assume readers are familiar with the basic ideas of smart contracts. More details of the examples mentioned in this document can be found in the demo area of our website. ## Certora Tool Suite Certora offers a suite of tools for auditing smart contracts, including both the detection of vulnerabilities and the generation of assurances that essential properties always hold. The core of the tool suite is the Certora Prover, a verification tool that takes a low-level EVM bytecode program and a specification written in CVL (Certora Verification Language). The Prover analyzes the code and the spec together to identify scenarios where the code deviates from the specification. The technology automatically locates critical vulnerabilities that even the best auditor may miss and increases confidence in code security by proving that certain key properties are satisfied. At a high level, the Certora Prover is essentially a sophisticated compiler, translating the smart contract bytecode and the specified properties into a mathematical formula that concisely defines the exact conditions under which the program may violate the expected behavior specified in the properties. This formula is fed into state-of-the-art open source solvers that examine the infinite space of possible executions and find any violating scenarios, which are then translated back by the compiler into the domain of the smart contract. Additionally, Certora also has tools for analyzing the complexity of contracts, specification checking using mutations and vacuity detection, and a fuzzer for light-weight verification. ## Verification vs. Auditing --- ## Since a vulnerability in a smart contract can expose the creator of the contract and its users to huge losses, contract developers are eager to eliminate vulnerabilities before their contracts are deployed. Many security companies provide services based on manual auditing, either performing the auditing with their own experts or outsourcing it through a vulnerability bounty program. Manual audits, while essential, have serious limitations. Certora's tool suite complements them in many ways: |(1) Automatic Rechecking.|Every time the code changes, a new audit is needed which requires hiring the same team of external auditors. Scheduling recurring audits ahead of time at a predetermined cadence can be a significant operational challenge; different versions of the same project may therefore end up with different auditors because of which the historical context of project codebase / concerns is lost. In contrast, Certora's approach lets developers specify critical properties early in the development process which can then be automatically rechecked whenever the code changes --- Specify Once, Verify Often!| |---|---| |(2) Collaborative Codification.|Auditing is usually performed by external security personnel who have extensive general experience but may lack a deep prior understanding of the specific contract at hand. Certora's property-based approach lets developers and auditors work together to formulate properties that codify security-relevant aspects of the contract, allowing more application-specific and deeper logical flaws to be detected.| |(3) Stronger Guarantees.|Any small mistake or oversight from an auditor can cause a critical vulnerability to be missed. The Certora tool suite has found major vulnerabilities even after extensive auditing. This is not surprising because errors are practically inevitable in manual audits. A user of the Certora tool on the other hand, focuses all their attention on specifying the properties themselves. Since the checking of the properties is fully automated, a successful check guarantees mathematically that the property holds: the Prover, unlike a human auditor, never makes reasoning errors. A failed check helps the developer by pinpoint a failing scenario.| |(4) Ready Availability.|The best auditors are typically booked 18 months in advance. Due to the steep learning curve, lack of structured onboarding resources/initiatives, and high expectations from auditors, Ethereum may continue to endure a significant shortage of code security professionals in the foreseeable future. Because Certora’s approach leverages automatic verification techniques to reduce the amount of repetitive effort needed, its services are more readily available to developers/experts who can specify properties on their code.| |(5) Shift Left.|The Secure Software Development Lifecycle in Web3 has unfortunately been reduced to a 3-step “Build-Audit(s)-Launch” linear timeline where there are enormous and unrealistic expectations from the audit phase(s) which is unsustainable. Specifying and checking of security properties by developers/experts using Certora's tools will catalyze a “Shift Left” effort where security will be better addressed and significantly improved at earlier stages of the application lifecycle.| Preliminary experience suggests that auditing and formal verification work well together. Manual audits can help specify or identify missing rules in formal verification while formal verification can identify corner cases missed by manual audits, especially when code is continuously modified over time. ## Verification vs. Testing Like any software, smart contracts need to be tested. But testing may not be sufficient for exposing security flaws due to a few limitations. |(1) Path Explosion.|Every if-statement in a function potentially doubles the number of paths that an execution can take. So paths typically grow exponentially with the size of the code. Testing is rarely able to cover even a high proportion of paths, let alone all of them, so some paths are omitted, leaving dangerous gaps in analysis. Tools based on verification, such as the Certora Prover, consider every path.| |---|---| |(2) State Explosion.|The number of states of a contract likewise grows exponentially with the number of state components. A tester will usually try and pick some representative states to test, along with some outliers and some that are suspected to be tricky cases. But these will only cover a tiny proportion of the states that can arise in practice. Tools based on verification, such as the Certora Prover, consider every state.| |(3) Test Suite Cost.|A comprehensive test suite is very tedious and difficult to write, maintain, and comprehend. Expected properties, which are the basis of Certora's technology, are usually much more compact because a single property| --- ## Experience to Date Certora has analyzed hundreds of smart contracts for a variety of clients, finding serious vulnerabilities, which, if undetected, might have led to major losses. Below is a small select set of interesting vulnerabilities that the Certora Prover has detected: - Transfer-related: When the sender's address is the same as the receiver's (to), a contract might allow a transaction in which the sender transfers assets to their own account. Contrary to what one might expect, a typical transfer code will produce the wrong results in this case, allowing the sender to create assets out of thin air. - Solvency-related: A common class of vulnerabilities that the Certora Prover has successfully detected in multiple contracts is when a user receives assets for free without paying any money in return. This problem has been found in some ERC20 contracts. - Staking-related: Systems based on proof-of-stake distribute rewards based on time periods. If the time calculation is not initialized correctly, the amount of rewards to be distributed can be a lot more than expected. - Edge case-related: Certora's expressivity is well suited for writing properties about mathematical formulae in smart contracts. Vulnerabilities due to overflow/underflow in computations have also been found. ## Case Studies To give a sense of Certora's impact in practice, this section presents three case studies that demonstrate how the Certora Prover was able to find vulnerabilities in real and complex smart contracts. ### Constant Product Pool Trident is SushiSwap’s platform for launching and running liquidity pools and managing their interactions with users. The Certora Prover found a pool-draining exploit in the Trident protocol which was subsequently fixed by SushiSwap. The exploit concerns the automated market maker contract for Constant Product Pools (CPPs). In a CPP, Liquidity Providers (LPs) deposit two types of underlying tokens (Token0 and Token1) in exchange for LP tokens. They can later \"burn\" (or exchange) LP tokens to reclaim a proportional amount of Token0 and Token1. Trident users can swap one underlying token for the other by transferring some tokens of one type to the pool and receiving some number of the other token. To determine the exchange rate, the pool returns enough tokens to ensure that: (reserves0 ⋅ reserves1)pre = (reserves0 ⋅ reserves1)post where reserves0 and reserves1 are the reserves for Token0 and Token1 respectively. The ability to burn LP tokens into underlying tokens suggests an important invariant: if there are any LP tokens (the totalSupply > 0), then neither reserves0 nor reserves1 should ever become zero. More formally, the CVL property we wrote was: (totalSupply = 0 <=> reserves0 = 0) && (totalSupply = 0 <=> reserves1 = 0) We ran the Certora Prover on the Trident Protocol to verify this invariant and found that an operation called burn-single violates it. The burn-single operation combines a burn and a swap, which can lead to issues in maintaining the underlying tokens. --- swap() and burn() operations maintain the invariant, the combined operation had a flaw that allowed a malicious user to drain the pool. More details on this can be found in our blog post. ## Kashi Pair We used the Certora Prover to verify the KashiPair contract, which allows users to deposit assets as collateral and to borrow other assets against them with flexible oracles and interest rates based on the utilization of the system. The Certora Prover found multiple vulnerabilities in KashiPair. Here we discuss one of the properties that KashiPair violated, called the antimotonicity of liquidation. Consider the liquidate method shown below."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-18", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 18, "text": "It is called as part of the batchCalls method, which invokes multiple transactions. |Function|Description| |---|---| |liquidate(address user, address to)|Liquidation of a user that is in insolvent state. user - address to liquidate to - address to receive collateral| |batchCalls(address[] calldata callee, bytes[] calldata datas)|Allows calling a few functions in a batch mode and interact with other contracts.| One important properties of liquidate is that borrow and collateral must be inversely proportional, i.e., before calling liquidate {b = borrowToken.balanceOf(system) / c = collateralToken.balanaceOf(system)} liquidate(x, y) after calling liquidate {borrowToken.balanceOf(system) > b <=> collateralToken.balanaceOf(system) < c} This property was written in CVL (see later sections in \"Rules\" for more details on how to write these properties) by the Certora team together with the SushiSwap team, and a violation was found. It turns out that in this version of liquidate, it is possible to use batchCalls to invoke a call to liquidate where msg.sender is set to the current contract's address which allows the system to transfer the collateral to the current contract without the latter paying any amount in return. This vulnerability was later fixed by the SushiSwap team by adding an additional requirement at the top of the liquidate method that does not allow msg.sender to be the same as the current contract's address. require(msg.sender != address(this)); More details can be found in our verification report. ## Maker DAO The Maker protocol consists of the smart contracts that create and sustain the DAI stablecoin. DAI is backed by debt. Debt is either assigned to a Vault, meaning it is associated with a lien against some collateral asset, or it is “unbacked”, meaning it is the protocol’s (i.e., MKR holders’) responsibility. These two sources of debt, when added, should equal the sum of all DAI balances. This crucial invariant is called the “Fundamental Equation of DAI” (FEoD): dai == vice + sumOfVaultDebt where dai is the sum over all DAI balances and vice is the total unbacked debt. The FEoD is the most famous Multi-Collateral DAI “invariant”, known since at least 2018, and until recently it was believed to be mathematically provable. The Maker team together with Certora wrote down this invariant in CVL and used the Certora Prover to prove it."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-19", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 19, "text": "Surprisingly, the Prover found a violation of this invariant and generated a concrete counterexample showing that the property did not hold after the execution of the so-called init() function. Crucially, the counterexample showed that the property was true in the \"prestate\" (before init() was invoked) but it was no longer true in the \"post-state\" (after init()'s execution). Such a counterexample is known as a counterexample to induction, i.e., it shows a scenario in which the system transitioned from a state where the property was true to a state where it is not true (see later sections in the whitepaper). --- technical> for more details on invariants). It is possible that the counterexample is not a \"true\" counterexample, i.e., the starting state of the \"bad\" transition may not actually be reachable. This happens if the invariant's definition failed to account for some system property."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-20", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 20, "text": "This was however not the case here. The Maker team in fact identified a sequence of function invocations that could lead to this violation in practice. The next deployment of the protocol will have a fix to ensure that the invariant is satisfied. More details including the CVL features used in writing the specification can be found in a recent blog post."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-21", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 21, "text": "## Key Features 1. Fully Automated Verification The Certora Prover offers push-button verification. The user writes the specification and invokes the Certora Prover with the smart contract to be verified and the specification as arguments. From there on, the user is not required to intervene in the verification process. Ultimately, the Certora Prover produces a user-friendly report listing both properties that were satisfied and those that were not. 2. Generation of Counterexample Scenarios Merely knowing that a property was not satisfied by the smart contract is not sufficient for a user to understand where the contract might have vulnerabilities. Therefore, the Certora Prover makes it easier to interpret the verification result by presenting the user with a counterexample. The counterexample represents a concrete state of the smart contract which helps the user narrow down the root cause of the specification violation. 3. Rich Specification Language Unlike traditional unit tests, which describe the output for a particular input, the Certora Prover considers the entire (potentially infinite) space of possible inputs. Instead of writing a large number of test cases, one writes a more compact and general specification in CVL. CVL supports invariants, parametric functions, uninterpreted functions, \"ghost\" functions that can model contract states not explicitly present in the contract, and relational properties. This allows reasoning about infinite behaviors, and also allows equivalence checking between programs (for example that a code refactoring doesn't introduce new behaviors)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-22", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 22, "text": "4. Powerful Interactive Support Since formal verification is an undecidable problem, there will always be properties that cannot be verified automatically for some programs. The Certora Prover provides a rich set of features for approximating difficult-to-verify code, giving users fine-grained tools for trading soundness for completeness. These include: (1) bounding the number of executed loop iterations or providing checked loop invariants (2) breaking large code into several pieces which are modularly verified. 5."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-23", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 23, "text": "Spec Checking. One of the hardest challenges in formal verification is coming up with the right specification. Errors in a specification can lead users to incorrectly conclude that their contracts are correctly implemented. Therefore, Certora implements techniques for preventing certain patterns of bad specifications. For example, a tautology invariant of the form x = 5 ==> x > 0 will be flagged as a potentially incorrect specification by the system. Certora also offers a mutation verification tool that automatically generates and verifies variations of the original contract, generated by mutating the code. Mutants that pass verification may indicate that the specification had loopholes that can be fixed. ## Design Principles Certora's approach is guided by a number of design principles: 1. Verify What You Execute. The tool suite is built on the EVM bytecode instead of the Solidity code. This decision significantly increases security as we verify the code that is actually executed. In particular, it does not trust the compiler (e.g., Solidity compiler) that generates EVM bytecode from the source. This decision does complicate the verification problem as the compiler often generates sophisticated, optimized code. Certain information is lost in the translation, which adds to the verification complexity, and complicates diagnosability when verification fails. The Certora Prover is able, however, to perform a static program analysis to reconstruct this information when possible to aid users in diagnosing counterexamples. 2. Trust But Verify The EVM provides a rich interface. Moreover, the compilers that generate EVM bytecode from the source code utilize dynamic loading, making general-purpose verification nearly impossible. Therefore, we place certain restrictions on the analyzed EVM bytecode to make verification scalable. Our static analysis algorithm enforces these restrictions. When the static analysis algorithm fails, we analyze the failure. In some cases, this reflects a vulnerability in the Solidity compiler, which is reported to the Solidity team. We are constantly working to improve and generalize the static analyses to handle more smart contracts. --- ### Technical Details This section provides more details about how properties are specified and checked using the Certora tool suite. #### Formal Specification One of the biggest challenges in software development is specifying the intended behavior of the program. Developers often use unit tests to specify the expected outputs for given inputs, but unit tests can only enumerate a finite number of input scenarios to be tested. In contrast to unit tests, specifications in CVL describe the expected output for every possible input. Since this article describes only some of the mechanisms used in CVL specifications; we refer readers to the reference manual that contains complete details. #### Inductive Invariants A program is a description of a state transition system. A specification of a program is a predicate that should hold on all reachable states of the state transition system. That specification is an invariant if it does in fact hold on all reachable states. If it does not hold on all reachable states, the program has a vulnerability. An input which causes the program to reach a state that does not satisfy the specification is a counterexample. It shows that the specification is not an invariant for the program. For example, in a contract that keeps bank account balances, an invariant may require that the total balance is equal to the sum of all balances. Inductive invariants are invariants that are preserved by arbitrary executions. An inductive invariant must hold at all initial states of the transition system. Additionally, when a transition is executed in an arbitrary state, s, that satisfies the invariant, and s steps to state, s', the invariant must hold at s'. Inductive invariants can guarantee that a program is correct irrespective of the number of instructions executed. A counterexample to induction is a transition from a state satisfying the invariant into a bad state violating the invariant. Unlike a regular counterexample described earlier, a counterexample to induction does not necessarily indicate that the program has a vulnerability, because it may reflect a state that may be impossible for the program to reach; it may only indicate that the specification is not inductive. Such specifications can be made inductive by strengthening."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-24", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 24, "text": "This mimics proofs by induction. To learn more about inductive invariants, we refer the reader to the presentation Inductive Reasoning about Smart Contracts Safety. You can learn more about invariants in CVL in the documentation. #### Rules A rule in CVL describes properties of possible transitions of the system. In smart contracts, such transitions can be made by invoking functions. A rule can therefore be viewed as a \"wrapper\" around functions invoked from the smart contract being verified. The call is \"wrapped\" by predicates that must hold before and after the function call is made. A rule must describe: (1) the state before the transition, (2) the transition, (3) and the state after the transition. Describing a state means setting requirements on the set of possible states. Describing a transition means specifying which function is invoked and what conditions the inputs satisfy. Using the notation of Hoare triples, a rule can be written as: { state before }; f(function inputs); { state after }; For example, we might want to track the change in the balance of user Alice when user Bob performs a deposit call to a pool contract. The triple above can take the form: { uint256 x = BalanceOf(Alice) }; Deposit(Bob, amount); { BalanceOf(Alice) == x }; Verification via Constraint Solving --- ## The Certora Prover The Certora Prover compares the behavior of the bytecode and the spec to find vulnerabilities and formally prove their absence. Intuitively, the idea is to model both the semantics of the EVM and the specifications as logical formulas in a language known as SMT (Satisfiability Modulo Theories)."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-25", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 25, "text": "SMT formulas are constraints over symbolic variables. Symbolic variables are very different from program variables - their value can be arbitrary. For example, the formula x * x > 4 is satisfiable, e.g., for x = 3. However, the formula x * x + 1 < 0 is not satisfiable. A solver for SMT can generate a formal proof that this formula is not satisfiable for any x and it can also generate a model for the former formula that is satisfiable. ## Boolean Satisfiability A classic problem in computer science is boolean satisfiability: given a boolean (0, 1) formula over logical variables: v1, v2, ..., vk, is there a value to the logical variables that makes the formula true. For example, a && !a is false for both a = 0 and a = 1, so it is not satisfiable. The satisfiability problem for n variables can be solved by enumerating all the $2^n$ combinations of values. This becomes rapidly intractable as n grows. Worse, a famous theoretical result of computer science demonstrated that this problem is inherently intractable: there are no algorithms that can solve every instance more efficiently than brute force enumeration. In practice, however, it was discovered that most instances of the problem that actually arise can be solved efficiently, and an extensive ecosystem of tools known as SAT solvers has been developed. A state of the art SAT solver can often find a solution to a formula with thousands of variables in seconds. ## Formal Verification by Reduction to Satisfiability Given a loop free program and an assertion about it, one can verify the assertion using Boolean Satisfiability (SAT). For example, Figure 1 shows the control flow of a small program. In order to determine if the assertion at the end of the program holds, we check the SAT query: ((a && x) \\/ (!a && !x)) /\\ ((b && y) \\/ (!b && !y)) /\\ ((x && !y) \\/ (!x && y)) Notice how this formula compactly defines 4 paths of the program. The SAT solver identifies that for a = 0 and b = 1, the values of x and y are 0 and 1 respectively, which shows a violation of the assertion. ## Modern SAT Solvers Modern SAT solvers can also determine that formulas are not satisfiable, often in clever ways without enumerating all values. They enable formally verifying the program on all paths. For example, Figure 2 shows a code fragment with a valid assertion. ## Beyond Booleans: SMT Boolean formulas are only good for representing finite state spaces. For a smart contract, the state space typically comprises structures (such as arrays) that are unbounded, so a richer notion of satisfiability is needed. SMT (Satisfiability Modulo Theories) were developed for exactly this purpose, and extend the kind of constraint solving previously applied to SAT to more general formulas. There exist many open source software for solving SMT constraints, including Z3, CVC5, Yices, and Vampire. The Certora verifier utilizes all of these solvers. These solvers can generate counterexamples and formal proofs in many interesting cases. --- ## Speeding Up Constraint Solving with Static Analysis Smart contracts often use complex mathematical formulae which involve non-linear arithmetic. SMT solvers struggle to solve these queries. Furthermore, the Solidity compiler generates nontrivial instructions that manipulate memory in nontrivial ways, often using dynamic loading to hide the program's control flow. These strategies make formal reasoning about program correctness using SMT solvers even harder by requiring the solvers to infer complex facts about the program. To mitigate this, Certora has developed sophisticated static analysis algorithms (also known as abstract interpretation) for automatically inferring nontrivial invariants from the bytecode in a preprocessing phase. For many common programs, Certora's static analysis algorithm can mitigate the complexity of SMT solving without sacrificing coverage. For example, consider the following EVM code snippet: l1: mem[index] = “foo()”; l2: mem[index + 4] = x; l3: mem[operIndex] = 44; l4: send(contract, mem[index .. index + 36]) The Solver needs to ensure that the only invoked method in the send command on line l4 is foo. This requires proving that the writes to memory on lines l2 and l3 do not change the content of mem[index]. This is in general an undecidable problem, and a technique that reasons about this is called pointer analysis. The Certora Prover implements pointer analysis which enforces invariants on the patterns of memory access generated by the compiler in order to solve the problem in many cases. ### Modularity Automatically verifying that a contract satisfies a specification is an undecidable problem in theory and can have high complexity in practice. To reduce the resources required to complete the proof, a user of the Certora Prover can take several approaches to simplify the problem. An important class of techniques is based on modularity, i.e., splitting the verification problem into multiple independent subproblems. Under modular verification, the user selects some methods from the smart contract to summarize. A summary approximates the behavior of the method. By replacing the method with its summary, the user simplifies the overall verification problem for the Certora Prover. Many different kinds of summarization are possible. For example, the body of the method could be summarized as returning an arbitrary value, a constant, some ghost state, or some other simplified description of the method's behavior. With summaries, instead of verifying the entire program in one pass, the problem is broken down into two kinds of subproblems. First, in the entire verification condition of the program instead of using the method's definition, we use its summary. Second, we check that the method's summary is a correct approximation of the actual method definition. In practice, it is sometimes useful to omit the second check to give rule writers maximum flexibility. ### The Certora Prover Architecture The Certora Prover implements a sophisticated tool chain for verifying low level code. It currently supports EVM bytecode but its tool chain is generic and can be adapted to other bytecodes, e.g., eBPF and Web Assembly. Figure 1 depicts the Certora Prover architecture. It operates on EVM bytecode which is a stack-based language. A decompiler maps each stack location into a symbolic value, called a register, and then converts the bytecode instructions into instructions over registers. A similar technique was implemented in Soot."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "index", "id": "d2a6ed83af6e-26", "chunk-uid": "d2a6ed83af6e", "chunk-page-index": 26, "text": "A static analysis algorithm then infers sound invariants about the code, drastically simplifying the verification task. Then, the VC generator outputs a set of mathematical constraints which describes the conditions under which the program can violate the rules. Finally, the Certora Prover invokes off-the-shelf SMT solvers that automatically search for solutions to the mathematical constraints which represent violations of the rules. As described earlier, this is an undecidable problem and these solvers can fail in certain cases by timing out with an inconclusive answer. The Certora Prover takes the result from the solver, processes it to generate a detailed report, and presents it to the client/user of the Prover. Figure 3: The Certora Prover Architecture ### Related Tools and Other Approaches --- ## Smart Contract Tools Comparison ### Unit Testing and Fuzzing Testing and fuzzing of smart contracts can be very effective in tools like Foundry, MythX, Manticore, and Echidna. The Certora Prover improves coverage beyond these tools by using the powerful CVL specifications and harnessing SMT solvers for identifying potentially rare paths showing cases where violations occur. ### Traditional Static Analysis Lightweight static analysis tools that work directly on source code like Slither can also be used to identify potential vulnerabilities in smart contracts. The Certora Prover, on the other hand, works at the bytecode level and can provide stronger guarantees. It provides witnesses for rule violations and formal correctness guarantees for rules that are verified, both of which are beyond the scope of simple static analyses that do not take into account control flow. This, however, makes the Certora Prover much more computationally expensive and slower to run on larger contracts. ### Proof Assistants Proof assistants such as K, Coq, and Isabelle/HOL implement a radically different approach for obtaining provably correct code. The programmer writes a mathematical proof about the model and additional tools extract code from the proofs. Instead, using the Certora Prover might feel similar to unit testing and fuzzing. In the Certora Prover, the ground truth against which the bytecode is verified is the high-level CVL specification. ## Conclusions The Certora Prover supports reasoning about all executions of an Ethereum bytecode program. The Prover takes as input the bytecode program along with a specification written in CVL. The goal of the Prover is to check whether all executions of the bytecode satisfy the specification. The Prover achieves this by analyzing the bytecode and converting it, together with the specification, into a system of constraints. These constraints are then solved by a suite of underlying SMT solvers. The solvers either report that all executions are correct, or they return a specific input that causes an execution that violates the specification. In either case, the information is translated into a high-level format and shown to the user. The main challenge with using any formal verification technology is complexity. For practical contracts and specifications, the constraints generated by the Prover can be very challenging for the solvers. In these cases, the user can break down the proof by summarizing complex pieces of code. With good summaries, each piece of the proof can be handled by the solver, and the pieces add up to a proof of the original specification."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "examples", "id": "d9b45df70d8a-0", "chunk-uid": "d9b45df70d8a", "chunk-page-index": 0, "text": "# Specification By Example bank/index.md map/index.md # Specification By Example bank/index.md map/index.md"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "98d5d26761a9-0", "chunk-uid": "98d5d26761a9", "chunk-page-index": 0, "text": "## Assert splitting Currently, each rule in the spec file generates a single result, highlighting a conclusion for the entire rule (fail, succeed, timeout, unknown). Even in the case when there are multiple assert statements within a rule, only a single result is generated. However, with the addition of assert each rule is now split into multiple sub rules, one for each of the asserts present in the rule. The rule is split not only on the user specified asserts, but also on the asserts that are automatically generated by the tool itself (the tool generates some assert statements to check against infinite recursion, stack overflows, etc.). ### How the sub rules are generated For each (TAC) assert command, a new sub rule ending at that assert command (target assert) is generated, ignoring the remaining code after the target assert. Moreover, all the asserts that come (topologically) before the target assert command are converted into assume commands in the sub rule. Thus, you can think of a sub rule as checking a single target assert assuming the previous asserts hold. Hence, you can think of assert splitting as follows: the following rule ```java rule checkElseNotExecuted(mathint r) { uint256 curr = counter(); env e; assert counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; uint y = 2 == 3 ? dec(e) : 42; assert counter() == curr, \"Value not equal, then branch executed above\"; assert y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } ``` will be split into the following sub rules: ```java rule 1 (mathint r) { uint256 curr = counter(); env e; assert counter() == curr; } rule 2 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; } rule 3 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; } ... rule 6 (mathint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assume x == 7; uint y = 2 == 3 ? dec(e) : 42; assume counter() == curr, \"Value not equal, then branch executed above\"; assume y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, both branches executed above\"; } ``` The ruleID for each of the sub rules above is formed based on the target assert command. --- If it is a user specified assert, the rule name will have the form: |Assert51_(Message)&lt;user specified msg with the assert&gt;|if the user has specified an assert message| |---|---| |Assert66_(Location)cspec_46_2|if there is no assert message associated with the assert, it displays the location of the target assert: File c.spec, line 46, column 2.| 51 and 66 in the above rule names are assert ids assigned by the tool to the target assert commands. They are mostly there for ensuring uniqueness of different assert commands For automatically generated asserts, we have |AutogeneratedAssert30_(Message)Recursion_protection_124|if there is a message associated with the automatically generated assert| |---|---| |AutogeneratedAssert30_(Symbol)b|when there is no message. (NOTE: In the future, we plan to incorporate solidity source file information (that produced the automatically generated assert) in the rule name)| Here is another example: java rule checkSoundness { bool b; assert !b; assert !b; } The above rule will fail when the model assigns b = true. With assert splitting, it will show two sub rules: java // fails when model assigns b = true rule 1 { bool b; assert !b; } // passes rule 2 { bool b; assume !b; assert !b; } As discussed later, the report will show the results for both the asserts and will also summarize the entire rule’s result as a failure (as expected). What if I have an assert command within an if-else statement If your code has assert commands within if-else statements, java rule checkAssertWithIfs(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else if (f.selector == foo().selector) { assert b; } else { assert b; } assert false; } You can think of assert splitting as generating the following rules: 1st assert (line 7) java rule 1(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else { assert true; } } 2nd assert (line 9) java rule 2(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.selector == foo().selector) { assert b; } else { assert true; } } 3rd assert (line 11) java rule 3(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (!f.isFallback &amp;&amp; !(f.selector == foo().selector)) { assert b; } else { assert true; } } 4p assert (line 13) --- ## java rule 4(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assume b; } else if (f.selector == foo().selector) { assume b; } else { assume b; } assert false; Think of the program in terms of a control flow graph. Lets call the block/node which contains the target assert the target block."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "98d5d26761a9-1", "chunk-uid": "98d5d26761a9", "chunk-page-index": 1, "text": "Now, when we split a rule on the target assert, we only consider the blocks from which the target block is reachable. If a block has two outgoing edges (e.g. if statements) and one edge points to a block B from which the target block cannot be reached, the subgraph beginning at B will be replaced by a dummy block containing a single command assert true. If the program execution reaches this dummy block, we'll know that the target assert is not violated for that execution. Lastly, after the control flow graph has been modified, all the previous assert commands still remaining in the modified graph are converted into assume commands as before. Note that rule 4 above will pass vacuously because all program paths to the target assert have assume false before the target assert is reached. ## Report These sub rules are then verified in parallel and the result of the rule is displayed in the report as follows: When all the sub rules succeed, the report shows only a single SUCCESS result for the entire rule (same as what the report displayed originally) When any of these sub rules do not succeed (fail, timeout or give an unknown result), the report shows individual results for 1. all the user specified asserts 2. all the automatically generated asserts that did not succeed Here are some example reports for the rules above: checkSoundness: checkAssertWithIfs: Note that checkAssertWithIfs is a parametric rule. For parametric rules, assert splitting of the rule is performed for each function. Here is also an example of automatically generated asserts: java // C2.sol contract C2 { function foo(uint32 count) public returns (uint) { if (count &lt; 2) return 1; else return foo(_count - 1) + foo(_count - 2); } } // c2.spec // auto generated asserts not violated rule checkAutoGenAssert() { env e; assert foo(e, 3) == 4; // fails } // auto generated assert violated rule checkAutoGenAssert2() { env e; assert foo(e, 5) == 13; // fails when recurionEntryLimit = 4 } ## Assert splitting --- Currently, each rule in the spec file generates a single result, highlighting a conclusion for the entire rule (fail, succeed, timeout, unknown). Even in the case when there are multiple assert statements within a rule, only a single result is generated. However, with the addition of assert each rule is now split into multiple sub rules, one for each of the asserts present in the rule. The rule is split not only on the user specified asserts, but also on the asserts that are automatically generated by the tool itself (the tool generates some assert statements to check against infinite recursion, stack overflows, etc.). How the sub rules are generated For each (TAC) assert command, a new sub rule ending at that assert command (target assert) is generated, ignoring the remaining code after the target assert. Moreover, all the asserts that come (topologically) before the target assert command are converted into assume commands in the sub rule. Thus, you can think of a sub rule as checking a single target assert assuming the previous asserts hold. Hence, you can think of assert splitting as follows: the following rule java rule checkElseNotExecuted(mapint r) { uint256 curr = counter(); env e; assert counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; uint y = 2 == 3 ? dec(e) : 42; assert counter() == curr, \"Value not equal, pen branch executed above\"; assert y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, bop branches executed above\"; } will be split into the following sub rules: java rule 1 (mapint r) { uint256 curr = counter(); env e; assert counter() == curr; } java rule 2 (mapint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assert counter() == curr, \"Value not equal, else branch executed above\"; } java rule 3 (mapint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assert x == 7; } ... java rule 6 (mapint r) { uint256 curr = counter(); env e; assume counter() == curr; uint x = true ? 7 : inc(e); assume counter() == curr, \"Value not equal, else branch executed above\"; assume x == 7; uint y = 2 == 3 ? dec(e) : 42; assume counter() == curr, \"Value not equal, pen branch executed above\"; assume y == 42; uint z = r > 5 ? inc(e) : dec(e); assert counter() != curr, \"Value equal, bop branches executed above\"; } The ruleID for each of the sub rules above is formed based on the target assert command. If it is a user specified assert, the rule name will have the form: Assert51_(Message)&lt;user specified msg with the assert&gt; if the user has specified an assert message or --- Assert66_(Location)cspec_46_2 if there is no assert message associated with the assert, it displays the location of the target assert: File c.spec, line 46, column 2. 51 and 66 in the above rule names are assert ids assigned by the tool to the target assert commands. They are mostly there for ensuring uniqueness of different assert commands For automatically generated asserts, we have AutogeneratedAssert30_(Message)Recursion_protection_124 if there is a message associated with the automatically generated assert or AutogeneratedAssert30_(Symbol)b when there is no message. (NOTE: In the future, we plan to incorporate solidity source file information (that produced the automatically generated assert) in the rule name) Here is another example: java rule checkSoundness { bool b; assert !b; assert !b; } The above rule will fail when the model assigns b = true. With assert splitting, it will show two sub rules: java // fails when model assigns b = true rule 1 { bool b; assert !b; } // passes rule 2 { bool b; assume !b; assert !b; } As discussed later, the report will show the results for both the asserts and will also summarize the entire rule’s result as a failure (as expected). What if I have an assert command within an if-else statement If your code has assert commands within if-else statements, java rule checkAssertWithIfs(method f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else if (f.selector == foo().selector) { assert b; } else { assert b; } assert false; } You can think of assert splitting as generating the following rules: 1st assert (line 7) java rule 1(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assert b; } else { assert true; } } 2nd assert (line 9) java rule 2(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.selector == foo().selector) { assert b; } else { assert true; } } 3rd assert (line 11) java rule 3(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (!f.isFallback && !(f.selector == foo().selector)) { assert b; } else { assert true; } } 4p assert (line 13) java rule 4(mepod f) { env e; calldataarg arg; f(e, arg); bool b = false; if (f.isFallback) { assume b; } else if (f.selector == foo().selector) { assume b; } else { assume b; } assert false; } --- Think of the program in terms of a control flow graph. Lets call the block/node which contains the target assert the target block."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "98d5d26761a9-2", "chunk-uid": "98d5d26761a9", "chunk-page-index": 2, "text": "Now, when we split a rule on the target assert, we only consider the blocks from which the target block is reachable. If a block has two outgoing edges (e.g. if statements) and one edge points to a block B from which the target block cannot be reached, the subgraph beginning at B will be replaced by a dummy block containing a single command assert true. If the program execution reaches this dummy block, we'll know that the target assert is not violated for that execution. Lastly, after the control flow graph has been modified, all the previous assert commands still remaining in the modified graph are converted into assume commands as before."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "98d5d26761a9-3", "chunk-uid": "98d5d26761a9", "chunk-page-index": 3, "text": "Note that rule 4 above will pass vacuously because all program paths to the target assert have assume false before the target assert is reached. ## Report These sub rules are then verified in parallel and the result of the rule is displayed in the report as follows: When all pe sub rules succeed, pe report shows only a single SUCCESS result for pe entire rule (same as what pe report displayed originally) When any of pese sub rules do not succeed (fail, timeout or give an unknown result), pe report shows individual results for a) all pe user specified asserts b) all pe automatically generated asserts pat did not succeed Here are some example reports for the rules above: checkSoundness: checkAssertWithIfs: Note that checkAssertWithIfs is a parametric rule. For parametric rules, assert splitting of the rule is performed for each function."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "assert-splitting", "id": "98d5d26761a9-4", "chunk-uid": "98d5d26761a9", "chunk-page-index": 4, "text": "Here is also an example of automatically generated asserts: java // C2.sol contract C2 { function foo(uint32 count) public returns (uint) { if (count &lt; 2) return 1; else return foo(_count - 1) + foo(_count - 2); } } // c2.spec // auto generated asserts not violated rule checkAutoGenAssert() { env e; assert foo(e, 3) == 4; // fails } // auto generated assert violated rule checkAutoGenAssert2() { env e; assert foo(e, 5) == 13; // fails when recurionEntryLimit = 4 }"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "using", "id": "7a5c3252502a-0", "chunk-uid": "7a5c3252502a", "chunk-page-index": 0, "text": "## Using Statements The using statement introduces a variable that can be used to call methods on contracts other than the main contract being verified. Examples {ref}using-example Syntax An example for using The syntax for using statements is given by the following EBNF grammar: using ::= \"using\" id \"as\" id See {ref}identifiers for the id production."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-0", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 0, "text": "## Changes Introduced in CVL 2 CVL 2 is a major overhaul to the type system of CVL. Though many of the changes are internal, we wanted to take this opportunity to introduce a few improvements to the syntax. The general goal of these changes is to make the behavior of CVL more explicit and predictable, and to bring the syntax more in line with Solidity's syntax. This document summarizes the changes to CVL syntax introduced by CVL 2. The CVLMigration repository contains examples demonstrating each of the changes; the cvl1 branch contains the examples in valid CVL 1 syntax, while the cvl2 branch contains the same examples in CVL 2 syntax. You can see the differences here, or you can clone the repository and compare the cvl1 and cvl2 branches using your favorite tools. ### Superficial syntax changes There are several simple changes to the syntax to make specs more uniform and consistent, and to reduce the superficial differences with Solidity. |CVL 1|CVL 2|Diff| |---|---|---| |cvl transferFrom(address, address, uint) returns(bool) envfree|cvl function transferFrom(address, address, uint) external returns(bool) envfree;|(note also the addition of external, described below)| |cvl balanceOf(address) returns(uint256) => ALWAYS(3)|cvl function balanceOf(address) external returns(uint256) => ALWAYS(3)| | In CVL 2, methods block entries must now start with function and end with ; (semicolons were optional in CVL 1). using, import, use, and invariant statements all require a ; at the end."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-1", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 1, "text": "use and invariant statements do not require (and may not have) a semicolon if they are followed by a preserved or filtered block. If you do not change this, you will get an error message like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/MethodsEntries.spec:4:5: Syntax error: unexpected token near ID(transferFrom) CRITICAL: [main] ERROR ALWAYS - certora/spec/MethodsEntries.spec:4:5: Couldn't repair and continue parse unexpected token near ID(transferFrom) If you do not change this, you will see an error like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/Semicolons.spec:5:1: Syntax error: unexpected token near using CRITICAL: [main] ERROR ALWAYS - certora/spec/Semicolons.spec:5:1: Couldn't repair and continue parse unexpected token near using --- Method literals require sig: In some places in CVL, you can refer to a contract method by its name and argument types. For example, you might write (CVL 1, CVL 2, diff): cvl f.selector == approve(address, uint).selector In this example, approve(address,uint) is a method literal. In CVL 2, these methods literals must now start with sig:. For example, the above would become: cvl f.selector == sig:approve(address, uint).selector If you do not change this, you will see the following error: Error: Error in spec file (MethodLiterals.spec:14:5): Variable address is undefined (first instance only reported) Error: Error in spec file (MethodLiterals.spec:14:5): Variable uint is undefined (first instance only reported) Error: Error in spec file (MethodLiterals.spec:15:34): could not type expression \"address\", message: unknown variable \"address\" Error: Error in spec file (MethodLiterals.spec:15:43): could not type expression \"uint\", message: unknown variable \"uint\" Use of contract name instead of using variable In CVL 1, the only way to refer to a contract in the {term}scene was to first introduce a contract instance variable with a using statement, and then use that variable. For example, to access a struct type S defined in PrimaryContract.sol, you would need to write (CVL 1, CVL 2, diff): cvl using PrimaryContract as primary; rule structExample { primary.S x; ... } In CVL 2, you must now use the name of the contract, rather than the instance variable, when referring to user-defined types. The above example would now be written cvl rule structExample { PrimaryContract.S x; ... } There is no need for a using statement in this example. If you don't change this, you will an error like the following: Error: Error in spec file (ContractNames.spec:12:19): Contract name primary does not exist in the scene. Make sure you are using a contract name and not a contract instance name. Calling methods on secondary contracts still requires using a contract instance variable: cvl using SecondaryContract as secondary; rule multicontractExample { ... secondary.balanceOf(0); ... } Entries in the methods block may use either the contract name or an instance variable: cvl using SecondaryContract as secondary; methods { //// both are valid (and the effect is the same): secondary.balanceOf(address) returns(uint) envfree SecondaryContract.transfer(address, uint) returns(bool) envfree } Using the contract name in the methods block currently has the same effect as using an instance variable; this may change in future versions of CVL. Rules must start with rule In CVL 1, you could omit the keyword rule when writing rules (CVL 1, CVL 2, diff): --- cvl transferReverts { ... } In CVL 2, the rule keyword is no longer optional: cvl rule transferReverts { ... } If you don't change this, you will receive an error like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/RuleKeyword.spec:3:1: Syntax error: unexpected token near ID(transferReverts) (cvl2-methods-blocks)= Changes to methods block entries In addition to the superficial changes listed above, there are some changes to the way that methods block entries can be written (there are also a few instances where the meanings of entries has changed). In CVL 1, methods block entries often had several different functions and meanings: - They were used to indicate targets for summarization - They were used to write generic specs that could apply to contracts with missing methods - They were used to declare targets envfree The changes described in this section make these different uses more explicit: {contents} :local: :depth: 1 Most Solidity types allowed as arguments CVL 1 had some restrictions on the types of arguments allowed in methods block entries. For example, user-defined types (such as enums and structs) were not fully supported. CVL 2 methods block entries may use any Solidity types for arguments and return values, except for function types and contract or interface types. To work around the missing types, CVL 1 allowed users to encode some user-defined types as primitive types in the methods block; these workarounds are no longer allowed in CVL 2. For example, consider the following solidity function: solidity contract Example { enum Permission { READ, WRITE }; function f(Permission p) internal { ... } } In CVL 1, a methods block entry for f would need to declare that it takes a uint8 argument: cvl methods { f(uint8 permission) =&gt; NONDET } In CVL 2, the methods block entry should use the same type as the Solidity implementations[^contract-types] (compare files), except for function types and contract or interface types: cvl methods { function f(Example.Permission p) internal =&gt; NONDET; } The method can be called from CVL as follows: cvl rule example { f(Example.Permission.READ); } Contract functions that take or return contract or interface types should instead use address in the methods block declaration. For example, if the contract contains the following function: solidity function listToken(IERC20 token) internal { ... } the methods block should use address for the token argument: --- ## cvl methods { function listToken(address token) internal; } Contract functions that take or return function types are not currently supported. (cvl2-visibility)= Required internal or external annotation Every methods block entry must be marked either internal or external. The annotation must come after the argument list and before the returns clause. If a function is declared public in Solidity, then the Solidity compiler creates an internal implementation method, and an external wrapper method that calls the internal implementation. Therefore, you can summarize a public method by marking the summarization internal. {warning} The behavior of `internal` vs. `external` summarization for public methods can be confusing, especially because functions called directly from CVL are not summarized. See {ref}methods-visibility`. (cvl2-optional)= optional methods block entries In CVL 1, you could write an entry in the methods block for a method that does not exist in the contract; rules that would call the non-existent method were skipped during verification. This behavior can lead to confusion, because typos or name changes could silently cause a rule to be skipped. In CVL 2, this behavior is still available, but the methods entry must contain the keyword optional somewhere after the returns clause and before the summarization (if any). (cvl2-locations)= Required calldata, memory, or storage annotations for reference types In CVL 2, methods block entries for internal functions must contain either calldata, memory, or storage annotations for all arguments with reference types (such as arrays). For methods block entries of external functions the location annotation must be omitted unless it's the storage annotation on an external library function, in which case it is required (the reasoning here is to have the information required in order to correctly calculate a function's sighash). (cvl2-wildcards)= Summaries only apply to one contract by default In CVL 1, a summary in the methods block applied to all methods with the given signature. In CVL 2, summaries only apply to a single contract, unless the old behavior is explicitly requested by using _ as the receiver. If no contract is specified, the default is currentContract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-2", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 2, "text": "{note} The receiver contract must be the contract where the method is defined. If a contract inherits a method defined in a supercontract, the receiver must be the supercontract, rather than the inheriting contract. Entries that use _ as the receiver are called {term}wildcard entries <wildcard>, summaries that do not are called {term}exact entries <exact>. Consider the following example: cvl using C as c; --- ## methods |function|summary| |---|---| |f(uint)|internal => NONDET| |c.g(uint)|internal => ALWAYS(4)| |h(uint)|internal => ALWAYS(1)| |_.h(uint)|internal => NONDET| In this example, the internal function currentContract.f has a NONDET summary, c.g has an ALWAYS summary, a call to currentContact.h has an ALWAYS summary and a call to h(uint) on any other contract will use a NONDET summary. Summaries for specific contract methods (including the default currentContract) always override wildcard summaries. Wildcard entries cannot be declared optional or envfree, since these annotations only make sense for specific contract methods. Requirements on returns In CVL 1, the returns clause on methods block entries was optional. CVL 2 has stricter requirements on the declared return types. Entries that apply to specific contracts (i.e. those that don't use the _.f {ref}syntax <cvl2-wildcards>) must include a returns clause if the contract method returns a value. A specific-contract entry may only omit the returns clause if the contract method does not return a value. The Prover will report an error if the contract method's return type differs from the type declared in the methods block entry. Wildcard entries must not declare return types, because they may apply to multiple methods that return different types. If a wildcard entry is summarized with a ghost or function summary, the summary must include an expect clause; see {ref}function-summary for more details. Changes to integer types In CVL 1, the rules for casting between integer types were complex; CVL 2 simplifies them. The general rule of thumb is that you should use mathint whenever possible; only use uint or int types for data that will be passed as input to contract functions. It is now impossible for CVL math expressions to cause overflow - all integer operations are exact. The remainder of this section describes the changes in detail. Mathematical operations return mathint In CVL 2, the results of all arithmetic operators have type mathint, regardless of the input types. Arithmetic operators include +, *, -, /, ^, and %, but not bitwise operators like <<, xor, and | (changes to bitwise operators are described {ref}below <cvl2-bitwise>). The primary impact of this change is that you may need to declare more of your variables as mathint instead of uint. If you are passing the results of arithmetic operations to contract functions, you will need to be more explicit about the overflow behavior by using the {ref}new casting operators <cvl2-casting>. Comparisons require identical types --- When comparing two integers using ==, &lt;=, &lt;, &gt;, or &gt;=, CVL 2 will require both sides of the equation to have identical types, and implicit casts will not be used. Comparisons with number literals (e.g."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-3", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 3, "text": "0 or 1) are allowed for any integer type. If you do not have identical types (and cannot change one of your variables to a mathint), the best solution is to use the special to_mathint operator to convert both sides to mathint. For example: cvl assert to_mathint(balanceOf(user)) == initial + deposit; Note that in this example, we do not need to cast the right hand side, since the result of + is always of type mathint. When should you not simply cast to mathint? We have one example: consider the following code: cvl ghost uint256 sum; hook ... { havoc sum assuming sum@new == sum@old + newBalance - oldBalance; } Simply casting to mathint will turn overflows into vacuity. In this particular example, the right solution is to declare sum to be a mathint instead of a uint. Note that with the more recent update syntax, this problem will correctly be reported as an error. For example, if you mistakenly write the following: cvl ghost uint256 sum; hook ... { sum = sum + newBalance - oldBalance; } then the Prover will again report a type error, but the only available solutions are to change sum to a mathint (which would prevent the vacuity) or write an explicit assert or require cast (which would make the vacuity explicit). Implicit and explicit casting If every number that can be represented by one type can also be represented by another type, then we say that the first type is a subtype of the second type. For example, a uint8 variable could have any value between 0 and 2^8-1, and all of these values can be stored in a uint16 variable, so uint8 is a subtype of uint16. An int16 can also store any value between 0 and 2^8-1, so uint8 is also a subtype of int16. All integer types are subtypes of mathint, since any integer can be represented by a mathint. In CVL 1, the rules for converting between supertypes and subtypes were complicated; they depended not only on the types involved, but on the context in which the conversion happened. CVL 2 simplifies these rules and improves the clarity and predictability of casts. In CVL 2, with one exception, you can always use a subtype whenever the supertype is accepted. For example, you can always use a uint8 where an int16 is expected. We say that the subtype can be \"implicitly cast\" to the supertype. The one exception is comparison operators; as mentioned above, you must add an explicit conversion if you want to compare two numbers with different types. The to_mathint operator exists solely for this purpose; in all other contexts you can simply use any number when a mathint is expected (since all integer types are subtypes of mathint). In order to convert from a supertype to a subtype, you must use an explicit cast. In CVL 1, only a few casting operators (such as to_uint256) were supported. CVL 2 replaces these casting operators with two new casting operators: assert casts such as assert_uint8(x) or assert_int256(x), and require casts such as require_uint8(x) or require_int256(x). Each of these casts checks that --- the value is in range; the assert cast will report a counterexample if the value is out of range, while the require cast will ignore counterexamples where the cast value is out of range. {warning} As with normal `require` statements, require casts can cause vacuity and should be used with care. CVL 2 supports assert and require casts on all numeric types. Casts from address or bytes1...bytes32 to integer types are not supported (see {ref}bytesN-support regarding casting in the other direction, and {ref}enum-casting for information on casting enums). require and assert casts are not allowed anywhere inside of a {term}quantified statement <quantifier>. You can work around this limitation by adding a second variable. For example, the following axiom is invalid because x+1 is not a uint: cvl ghost mapping(uint =&gt; uint) a { axiom forall uint x . a[x+1] == 0 } However, it can be replaced with the following: cvl ghost mapping(uint =&gt; uint) a { axiom forall uint x . forall uint y . (to_mathint(y) == x + 1) =&gt; a[y] == 0 } (enum-casting)= Casting enums to integer types In CVL2 enums are not directly comparable to the corresponding integer type (uint8). Instead one must use one of the new cast operators. For example cvl uint8 x = MyContract.MyEnum.VAL; // will fail typechecking uint8 x = assert_uint8(MyContract.MyEnum.VAL); // good mathint x = to_mathint(MyContract.MyEnum.VAL); // good Casting integer types to an enum is not supported. (address-casting)= Casting addresses to bytes32 CVL2 supports casting from the address type to the bytes32 type. For example: cvl address a = 0xa44f5d3d624DfD660ecc11FF777587AD0a19606d; bytes32 b = to_bytes32(a); The cast from address to bytes32 behaves equivalently to the Solidity code: solidity address a = 0xa44f5d3d624DfD660ecc11FF777587AD0a19606d; bytes32 b = bytes32(uint256(uint160(a))); Among other things, this behavior means that the resulting bytes32 value is right-aligned and zero-padded to the left. CVL2 also supports casting from the bytes32 type to the address type using either the require_address() or assert_address() cast functions. cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d); address a = assert_address(b); Note that require_address() will silently allow a cast to continue when the bytes32 variable contains a value that lies in the range 2^160 &lt; var &lt; 2^256. The assert_address() cast function will fail when the bytes32 variable contains a value in that same range. cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d0e); // Note this contains one extra byte address a = require_address(b); // Silently does the cast. --- ## Changes to the fallback function While when using assert_address: cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d0e); // Note pis contains one extra byte address a = assert_address(b); // This will fail. Casting from bytes32 to address behaves equivalently to the Solidity code: solidity bytes32 b = bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d); address a = address(uint160(uint256(b))); Modulo operator % returns negative values for negative inputs As in Solidity, if n &lt; 0 then n % k == -(-n % k). (bytesN-support)= Support for bytes1...bytes32 CVL 2 supports the types bytes1, bytes2, ..., bytes32, as in Solidity. Number literals must be explicitly cast to these types using to_bytesN; for example: cvl bytes32 x = to_bytes32(0); Unlike Solidity, bytes1...bytes32 literals do not need to be written in hex or padded to the correct length. The only conversion between integer types and these types is from uint&lt;i*8&gt; to bytes&lt;i&gt; (i.e. unsigned integers with the same bitwidth as the target bytes&lt;i&gt; type); For example: cvl uint24 u; bytes3 x = to_bytes3(u); // This is OK bytes4 y = to_bytes4(u); // This will fail (cvl2-bitwise)= Changes for bitwise operations In CVL1, the exact details for bitwise operations (such as &, |, and &lt;&lt;) were not completely specified, especially for negative integers. In CVL 2, all bitwise operations (&, |, ~, &gt;&gt;, &gt;&gt;&gt;, &lt;&lt;, and xor) on integer types first convert to a 256 bit word, then perform the operations on the full 256-bit word, then convert back to the expected type. Signed integer types use twos-complement encoding."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-4", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 4, "text": "The two right-shifts differ in how they treat signed integers. &gt;&gt; is an arithmetic shift; it preserves the sign bit. &gt;&gt;&gt; is a logical shift; it pads the shifted word with zero. Bitwise operations cannot be performed on mathint values. {note} By default, bitwise operators are {term}overapproximated (in both CVL 1 and CVL 2), so you may see counterexamples that incorrectly compute the results of bitwise operations. The approximations are still {term}sound`: the Prover will not report a rule as verified if the original code does not satisfy the rule. The {ref}--precise_bitwise_ops flag makes the Prover's reasoning about bitwise operations more precise, but this flag is experimental in CVL 2. --- In CVL 1, you could determine whether a method object was the fallback function by comparing its selector to certorafallback().selector: cvl assert f.selector == certorafallback().selector, \"f must be the fallback\"; In CVL 2, certorafallback() is no longer valid. Instead, you can use the new field f.isFallback to detect the fallback method: cvl assert f.isFallback, \"f must be the fallback\"; Removed features As we transit to CVL 2, we have removed several language features that are no longer used. We have removed these features because we think they are no longer used and no longer useful."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-5", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 5, "text": "If you find that you do need one of these features, contact Certora support. |(cvl2-removed-sighashes)| | |---|---| |Methods entries for sighashes| | In CVL 1, you could write a sighash instead of a method identifier in the methods block. This feature is no longer supported."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-6", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 6, "text": "You will need to have the name and argument types of the called method in order to provide an entry. |(cvl2-removed-invoke)| | |---|---| |invoke, sinvoke, and call| | Older versions of CVL had special syntax for calling contract and CVL functions: - invoke f(args); should be replaced with f@withrevert(args); - sinvoke f(args); should be replaced with f(args); - call f(args) should be replaced with f(args). |(cvl2-removed-static-assert-require)| | |---|---| |static_assert and static_require| | These deprecated aliases for assert and require are being removed; replace them with assert and require respectively. |(cvl2-removed-fallback)| | |---|---| |invoke_fallback and certorafallback()| | The invoke_fallback syntax is no longer supported; there is no longer a way to directly invoke the fallback method. You can work around this limitation by writing a parametric rule and filtering on f.isFallback."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-7", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 7, "text": "See cvl2-fallback-changes. |(cvl2-removed-invoke-whole)| | |---|---| |invoke_whole| | Havocing local variables In CVL 1, you could write the following: --- ## cvl calldataarg args; env e; f(e, args); ## havoc args; g(e, args); In CVL 2, you can only havoc ghost variables and ghost functions. Instead of havocing a local variable, replace the havoced variable with a new variable. For example, you should replace the above with: ## cvl calldataarg args; env e; f(e,args); ## calldataarg args2; g(e,args2); ## Destructuring syntax for struct returns In CVL 1, if a contract function returned a struct, you could use a destructuring syntax to get the return value in your spec. For example, consider the following contract: ```solidity contract Example { struct S { uint firstField; uint secondField; bool thirdField; } function f() returns(S) { ... } function g() returns(uint, uint) { ... } } ``` To access the return value of f in CVL 1, you could write the following: cvl uint x; uint y; bool z; x, y, z = f(); This syntax is no longer supported. Instead, you should declare a variable with the struct type: cvl Example.S result = f(); uint x = result.firstField; Destructuring assignments are still allowed for functions that return multiple values; the following is valid: cvl uint x; uint y; x, y = g(); ## bytes[] and string[] In CVL 1, you could declare variables of type string[] and bytes[]. You can no longer use these types in CVL."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-8", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 8, "text": "You can still declare contract methods that use these types in the methods block. However, you can only call methods that take one of these types as an argument by passing a calldataarg variable, and you cannot access the return value of a method that returns one of these types. ## pragma CVL 1 had a pragma command for specifying the CVL version, but this feature was not used and has been removed in CVL 2. events CVL 1 had syntax for an events block, but it did nothing and has been removed. --- ## Changes to the Command Line Interface (CLI) As part of the transition to CVL 2 changes were made to enhanced clarity, uniformity, and readability on the Command-Line Interface (CLI). The complete CLI specification can be found here {note} The changes will take effect starting v4.3.1 of `certora-cli`. {note} To opt-out of the new CLI, one can set an environment variable `CERTORA_OLD_API` to `1`, e.g.: `export CERTORA_OLD_API=1`. The old CLI will not be available in versions released after August 31st, 2023 ### Flags Renaming In CVL 2 some flags were renamed: 1. flags with names that are generic or wrong 2. flags that do not match their corresponding key in the conf file 3. flags that do not follow the snake case format This is the list of the flags that were renamed: |CVL 1|CVL 2| |---|---| |--settings|--prover_args| |--path|--solc_allow_path| |--optimize|--solc_optimize| |--optimize_map|--solc_optimize_map| |--get_conf|--conf_output_file| |--assert|--assert_contracts| |--bytecode|--bytecode_jsons| |--toolOutput|--tool_output| |--structLink|--struct_link| |--javaArgs|--java_args| ### Prover Args Prover args are CLI flags that are sent to the Prover. Prover args can be set in one of two ways: 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-9", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 9, "text": "Using specific CLI flags (e.g. --loop_iter) 2. As parameters to the --prover_args (--settings in CVL 1) Unlike CVL 1, if a prover arg is set using a specific CLI flag it cannot be set using --prover_args. In addition, the value commas and equal signs separators that were used in --settings were replaced with white-spaces in --prover_args. Example: Consider this call to certoraRun using CVL 1 syntax bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --settings -smt_bitVectorTheory=true,- smt_hashingScheme=plainInjectivity,-assumeUnwindCond In order to convert this call to CVL 2 we: 1. renamed --settings to --prover_args 2. replaced -assumeUnwindCond with the flag --optimistic_loop 3. removed the comma and equal sign separators bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --optimistic_loop \\ --prover_args '-smt_bitVectorTheory true -smt_hashingScheme plainInjectivity' ### Solidity Compiler Args The Solidity Compiler Args are CLI flags that are sent to the Solidity compiler. The behavior of the Solidity Args is similar to Prover Args. The flag --solc_args can only be used if there is no CLI flag that sets the Solidity flag and the value of --solc_args is a string that is sent as is to the Solidity compiler. Example: Consider this call to certoraRun using CVL 1 syntax bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --solc_args \"['--optimize', '--optimize-runs', '200', '--experimental-via-ir']\" In CVL 2 calling optimize is using --solc_optimize bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --solc_optimize 200 \\ --solc_args \"--experimental-via-ir\" --- ## Enhanced server support In CVL 1, two server platforms were supported: 1. staging was set using pe flag --staging [Branch/hotfix] 2. production was set using pe flag --cloud [Branch/hotfix] In CVL 2 the flag --server was added to replace --staging --cloud and to allow adding additional server platforms. --server gets as a parameter the platform name. --prover_version is a new flag in CVL 2 for setting the Branch/hot-fix. Changes Introduced in CVL 2 CVL 2 is a major overhaul to the type system of CVL. Though many of the changes are internal, we wanted to take this opportunity to introduce a few improvements to the syntax. The general goal of these changes is to make the behavior of CVL more explicit and predictable, and to bring the syntax more in line with Solidity's syntax. This document summarizes the changes to CVL syntax introduced by CVL 2. The CVLMigration repository contains examples demonstrating each of the changes; the cvl1 branch contains the examples in valid CVL 1 syntax, while the cvl2 branch contains the same examples in CVL 2 syntax. You can see the differences here, or you can clone the repository and compare the cvl1 and cvl2 branches using your favorite tools. ### Superficial syntax changes There are several simple changes to the syntax to make specs more uniform and consistent, and to reduce the superficial differences with Solidity. function and ; required for methods block entries In CVL 2, methods block entries must now start with function and end with ; (semicolons were optional in CVL 1). For example (CVL 1, CVL 2, diff): cvl transferFrom(address, address, uint) returns(bool) envfree will become cvl function transferFrom(address, address, uint) external returns(bool) envfree; (note also the addition of external, described below) This is also true for entries with summaries: cvl balanceOf(address) returns(uint256) =&gt; ALWAYS(3) will become cvl function balanceOf(address) external returns(uint256) =&gt; ALWAYS(3); If you do not change this, you will get an error message like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/MethodsEntries.spec:4:5: Syntax error: unexpected token near ID(transferFrom) CRITICAL: [main] ERROR ALWAYS - certora/spec/MethodsEntries.spec:4:5: Couldn't repair and continue parse unexpected token near ID(transferFrom) Required ; in more places using, import, use, and invariant statements all require a ; at the end. For example (CVL 1, CVL 2, diff): cvl invariant balanceOfZeroIsZero() balanceOf(0) == 0 becomes cvl invariant balanceOfZeroIsZero() balanceOf(0) == 0; use and invariant statements do not require (and may not have) a semicolon if they are followed by a preserved or filtered block. For example, the following is valid in both CVL 1 and CVL 2: --- ## cvl invariant totalSupplyBoundsBalance(address a) balanceOf(a) <= totalSupply() { preserved { require false; } } If you do not change this, you will see an error like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/Semicolons.spec:5:1: Syntax error: unexpected token near using CRITICAL: [main] ERROR ALWAYS - certora/spec/Semicolons.spec:5:1: Couldn't repair and continue parse unexpected token near using Method literals require sig: In some places in CVL, you can refer to a contract method by its name and argument types. For example, you might write (CVL 1, CVL 2, diff): cvl f.selector == approve(address, uint).selector In this example, approve(address,uint) is a method literal. In CVL 2, these methods literals must now start with sig:. For example, the above would become: cvl f.selector == sig:approve(address, uint).selector If you do not change this, you will see the following error: Error: Error in spec file (MethodLiterals.spec:14:5): Variable address is undefined (first instance only reported) Error: Error in spec file (MethodLiterals.spec:14:5): Variable uint is undefined (first instance only reported) Error: Error in spec file (MethodLiterals.spec:15:34): could not type expression \"address\", message: unknown variable \"address\" Error: Error in spec file (MethodLiterals.spec:15:43): could not type expression \"uint\", message: unknown variable \"uint\" Use of contract name instead of using variable In CVL 1, the only way to refer to a contract in the {term}scene was to first introduce a contract instance variable with a using statement, and then use that variable. For example, to access a struct type S defined in PrimaryContract.sol, you would need to write (CVL 1, CVL 2, diff): cvl using PrimaryContract as primary; rule structExample { primary.S x; ... } In CVL 2, you must now use the name of the contract, rather than the instance variable, when referring to user-defined types. The above example would now be written cvl rule structExample { PrimaryContract.S x; ... } There is no need for a using statement in this example. If you don't change this, you will an error like the following: Error: Error in spec file (ContractNames.spec:12:19): Contract name primary does not exist in the scene. Make sure you are using a contract name and not a contract instance name. Calling methods on secondary contracts still requires using a contract instance variable: cvl using SecondaryContract as secondary; rule multicontractExample { ... secondary.balanceOf(0); ... } Entries in the methods block may use either the contract name or an instance variable: cvl using SecondaryContract as secondary; --- ## methods //// both are valid (and the effect is the same): secondary.balanceOf(address) returns(uint) envfree SecondaryContract.transfer(address, uint) returns(bool) envfree } ``` Using the contract name in the methods block currently has the same effect as using an instance variable; this may change in future versions of CVL. Rules must start with rule In CVL 1, you could omit the keyword rule when writing rules (CVL 1, CVL 2, diff): cvl transferReverts { ... } In CVL 2, the rule keyword is no longer optional: cvl rule transferReverts { ... } If you don't change this, you will receive an error like the following: CRITICAL: [main] ERROR ALWAYS - certora/spec/RuleKeyword.spec:3:1: Syntax error: unexpected token near ID(transferReverts) ## Changes to methods block entries In addition to the superficial changes listed above, there are some changes to the way that methods block entries can be written (there are also a few instances where the meanings of entries has changed). In CVL 1, methods block entries often had several different functions and meanings: - They were used to indicate targets for summarization - They were used to write generic specs that could apply to contracts with missing methods - They were used to declare targets envfree The changes described in this section make these different uses more explicit: {contents} :local: :depth: 1 ## Most Solidity types allowed as arguments CVL 1 had some restrictions on the types of arguments allowed in methods block entries. For example, user-defined types (such as enums and structs) were not fully supported. CVL 2 methods block entries may use any Solidity types for arguments and return values, except for function types and contract or interface types. To work around the missing types, CVL 1 allowed users to encode some user-defined types as primitive types in the methods block; these workarounds are no longer allowed in CVL 2. For example, consider the following solidity function: solidity contract Example { enum Permission { READ, WRITE }; function f(Permission p) internal { ... } } In CVL 1, a methods block entry for f would need to declare that it takes a uint8 argument: cvl methods { f(uint8 permission) =&gt; NONDET } In CVL 2, the methods block entry should use the same type as the Solidity implementations[^contract-types] (compare files), except for function types and contract or interface types: --- ## cvl methods function f(Example.Permission p) internal => NONDET; The method can be called from CVL as follows: cvl rule example { f(Example.Permission.READ); } Contract functions that take or return contract or interface types should instead use address in the methods block declaration. For example, if the contract contains the following function: solidity function listToken(IERC20 token) internal { ... } the methods block should use address for the token argument: cvl methods { function listToken(address token) internal; } Contract functions that take or return function types are not currently supported. (cvl2-visibility) Required internal or external annotation Every methods block entry must be marked either internal or external. The annotation must come after the argument list and before the returns clause. If a function is declared public in Solidity, then the Solidity compiler creates an internal implementation method, and an external wrapper method that calls the internal implementation. Therefore, you can summarize a public method by marking the summarization internal. {warning} The behavior of `internal` vs. `external` summarization for public methods can be confusing, especially because functions called directly from CVL are not summarized. See methods-visibility. (cvl2-optional) optional methods block entries In CVL 1, you could write an entry in the methods block for a method that does not exist in the contract; rules that would call the non-existent method were skipped during verification. This behavior can lead to confusion, because typos or name changes could silently cause a rule to be skipped. In CVL 2, this behavior is still available, but the methods entry must contain the keyword optional somewhere after the returns clause and before the summarization (if any). (cvl2-locations) Required calldata, memory, or storage annotations for reference types In CVL 2, methods block entries for internal functions must contain either calldata, memory, or storage annotations for all arguments with reference types (such as arrays). For methods block entries of external functions the location annotation must be omitted unless it's the storage annotation on an external library function, in which case it is required (the reasoning here is to have the information required in order to correctly calculate a function's sighash). (cvl2-wildcards) Summaries only apply to one contract by default In CVL 1, a summary in the methods block applied to all methods with the given signature. --- ## CVL 2 Summaries In CVL 2, summaries only apply to a single contract, unless the old behavior is explicitly requested by using _ as the receiver. If no contract is specified, the default is currentContract."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-10", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 10, "text": "Note: The receiver contract must be the contract where the method is defined. If a contract inherits a method defined in a supercontract, the receiver must be the supercontract, rather than the inheriting contract. Entries that use _ as the receiver are called wildcard entries, summaries that do not are called exact entries. Consider the following example: cvl using C as c; methods { function f(uint) internal => NONDET; function c.g(uint) internal => ALWAYS(4); function h(uint) internal => ALWAYS(1); function _.h(uint) internal => NONDET; } In this example, the internal function currentContract.f has a NONDET summary, c.g has an ALWAYS summary, a call to currentContact.h has an ALWAYS summary and a call to h(uint) on any other contract will use a NONDET summary. Summaries for specific contract methods (including the default currentContract) always override wildcard summaries. Wildcard entries cannot be declared optional or envfree, since these annotations only make sense for specific contract methods. Warning: The meaning of your summarizations will change from CVL 1 to CVL 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-11", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 11, "text": "In CVL 2, any entry without an '_' will only apply to a single contract! ## CVL 2 Returns In CVL 1, the returns clause on methods block entries was optional. CVL 2 has stricter requirements on the declared return types. Entries that apply to specific contracts (i.e. those that don't use the _.f syntax) must include a returns clause if the contract method returns a value. A specific-contract entry may only omit the returns clause if the contract method does not return a value. The Prover will report an error if the contract method's return type differs from the type declared in the methods block entry. Wildcard entries must not declare return types, because they may apply to multiple methods that return different types. If a wildcard entry is summarized with a ghost or function summary, the summary must include an expect clause; see function-summary for more details. ## Changes to Integer Types in CVL 2 In CVL 1, the rules for casting between integer types were complex; CVL 2 simplifies them. The general rule of thumb is that you should use mathint whenever possible; only use uint or int types for data that will be passed as input to contract functions. It is now impossible for CVL math expressions to cause overflow - all integer operations are exact."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-12", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 12, "text": "The remainder of this section describes the changes in detail. --- In CVL 2, the results of all arithmetic operators have type mathint, regardless of the input types. Arithmetic operators include +, *, -, /, ^, and %, but not bitwise operators like <<, xor, and | (changes to bitwise operators are described below). The primary impact of this change is that you may need to declare more of your variables as mathint instead of uint. If you are passing the results of arithmetic operations to contract functions, you will need to be more explicit about the overflow behavior by using the new casting operators. Comparisons require identical types When comparing two integers using ==, <=, <, >, or >=, CVL 2 will require both sides of the equation to have identical types, and implicit casts will not be used. Comparisons with number literals (e.g."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-13", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 13, "text": "0 or 1) are allowed for any integer type. If you do not have identical types (and cannot change one of your variables to a mathint), the best solution is to use the special to_mathint operator to convert both sides to mathint. For example: cvl assert to_mathint(balanceOf(user)) == initial + deposit; Note that in this example, we do not need to cast the right hand side, since the result of + is always of type mathint. When should you not simply cast to mathint? We have one example: consider the following code: cvl ghost uint256 sum; hook ... { havoc sum assuming sum@new == sum@old + newBalance - oldBalance; } Simply casting to mathint will turn overflows into vacuity. In this particular example, the right solution is to declare sum to be a mathint instead of a uint. Note that with the more recent update syntax, this problem will correctly be reported as an error. For example, if you mistakenly write the following: cvl ghost uint256 sum; hook ... { sum = sum + newBalance - oldBalance; } then the Prover will again report a type error, but the only available solutions are to change sum to a mathint (which would prevent the vacuity) or write an explicit assert or require cast (which would make the vacuity explicit). Implicit and explicit casting If every number that can be represented by one type can also be represented by another type, then we say that the first type is a subtype of the second type. For example, a uint8 variable could have any value between 0 and 2^8-1, and all of these values can be stored in a uint16 variable, so uint8 is a subtype of uint16. An int16 can also store any value between 0 and 2^8-1, so uint8 is also a subtype of int16. All integer types are subtypes of mathint, since any integer can be represented by a mathint. In CVL 1, the rules for converting between supertypes and subtypes were complicated; they depended not only on the types involved, but on the context in which the conversion happened. CVL 2 simplifies these rules and improves the clarity and predictability of casts. In CVL 2, with one exception, you can always use a subtype whenever the supertype is accepted. For example, you can always use a uint8 where an int16 is expected. We say that the subtype can be \"implicitly cast\" to the supertype. --- The one exception is comparison operators; as mentioned above, you must add an explicit conversion if you want to compare two numbers with different types. The to_mathint operator exists solely for this purpose; in all other contexts you can simply use any number when a mathint is expected (since all integer types are subtypes of mathint). In order to convert from a supertype to a subtype, you must use an explicit cast. In CVL 1, only a few casting operators (such as to_uint256) were supported. CVL 2 replaces these casting operators with two new casting operators: assert casts such as assert_uint8(x) or assert_int256(x), and require casts such as require_uint8(x) or require_int256(x). Each of these casts checks that the value is in range; the assert cast will report a counterexample if the value is out of range, while the require cast will ignore counterexamples where the cast value is out of range. As with normal 'require' statements, require casts can cause vacuity and should be used with care. CVL 2 supports assert and require casts on all numeric types. Casts from address or bytes1...bytes32 to integer types are not supported (see bytesN-support regarding casting in the other direction, and enum-casting for information on casting enums). Require and assert casts are not allowed anywhere inside of a quantified statement. You can work around this limitation by adding a second variable. For example, the following axiom is invalid because x+1 is not a uint: cvl ghost mapping(uint => uint) a { axiom forall uint x . a[x+1] == 0 } However, it can be replaced with the following: cvl ghost mapping(uint => uint) a { axiom forall uint x . forall uint y . (to_mathint(y) == x + 1) => a[y] == 0 } Casting enums to integer types In CVL2 enums are not directly comparable to the corresponding integer type (uint8). Instead one must use one of the new cast operators. For example cvl uint8 x = MyContract.MyEnum.VAL; // will fail typechecking uint8 x = assert_uint8(MyContract.MyEnum.VAL); // good mathint x = to_mathint(MyContract.MyEnum.VAL); // good Casting integer types to an enum is not supported. Casting addresses to bytes32 CVL2 supports casting from the address type to the bytes32 type. For example: cvl address a = 0xa44f5d3d624DfD660ecc11FF777587AD0a19606d; bytes32 b = to_bytes32(a); The cast from address to bytes32 behaves equivalently to the Solidity code: solidity address a = 0xa44f5d3d624DfD660ecc11FF777587AD0a19606d; bytes32 b = bytes32(uint256(uint160(a))); Among other things, this behavior means that the resulting bytes32 value is right-aligned and zero-padded to the left. --- ## CVL2 also supports casting from the bytes32 type to the address type using either the require_address() or assert_address() cast functions. cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d); address a = assert_address(b); Note that require_address() will silently allow a cast to continue when the bytes32 variable contains a value that lies in the range 2^160 < var < 2^256. The assert_address() cast function will fail when the bytes32 variable contains a value in that same range. cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d0e); // Note this contains one extra byte address a = require_address(b); // Silently does the cast. While when using assert_address: cvl bytes32 b = to_bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d0e); // Note this contains one extra byte address a = assert_address(b); // This will fail. Casting from bytes32 to address behaves equivalently to the Solidity code: solidity bytes32 b = bytes32(0xa44f5d3d624DfD660ecc11FF777587AD0a19606d); address a = address(uint160(uint256(b))); Modulo operator % returns negative values for negative inputs As in Solidity, if n < 0 then n % k == -(-n % k). ## Support for bytes1...bytes32 CVL 2 supports the types bytes1, bytes2, ..., bytes32, as in Solidity. Number literals must be explicitly cast to these types using to_bytesN; for example: cvl bytes32 x = to_bytes32(0); Unlike Solidity, bytes1...bytes32 literals do not need to be written in hex or padded to the correct length. The only conversion between integer types and these types is from uint<i*8> to bytes (i.e. unsigned integers with the same bitwidth as the target bytes type); For example: cvl uint24 u; bytes3 x = to_bytes3(u); // This is OK bytes4 y = to_bytes4(u); // This will fail ## Changes for bitwise operations In CVL1, the exact details for bitwise operations (such as &, |, and <<) were not completely specified, especially for negative integers. In CVL 2, all bitwise operations (&, |, ~, >>, >>>, <<, and xor) on integer types first convert to a 256 bit word, then perform the operations on the full 256-bit word, then convert back to the expected type. Signed integer types use twos-complement encoding."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-14", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 14, "text": "The two right-shifts differ in how they treat signed integers. >> is an arithmetic shift; it preserves the sign bit. >>> is a logical shift; it pads the shifted word with zero. Bitwise operations cannot be performed on mathint values. --- ## {note} By default, bitwise operators are {term}overapproximated (in both CVL 1 and CVL 2), so you may see counterexamples that incorrectly compute the results of bitwise operations. The approximations are still {term}sound: the Prover will not report a rule as verified if the original code does not satisfy the rule. The {ref}--precise_bitwise_ops flag makes the Prover's reasoning about bitwise operations more precise, but this flag is experimental in CVL 2. ## (cvl2-fallback-changes) Changes to the fallback function In CVL 1, you could determine whether a method object was the fallback function by comparing its selector to certorafallback().selector: cvl assert f.selector == certorafallback().selector, \"f must be the fallback\"; In CVL 2, certorafallback() is no longer valid. Instead, you can use the new field f.isFallback to detect the fallback method: cvl assert f.isFallback, \"f must be the fallback\"; Removed features As we transit to CVL 2, we have removed several language features that are no longer used. We have removed these features because we think they are no longer used and no longer useful."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-15", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 15, "text": "If you find that you do need one of these features, contact Certora support. ## (cvl2-removed-sighashes) Methods entries for sighashes In CVL 1, you could write a sighash instead of a method identifier in the methods block. This feature is no longer supported."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-16", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 16, "text": "You will need to have the name and argument types of the called method in order to provide an entry. ## (cvl2-removed-invoke) invoke, sinvoke, and call Older versions of CVL had special syntax for calling contract and CVL functions: - invoke f(args); should be replaced with f@withrevert(args); - sinvoke f(args); should be replaced with f(args); - call f(args) should be replaced with f(args). ## (cvl2-removed-static-assert-require) static_assert and static_require These deprecated aliases for assert and require are being removed; replace them with assert and require respectively. ## (cvl2-removed-fallback) invoke_fallback and certorafallback() The invoke_fallback syntax is no longer supported; there is no longer a way to directly invoke the fallback method. You can work around this limitation by writing a parametric rule and filtering on f.isFallback. See {ref}cvl2-fallback-changes. --- ## invoke_whole The invoke_whole keyword is no longer supported. ## Havocing local variables In CVL 1, you could write the following: cvl calldataarg args; env e; f(e, args); havoc args; g(e, args); In CVL 2, you can only havoc ghost variables and ghost functions. Instead of havocing a local variable, replace the havoced variable with a new variable. For example, you should replace the above with: cvl calldataarg args; env e; f(e,args); calldataarg args2; g(e,args2); ## Destructuring syntax for struct returns In CVL 1, if a contract function returned a struct, you could use a destructuring syntax to get the return value in your spec. For example, consider the following contract: solidity contract Example { struct S { uint firstField; uint secondField; bool thirdField; } function f() returns(S) { ... } function g() returns(uint, uint) { ... } } To access the return value of f in CVL 1, you could write the following: cvl uint x; uint y; bool z; x, y, z = f(); This syntax is no longer supported. Instead, you should declare a variable with the struct type: cvl Example.S result = f(); uint x = result.firstField; Destructuring assignments are still allowed for functions that return multiple values; the following is valid: cvl uint x; uint y; x, y = g(); ## bytes[] and string[] In CVL 1, you could declare variables of type string[] and bytes[]. You can no longer use these types in CVL."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-17", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 17, "text": "You can still declare contract methods that use these types in the methods block. However, you can only call methods that take one of these types as an argument by passing a calldataarg variable, and you cannot access the return value of a method that returns one of these types. --- ## CVL 2 Changes CVL 1 had a pragma command for specifying the CVL version, but this feature was not used and has been removed in CVL 2. CVL 1 had syntax for an events block, but it did nothing and has been removed. ## Changes to the Command Line Interface (CLI) As part of the transition to CVL 2 changes were made to enhanced clarity, uniformity, and readability on the Command-Line Interface (CLI). The complete CLI specification can be found here. Note: The changes will take effect starting v4.3.1 of certora-cli. Note: To opt-out of the new CLI, one can set an environment variable CERTORA_OLD_API to 1, e.g.: export CERTORA_OLD_API=1. The old CLI will not be available in versions released after August 31st, 2023 ## Flags Renaming In CVL 2 some flags were renamed: flags with names that are generic or wrong flags that do not match their corresponding key in the conf file flags that do not follow the snake case format This is the list of the flags that were renamed: |CVL 1|CVL 2| |---|---| |--settings|--prover_args| |--path|--solc_allow_path| |--optimize|--solc_optimize| |--optimize_map|--solc_optimize_map| |--get_conf|--conf_output_file| |--assert|--assert_contracts| |--bytecode|--bytecode_jsons| |--toolOutput|--tool_output| |--structLink|--struct_link| |--javaArgs|--java_args| ## Prover Args Prover args are CLI flags that are sent to the Prover. Prover args can be set in one of two ways: Using specific CLI flags (e.g. --loop_iter) As parameters to the --prover_args (--settings in CVL 1) Unlike CVL 1, if a prover arg is set using a specific CLI flag it cannot be set using --prover_args. In addition, the value commas and equal signs separators that were used in --settings were replaced with white-spaces in --prover_args. Example: Consider this call to certoraRun using CVL 1 syntax: bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --settings -smt_bitVectorTheory=true,- smt_hashingScheme=plainInjectivity,-assumeUnwindCond In order to convert this call to CVL 2 we: 1. renamed --settings to --prover_args 2. replaced -assumeUnwindCond with the flag --optimistic_loop 3. removed the comma and equal sign separators bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --optimistic_loop \\ --prover_args '-smt_bitVectorTheory true -smt_hashingScheme plainInjectivity' ## Solidity Compiler Args --- ## The Solidity Compiler Args The Solidity Compiler Args are CLI flags that are sent to the Solidity compiler. The behavior of the Solidity Args is similar to Prover Args. The flag --solc_args can only be used if there is no CLI flag that sets the Solidity flag and the value of --solc_args is a string that is sent as is to the Solidity compiler. ### Example: Consider this call to certoraRun using CVL 1 syntax: bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --solc_args \"['--optimize', '--optimize-runs', '200', '--experimental-via-ir']\" In CVL 2 calling optimize is using --solc_optimize bash certoraRun Compound.sol \\ --verify Compound:Compound.spec \\ --solc solc8.13 \\ --solc_optimize 200 \\ --solc_args \"--experimental-via-ir\" ## Enhanced server support In CVL 1, two server platforms were supported: 1. staging was set using the flag --staging [Branch/hotfix] 2."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "changes", "id": "74fcf9fd150d-18", "chunk-uid": "74fcf9fd150d", "chunk-page-index": 18, "text": "production was set using the flag --cloud [Branch/hotfix] In CVL 2 the flag --server was added to replace --staging --cloud and to allow adding additional server platforms. --server gets as a parameter the platform name. --prover_version is a new flag in CVL 2 For setting the Branch/hot-fix"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "opcodes", "id": "a493f2fd9ff9-0", "chunk-uid": "a493f2fd9ff9", "chunk-page-index": 0, "text": "## Using Opcode Hooks Opcode hooks are useful for reasoning about the low-level behavior of your contracts, and for accessing EVM state that is otherwise unavailable in CVL. This guide gives a few examples of how opcode hooks can be used. ### Accessing environment variables In CVL, you can access EVM variables like msg.sender using an environment object <env>. However, env objects do not contain all of the EVM state that is available to contracts. We made this choice for a few reasons: for one, it would be annoying to have to manually specify that global constants like the chain ID are same in every transaction. Another is that we have tried to decouple CVL from EVM as much as possible. Nevertheless, sometimes you need access to EVM variables that are not included in the env type, such as the CHAINID or GASPRICE. You can use opcode hooks on the corresponding instructions to restrict these values or save them in ghost-variables for use in rules. % TODO: make an actual example in the examples repo For example, if your contract uses chainid() to detect whether it is running on the Ethereum Mainnet, you could ensure that the chain ID is always 1 (which is the Ethereum Mainnet chain ID) by adding the following hook: cvl hook CHAINID uint id { require id == 1; } Alternatively, you could save the chain ID in a ghost variable and then use it in your rule: cvl ghost uint chainid; hook CHAINID uint id { chainid = id; } The contract's behavior changes appropriately when run on mainnet rule chainidbehaviorcorrect { ... if (chain_id == 1) { ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "opcodes", "id": "a493f2fd9ff9-1", "chunk-uid": "a493f2fd9ff9", "chunk-page-index": 1, "text": "} else { ... } } ### Detecting CALL instructions Suppose you want to ensure that a specific contract function never makes an external call while it is in an emergency shutdown mode. In order to verify this property, you need to know whether the contract has made a call. You can use a hook on the CALL opcode to write such a rule: cvl ghost bool made_call; hook CALL(uint g, address addr, uint value, uint argsOffset, uint argsLength, uint retOffset, uint retLength) uint rc { made_call = true; } While in emergencyMode, no function can make an external call. rule nocallduringemergency { require !madecall; require emergencyMode(); method f; env e; calldataarg args; f(e, args); assert !made_call; } In this example, the made_call variable gets set to true whenever the contract executes the CALL opcode, which is used to make external calls. The rule simply asserts that this variable is false (note that we required !made_call to avoid counterexamples where made_call started out set). --- ## Using Opcode Hooks Opcode hooks are useful for reasoning about the low-level behavior of your contracts, and for accessing EVM state that is otherwise unavailable in CVL. This guide gives a few examples of how opcode hooks can be used. ### Accessing environment variables In CVL, you can access EVM variables like msg.sender using an environment object. However, env objects do not contain all of the EVM state that is available to contracts. We made this choice for a few reasons: for one, it would be annoying to have to manually specify that global constants like the chain ID are same in every transaction. Another is that we have tried to decouple CVL from EVM as much as possible. Nevertheless, sometimes you need access to EVM variables that are not included in the env type, such as the CHAINID or GASPRICE. You can use opcode hooks on the corresponding instructions to restrict these values or save them in ghost-variables for use in rules. For example, if your contract uses chainid() to detect whether it is running on the Ethereum Mainnet, you could ensure that the chain ID is always 1 (which is the Ethereum Mainnet chain ID) by adding the following hook: cvl hook CHAINID uint id { require id == 1; } Alternatively, you could save the chain ID in a ghost variable and then use it in your rule: cvl ghost uint chainid; hook CHAINID uint id { chainid = id; } /// The contract's behavior changes appropriately when run on mainnet rule chainidbehaviorcorrect { ... if (chain_id == 1) { ... } else { ... } } Detecting CALL instructions Suppose you want to ensure that a specific contract function never makes an external call while it is in an emergency shutdown mode. In order to verify this property, you need to know whether the contract has made a call. You can use a hook on the CALL opcode to write such a rule: cvl ghost bool made_call; hook CALL(uint g, address addr, uint value, uint argsOffset, uint argsLength, uint retOffset, uint retLength) uint rc { made_call = true; } /// While in emergencyMode, no function can make an external call. rule nocallduringemergency { require !madecall; require emergencyMode(); method f; env e; calldataarg args; f(e, args); assert !made_call; --- ## In this example The made_call variable gets set to true whenever the contract executes the CALL opcode, which is used to make external calls. The rule simply asserts that this variable is false (note that we required !made_call to avoid counterexamples where made_call started out set). % TODO: % Reasoning about new contracts % ----------------------------- % Using the CREATE1 and CREATE2 opcode hooks % % Detecting events % ---------------- % Using the LOGn opcodes. % % ## Using call hooks % % {todo} % Ensure that the `ecrecover` function is checked whenever the signed transaction % function changes a balance % % % ### Call hooks or summarization? % % {todo} % Now we have hooks on calls and also summaries that can call contract functions; % these do similar things. Which is the recommended way / what are the tradeoffs?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "opcodes", "id": "a493f2fd9ff9-2", "chunk-uid": "a493f2fd9ff9", "chunk-page-index": 2, "text": "% %"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-0", "chunk-uid": "8438241533a2", "chunk-page-index": 0, "text": "## A Simple Map The code The below code contains the implementation of a simple map data structure, holding uint keys, uint values, and assuming that the value 0 indicates a non-existent key. It is possible to get, insert, or remove a key from the map. solidity pragma solidity ^0.7.0; contract SimpleMap { mapping(uint => uint) internal map; function get(uint key) public view returns(uint) { return map[key]; } function insert(uint key, uint value) external { require(value != uint(0), \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; } function remove(uint key) external { require (map[key] != uint(0), \"Key does not exist\"); map[key] = uint(0); } function contains(uint key) public view returns (bool) { if (map[key] == uint(0)) { return false; } return true; } } In the next sections of the tutorial, we will generalize this trivial contract to support enumeration of the keys in the map. Writing specs Writing rules requires us to consider what are the high-level properties our contract should satisfy. We show some simple and useful patterns for rules. Generalized unit tests Rules that generalize unit tests focus on a single state-mutating function of the contract and ensure that the state is mutated as expected. The main benefits of these rules are that they are easy to develop due to their similarity to unit tests. The added advantage compared to unit tests is that they only use symbolic values, meaning that we check not a single set of concrete values in the unit test but all possible values. Here is a simple rule for the insert function: cvl rule checkInsert(uint key, uint value) { env e; insert(e, key, value); assert get(key) == value, \"value of key is not equal to the inserted value\"; assert contains(key), \"key is not contained after successful insertion\"; } This rule checks that once a key is successfully inserted with insert, getting the key with get returns the value inserted. The key and value parameters declared in the rule's header are completely arbitrarily chosen. The env (environment) variable e is capturing the (symbolic) values of the blockchain variables, such as msg.sender and block.number. --- invocation of insert expects to get as a first argument the environment variable, followed by the arguments according to the function's declaration. {note} Note that by default, the invocation of a function is assumed to succeed. That is, reverting paths of the function are ignored. After calling insert, we wish to examine if the mutated state is as expected. Therefore, we assert that calling get(key) is returning the value value inserted. It is possible to add an explanation string to the assertion, which may help in finding out which assertion was violated if a rule contains more than one assertion. We are now ready to run the tool: suppose the contract is saved in a file called SimpleMap.sol, and the spec is saved in a file simpleMap.spec, we can run the tool as follows: bash certoraRun SimpleMap.sol --verify SimpleMap:simpleMap.spec Which tells the tool to include the SimpleMap contract in its verification context, and to verify it using the provided spec file. Unfortunately, the tool outputs the following error: [main] ERROR log.Logger - Syntax error in spec file (9:5): could not type expression \"get(key)\", message: Could not find an overloading of method get that matches the given arguments: uint. Method is not envfree; did you forget to provide the environment as the first function argument?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-1", "chunk-uid": "8438241533a2", "chunk-page-index": 1, "text": "The cause of the failure is that we did not pass an environment variable to the invocation of get. While it is possible to reuse e or even declare another environment variable, we note that get does not depend on any of the blockchain-related variables. Thus, we can tell the Prover to relieve us from specifying the environment by adding the following declaration to the top of the spec file: cvl methods { get(uint) returns uint envfree } Add an envfree declaration for the method contains too. Revert conditions As noted before, by default, invocations are assuming only the non-reverting paths of the function. It is useful to precisely characterize all conditions that guarantee that the function would not revert. We can write such a rule for insert: cvl rule insertRevertConditions(uint key, uint value) { env e; insert@wiprevert(e, key, value); bool succeeded = !lastReverted; assert value != 0 => succeeded; } Here, we invoke insert but append to the function name the modifier @withrevert that tells the Prover to skip the pruning of reverting paths. (One could also stress that a function should prune the reverting paths using @norevert, although this is equivalent to not writing any modifier at all.) We then save into a boolean variable the negation of lastReverted, which is a special keyword set to true if the last invocation reverted. We then assert that if the value inserted is non-zero (recall that we consider 0 to be an illegal value in our map implementation), then the value of succeeded must be true. {note} `lastReverted` will _always_ be `false` following an invocation that is not permitting reverting paths. Running the Prover on the new rule, it returns a failure. The failure is happening because value is non-zero yet the insert function reverted anyway. call trace example A hint towards what happened can be found in the Variables section. The value of e.msg.value is indicating the msg.value used in insert. Since insert is not a payable function, it is expected to revert when msg.value is non-zero, --- which is indeed our case here. We refine the rule as follows, and require that e.msg.value is 0: cvl rule insertRevertConditions(uint key, uint value) { env e; insert@withrevert(e, key, value); bool succeeded = !lastReverted; assert (e.msg.value == 0 && value != 0) =&gt; succeeded; } We run the rule again, but it still fails: call trace example - second failure We get a call trace that tells us the most important operations performed by the bytecode of the contract, on which the Prover operates. The call trace tells us that we were reading from a storage slot the value 1. To assist us in identifying the issue, in parenthesis we get a reference to the matching source code, which is the load of map[key] in line 19, which is where the contains function is defined. We understand that we forgot to include the condition that the key does not already exist in the map. So we refine the code again: cvl rule insertRevertConditions(uint key, uint value) { env e; bool containsKey = contains(key); insert@withrevert(e, key, value); bool succeeded = !lastReverted; assert (e.msg.value == 0 && value != 0 && !containsKey) =&gt; succeeded; } And finally our rule is successfully verified. Inverses In some cases, we can reach wider coverage if we write rules that check the interaction of multiple functions with each other. In the map implementation, it is natural to check that insert and remove are inverses of one another. Specifically, we'd like to check that: - Invoking remove after a successful insert must succeed too. - The value of a key that was inserted and immediately removed is not the value that we inserted. The below rule shows how we can check these two assertions: cvl rule inverses(uint key, uint value) { env e; insert(e, key, value); env e2; require e2.msg.value == 0; remove@withrevert(e2, key); bool removeSucceeded = !lastReverted; assert removeSucceeded, \"remove after insert must succeed\"; assert get(key) != value, \"value of removed key must not be the inserted value\"; } Note that we use two separate environments for insert and remove for better coverage. {note} Reuse of environment variables could lead to vacuity, which is expanded upon in other sections of this manual."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-2", "chunk-uid": "8438241533a2", "chunk-page-index": 2, "text": "{note} It is recommended to keep lastReverted in separate variables to clearly indicate which invocation we refer to, and to avoid confusion if invocations are reordered. --- ## This rule is verified by the Prover. ## A Simple Map The code The below code contains the implementation of a simple map data structure, holding uint keys, uint values, and assuming that the value 0 indicates a non-existent key. It is possible to get, insert, or remove a key from the map. solidity pragma solidity ^0.7.0; contract SimpleMap { mapping(uint => uint) internal map; function get(uint key) public view returns(uint) { return map[key]; } function insert(uint key, uint value) external { require(value != uint(0), \"0 is not a valid value\"); require (!contains(key), \"key already exists\"); map[key] = value; } function remove(uint key) external { require (map[key] != uint(0), \"Key does not exist\"); map[key] = uint(0); } function contains(uint key) public view returns (bool) { if (map[key] == uint(0)) { return false; } return true; } } In the next sections of the tutorial, we will generalize this trivial contract to support enumeration of the keys in the map. ## Writing specs Writing rules requires us to consider what are the high-level properties our contract should satisfy. We show some simple and useful patterns for rules. ## Generalized unit tests Rules that generalize unit tests focus on a single state-mutating function of the contract and ensure that the state is mutated as expected. The main benefits of these rules are that they are easy to develop due to their similarity to unit tests. The added advantage compared to unit tests is that they only use symbolic values, meaning that we check not a single set of concrete values in the unit test but all possible values. Here is a simple rule for the insert function: cvl rule checkInsert(uint key, uint value) { env e; insert(e, key, value); assert get(key) == value, \"value of key is not equal to the inserted value\"; assert contains(key), \"key is not contained after successful insertion\"; } --- This rule checks that once a key is successfully inserted with insert, getting the key with get returns the value inserted. The key and value parameters declared in the rule's header are completely arbitrarily chosen. The env (environment) variable e is capturing the (symbolic) values of the blockchain variables, such as msg.sender and block.number. The invocation of insert expects to get as a first argument the environment variable, followed by the arguments according to the function's declaration. Note: Note that by default, the invocation of a function is assumed to succeed. That is, reverting paths of the function are ignored. After calling insert, we wish to examine if the mutated state is as expected. Therefore, we assert that calling get(key) is returning the value value inserted. It is possible to add an explanation string to the assertion, which may help in finding out which assertion was violated if a rule contains more than one assertion. We are now ready to run the tool: suppose the contract is saved in a file called SimpleMap.sol, and the spec is saved in a file simpleMap.spec, we can run the tool as follows: bash certoraRun SimpleMap.sol --verify SimpleMap:simpleMap.spec Which tells the tool to include the SimpleMap contract in its verification context, and to verify it using the provided spec file. Unfortunately, the tool outputs the following error: [main] ERROR log.Logger - Syntax error in spec file (9:5): could not type expression \"get(key)\", message: Could not find an overloading of method get that matches the given arguments: uint. Method is not envfree; did you forget to provide the environment as the first function argument?"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-3", "chunk-uid": "8438241533a2", "chunk-page-index": 3, "text": "The cause of the failure is that we did not pass an environment variable to the invocation of get. While it is possible to reuse e or even declare another environment variable, we note that get does not depend on any of the blockchain-related variables. Thus, we can tell the Prover to relieve us from specifying the environment by adding the following declaration to the top of the spec file: cvl methods { get(uint) returns uint envfree } Add an envfree declaration for the method contains too. Revert conditions As noted before, by default, invocations are assuming only the non-reverting paths of the function. It is useful to precisely characterize all conditions that guarantee that the function would not revert. We can write such a rule for insert: cvl rule insertRevertConditions(uint key, uint value) { env e; insert@wiprevert(e, key, value); bool succeeded = !lastReverted; assert value != 0 => succeeded; } Here, we invoke insert but append to the function name the modifier @withrevert that tells the Prover to skip the pruning of reverting paths. (One could also stress that a function should prune the reverting paths using @norevert, although this is equivalent to not writing any modifier at all.) We then save into a boolean variable the negation of lastReverted, which is a special keyword set to true if the last invocation reverted. We then assert that if the value inserted is non-zero (recall that we consider 0 to be an illegal value in our map implementation), then the value of succeeded must be true. Note: lastReverted will always be false following an invocation that is not permitting reverting paths. Running the Prover on the new rule, it returns a failure. The failure is happening because value is non-zero yet the insert function reverted anyway. --- A hint towards what happened can be found in the Variables section. The value of e.msg.value is indicating the msg.value used in insert. Since insert is not a payable function, it is expected to revert when msg.value is non-zero, which is indeed our case here. We refine the rule as follows, and require that e.msg.value is 0: cvl rule insertRevertConditions(uint key, uint value) { env e; insert@wiprevert(e, key, value); bool succeeded = !lastReverted; assert (e.msg.value == 0 && value != 0) => succeeded; We run the rule again, but it still fails: call trace example - second failure We get a call trace that tells us the most important operations performed by the bytecode of the contract, on which the Prover operates. The call trace tells us that we were reading from a storage slot the value 1."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-4", "chunk-uid": "8438241533a2", "chunk-page-index": 4, "text": "To assist us in identifying the issue, in parenthesis we get a reference to the matching source code, which is the load of map[key] in line 19, which is where the contains function is defined. We understand that we forgot to include the condition that the key does not already exist in the map. So we refine the code again: cvl rule insertRevertConditions(uint key, uint value) { env e; bool containsKey = contains(key); insert@wiprevert(e, key, value); bool succeeded = !lastReverted; assert (e.msg.value == 0 && value != 0 && !containsKey) => succeeded; And finally our rule is successfully verified. Inverses In some cases, we can reach wider coverage if we write rules that check the interaction of multiple functions with each other. In the map implementation, it is natural to check that insert and remove are inverses of one another. Specifically, we'd like to check that: - Invoking remove after a successful insert must succeed too. - The value of a key that was inserted and immediately removed is not the value that we inserted. The below rule shows how we can check these two assertions: cvl rule inverses(uint key, uint value) { env e; insert(e, key, value); env e2; require e2.msg.value == 0; remove@wiprevert(e2, key); bool removeSucceeded = !lastReverted; assert removeSucceeded, \"remove after insert must succeed\"; assert get(key) != value, \"value of removed key must not be pe inserted value\"; } Note that we use two separate environments for insert and remove for better coverage. {note} Reuse of environment variables could lead to vacuity, which is expanded upon in other sections of this manual."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "simple", "id": "8438241533a2-5", "chunk-uid": "8438241533a2", "chunk-page-index": 5, "text": "--- {note} It is recommended to keep `lastReverted` in separate variables to clearly indicate which invocation we refer to, and to avoid confusion if invocations are reordered. This rule is verified by the Prover."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "report_changelog", "id": "962a9d2b1c42-0", "chunk-uid": "962a9d2b1c42", "chunk-page-index": 0, "text": "# Rules Report Release Notes |Version|Date|Features| |---|---|---| |1.0.0|Apr 11, 2024|[feat] Jump To Source: Animation to highlight already selected line on button click [feat] New Job Configuration Tab that provides details on all arguments and inputs of a job that has been executed with (main contract, solidity version, all prover flags and CLI options) [feat] Browser tab title now indicates the main contract and the message of the job to simplify identification of a job [feat] Files with extension .yul - Yul files - can be displayed in the editor [fix] When a job has been canceled or halted, only rules that were running are being displayed as killed| |0.8.0|Mar 11, 2024|[feat] Jump To Source Feature (works only in combination with Certora version later than 7.1.0) [feat] New tooltips on labels for the call trace| |0.7.0|Feb 12, 2024|[fix] Fixed bug when collapsing the left pane of the main grid [fix] Fixed bug when collapsing entries in the call trace| |0.6.0|Jan 31, 2024|[feat] Live Difficulty Statistics [feat] Adding tool tips to status [fix] Fixed file contents were shown to be loading for indefinite time| |0.5.7|Nov 26, 2023|[feat] Improvements on naming for global / rule notifications| --- ## Bugs [fix] Fixed removed links to deprecated Certora Forum ## Features [feat] Shareable report button [feat] Foldable call trace [feat] Added view of .conf files in pe source files tab [feat] New Tracking Points feature in pe call trace [feat] Added support for Witness examples view [feat] Added link to pe unsat core page inside info tab [feat] Added job status at pe top level [feat] Default first load of pe report shows pe spec file and rules tab only [feat] Display pe report version in pe info tab [feat] Added a floating column option for pe main sidebar [feat] Added animated icons for jobs status in progress [feat] Files tab keeps expanded files state [feat] Improved filter, filter highlight, and search highlight functionality inside call resolutions [feat] Added code editor scroll position to state [feat] Added columns widp to local storage [feat] Removed cancel job button from pe report [feat] Removed auto-scroll in call Trace [feat] Improved drop filters [feat] Improved component's state handling [feat] Added upload failed view ## Bugs [bugfix] Fixed pe issue of selected file not being shown in pe file tree [bugfix] Fixed call resolution empty state issue [bugfix] Fixed global problems empty state issue [bugfix] Support for view of files wip same name in different folders [bugfix] Support file opening twice [bugfix] Fixed handling collapse functionality when data is filtered [bugfix] Fixed Firefox warnings on pe source files tab [bugfix] Fixed filter and collapse on contracts and global call resolution tabs to be consistent [bugfix] Fixed contracts tab to show more/less and line breaks [bugfix] Fixed UI breaking when selecting a new rule [bugfix] Fixed issue of multi counter example shown wipout call trace [bugfix] Fixed call resolution opening two items by default instead of one [bugfix] Fixed view of job run time to excluded pe time pe job waited in pe queue [bugfix] Fixed variables sorting order ## Rules Report Release Notes 1.0.0 (Apr 11, 2024) --- ## Features [feat] Jump To Source: Animation to highlight already selected line on button click [feat] New Job Configuration Tab pat provides details on all arguments and inputs of a job pat has been executed wip (main contract, solidity version, all prover flags and CLI options) [feat] Browser tab title now indicates pe main contract and pe message of pe job to simplify identification of a job [feat] Files wip extension .yul - Yul files - can be displayed in pe editor ## 0.8.0 (Mar 11, 2024) ## Features [feat] Jump To Source Feature (works only in combination wip Certora version later pan 7.1.0) [feat] New tooltips on labels for pe call trace ## Bugs [fix] Fixed tracking points [fix] Fixed sharing button ## 0.7.0 (Feb 12, 2024) ## Bugs [fix] Fixed bug when collapsing pe left pane of pe main grid [fix] Fixed bug when collapsing entries in pe call trace ## 0.6.0 (Jan 31, 2024) ## Features [feat] Live Difficulty Statistics [feat] Adding tool tips to status ## Bugs [fix] Fixed file contents were shown to be loading for indefinite time ## 0.5.7 (Nov 26, 2023) ## Features [feat] Improvements on naming for global / rule notifications ## 0.5.62 (Feb 11, 2024) ## Bugs [fix] Fixed removed links to deprecated Certora Forum ## 0.5.6 (October 24, 2023) --- ## Features - [feat] Shareable report button - [feat] Foldable call trace - [feat] Added view of .conf files in the source files tab - [feat] New Tracking Points feature in the call trace - [feat] Added support for Witness examples view - [feat] Added link to the unsat core page inside info tab - [feat] Added job status at the top level - [feat] Default first load of the report shows the spec file and rules tab only - [feat] Display the report version in the info tab - [feat] Added a floating column option for the main sidebar - [feat] Added animated icons for jobs status in progress - [feat] Files tab keeps expanded files state - [feat] Improved filter, filter highlight, and search highlight functionality inside call resolutions - [feat] Added code editor scroll position to state - [feat] Added columns width to local storage - [feat] Removed cancel job button from the report - [feat] Removed auto-scroll in call Trace - [feat] Improved drop filters - [feat] Improved component's state handling - [feat] Added upload failed view ## Bugs - [bugfix] Fixed the issue of selected file not being shown in the file tree - [bugfix] Fixed call resolution empty state issue - [bugfix] Fixed global problems empty state issue - [bugfix] Support for view of files with same name in different folders - [bugfix] Support file opening twice - [bugfix] Fixed handling collapse functionality when data is filtered - [bugfix] Fixed Firefox warnings on the source files tab - [bugfix] Fixed filter and collapse on contracts and global call resolution tabs to be consistent - [bugfix] Fixed contracts tab to show more/less and line breaks - [bugfix] Fixed UI breaking when selecting a new rule - [bugfix] Fixed issue of multi counter example shown without call trace - [bugfix] Fixed call resolution opening two items by default instead of one - [bugfix] Fixed view of job run time to excluded the time the job waited in the queue - [bugfix] Fixed variables sorting order"}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "satisfy", "id": "0f290698cdd8-0", "chunk-uid": "0f290698cdd8", "chunk-page-index": 0, "text": "{role} cvl(code) :language: cvl {role} solidity(code) :language: solidity (producing-examples) Producing Positive Examples Sometimes it is useful to produce examples of an expected behavior instead of counterexamples that demonstrate unexpected behavior. You can do this by writing a rule that uses {ref}satisfy instead of the assert command. For each satisfy command in a rule, the Prover will produce an example that makes the condition true, or report an error. The purpose of the satisfy statement is to produce examples that demonstrate some execution of the code. Not every example is interesting — users should inspect the example to ensure that it demonstrates the expected behavior. For {clink}example </DEFI/ConstantProductPool/certora/spec/ConstantProductPool.spec>, we may be interested in showing that it is possible for someone to deposit some assets into a pool and then immediately withdraw them. The following rule demonstrates this scenario: {cvlinclude} /Examples/DEFI/ConstantProductPool/certora/spec/ConstantProductPool.spec :cvlobject: possibleToFullyWithdraw :caption: Positive example The Prover will produce an example that satisfies this condition. Sometimes the example will be uninteresting, such as having {cvl}amount == 0 in the example for {cvl}possibleToFullyWithdraw. In such cases we need to strengthen the conditions in order to produce more interesting examples. In {cvl}possibleToFullyWithdraw we added a {cvl}require amount > 0; statement to prevent such a case. Alternatively, we could have strengthened the {cvl}satisfy condition by adding {role} cvl(code) :language: cvl {role} solidity(code) :language: solidity (producing-examples) Producing Positive Examples Sometimes it is useful to produce examples of an expected behavior instead of counterexamples that demonstrate unexpected behavior. You can do this by writing a rule that uses {ref}satisfy instead of the assert command. For each satisfy command in a rule, the Prover will produce an example that makes the condition true, or report an error. The purpose of the satisfy statement is to produce examples that demonstrate some execution of the code."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "satisfy", "id": "0f290698cdd8-1", "chunk-uid": "0f290698cdd8", "chunk-page-index": 1, "text": "Not every example is interesting — users should inspect the example to ensure that it demonstrates the expected behavior. For {clink}example </DEFI/ConstantProductPool/certora/spec/ConstantProductPool.spec>, we may be interested in showing that it is possible for someone to deposit some assets into a pool and then immediately withdraw them. The following rule demonstrates this scenario: {cvlinclude} /Examples/DEFI/ConstantProductPool/certora/spec/ConstantProductPool.spec :cvlobject: possibleToFullyWithdraw :caption: Positive example The Prover will produce an example that satisfies this condition. Sometimes the example will be uninteresting, such as having {cvl}amount == 0 in the example for {cvl}possibleToFullyWithdraw. In such cases we need to strengthen the conditions in order to produce more interesting examples. In {cvl}possibleToFullyWithdraw we added a {cvl}require amount > 0; statement to prevent such a case. --- Alternatively, we could have strengpened pe satisfy condition by adding cvl satisfy (amount &gt; 0) &amp;&amp; ..."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "intro", "id": "f9fc38a03018-0", "chunk-uid": "f9fc38a03018", "chunk-page-index": 0, "text": "# Introduction This Reference Manual contains detailed and comprehensive information about the Certora Prover. The Reference Manual is intended to describe what the Prover does, in contrast to the {doc}/docs/user-guide/index which explains how to use the Prover to accomplish particular goals."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-0", "chunk-uid": "246afcfcf552", "chunk-page-index": 0, "text": "## Types Like Solidity, CVL is a statically typed language. There is overlap between the types supported by Solidity and the types supported by CVL, but CVL has some additional types and is also missing support for some Solidity types. The additional CVL types are: - mathint is an arbitrary precision integer that cannot overflow - method-type are used to represent arbitrary methods and arguments of the contract under verification - storage-type is used to represent a snapshot of the entire EVM storage - env is used to represent the Solidity global variables msg, block, and tx - sort are used to represent unknown types ## Syntax The syntax for types in CVL is given by the following EBNF grammar: basictype ::= \"int*\" | \"uint*\" | \"address\" | \"bool\" | \"string\" | \"bytes*\" | basictype \"[\" [ number ] \"]\" | id \".\" id evmtype ::= basictype | \"(\" evmtype { \",\" evmtype } \")\" | evm_type \"[\" [ number ] \"]\" cvltype ::= basictype | \"mathint\" | \"calldataarg\" | \"storage\" | \"env\" | \"method\" | id See basics for the id and number productions. ## Solidity Types You can declare variables in CVL of any of the following solidity types: - int, uint, and the sized variants such as uint256 and int8 - bool, address, and the sized bytes variants (bytes1 through bytes32) - string and bytes - Single-dimensional arrays (both statically- and dynamically-sized) - Enum types, struct types, and type aliases that are defined in Solidity contracts The following are not directly supported in CVL, although you can interact with contracts that use them (see type-conversions): - Function types - Multi-dimensional arrays - Mappings ## Integer types CVL integer types are mostly identical to Solidity integer types. See math-ops for details. ## Array access Array accesses in CVL behave slightly differently from Solidity accesses. In Solidity, an out-of-bounds array access will result in an exception, causing the transaction to revert. By contrast, out-of-bounds array accesses in CVL are treated as undefined values: if i > a.length then the Prover considers every possible value for a[i] when constructing counterexamples. --- ## User-defined types Specifications can use structs, enums, or user-defined value types that are defined in Solidity contracts. Struct types have the following limitations: - Assignment to struct fields is unsupported. You can achieve the same effect using a require statement."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-1", "chunk-uid": "246afcfcf552", "chunk-page-index": 1, "text": "For example, instead of s.f = x; you can write require s.f == x;. However, be aware that require statements can introduce vacuity if there are multiple conflicting constraints. All user-defined type names (structs, enums, and user-defined values) must be explicitly qualified by the contract name that contains them. For types defined within a contract, the named contract must be the contract containing the type definition. Note that if a contract inherits a type from a supertype, the contract that actually contains the type must be named, not the inheriting contract. For types defined at the file level, the named contract can be any contract in the scene from which the type is visible. Warning: If you do not qualify the type name with a contract name, the type name will be misinterpreted as a sort. For example, consider the files parent.sol and child.sol, defined as follows: parent.sol solidity type ParentFileType is uint64; contract Parent { enum ParentContractType { member1, member2 } } child.sol solidity import 'parent.sol'; type ChildFileType is bool; contract Child is Parent { type alias ChildContractType is uint128; } Given these definitions, types can be named as follows: child.spec cvl // valid types Parent.ParentFileType valid1; Child.ParentFileType valid2; Parent.ParentContractType valid3; --- ## Additional CVL types The mathint type Arithmetic overflow and underflow are difficult to reason about and often lead to bugs. To avoid this complexity, CVL provides the mathint type that can represent an integer of any size; operations on mathints can never overflow or underflow. See math-ops for details on mathematical operations and casting between mathint and Solidity integer types. The env type Rules often reason about the effects of multiple transactions. In different transactions, the global Solidity variables (such as msg.sender or block.timestamp) may have different values. To support reasoning about multiple transactions, CVL groups some of the solidity global variables into an \"environment\": an object of the special type env. Environments must be passed as the first argument of a call from CVL into a contract function (unless the contract function is declared envfree). For example, to call a Solidity function deposit(uint amount), a spec must explicitly pass in an additional environment argument: cvl rule check_deposit() { env e; uint amount; deposit(e, amount); // increases e.msg.sender's balance by `amount` } The value of the Solidity global variables can be extracted from the env object using a field-like syntax. The following fields are available on an environment e: |e.msg.sender|address of the sender of the message| |---|---| |e.msg.value|number of Wei sent with the message| |e.block.number|current block number| |e.block.timestamp|current block's time stamp| |e.block.basefee|current block's base fee| |e.block.coinbase|current block's coinbase| |e.block.difficulty|current block's difficulty| |e.block.gaslimit|current block's gas limit| |e.tx.origin|original message sender| The remaining solidity global variables are not accessible from CVL. The method and calldataarg types Formerly, parametric method calls would only call methods of `currentContract`; now they call methods of all contracts. This version also introduced the `f.contract` field. An important feature of CVL is the ability to reason about the effects of an arbitrary method called with arbitrary arguments. To support this, CVL provides the method type to represent an arbitrary method, and the calldataarg type to represent an arbitrary set of arguments. --- ### For example, the following rule checks that no method can decrease the user's balance: cvl rule balanceincreasing() { address user; uint balancebefore = balance(user); mepod f; env e; calldataarg args; f(e,args); uint balance_after = balance(user); assert balance_after >= balance_before, \"balance must be increasing\"; } Since f, e, and args are not given values, the Prover will consider every possible assignment. This means that when evaluating the call to f(e,args), the Prover will check the rule on every method of every contract on the scene, with every possible set of method arguments. See parametric-rules for more information about how rules that declare method variables are verified. Variables of type method can only be declared as an argument to the rule or directly in the body of a rule. They may not be nested inside of if statements or declared in CVL functions. They may be passed as arguments to CVL functions. Properties of methods can be extracted from method variables using a field-like syntax. The following fields are available on a method m: - m.selector - the ABI signature of the method - m.isPure - true when m is declared with the pure attribute - m.isView - true when m is declared with the view attribute - m.isFallback - true when m is the fallback function - m.numberOfArguments - the number of arguments to method m - m.contract - the receiver contract for the method There is no way to examine the contents of a calldataarg variable, because the type of its contents vary depending on which method the Prover is checking. The only thing you can do with it is pass it as an argument to a contract method call."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-2", "chunk-uid": "246afcfcf552", "chunk-page-index": 2, "text": "It is possible to work around this limitation; see partially parametric rules for further details. ### storage-type The storage type The Certora Prover can compare different hypothetical transactions starting from the same state and compare their results. For example, checking a property like \"if you stake more, you earn more\" requires comparing the earnings after two possible transactions starting in the same initial state: one where you stake less, and one where you stake more. Properties that compare the results of different hypothetical executions are sometimes called hyperproperties. CVL supports this kind of specification using the special storage type. A variable of type storage represents a snapshot of the EVM storage and the state of ghosts at a given point in time. The EVM storage can be reset to a saved storage value s by appending at s to the end of a function call. For example, the following rule checks that \"if you stake more, you earn more\": cvl rule biggerstakemore_earnings() { storage initial = lastStorage; env e; uint less; uint more; require less < more; // stake less --- ## stake(e, less) at initial; earnings_less = earnings(e); ## stake more stake(e, more) at initial; earnings_more = earnings(e); assert earnings_less &lt; earnings_more, \"if you stake more, you earn more\"; The lastStorage variable contains the state of the EVM after the most recent contract function call. Variables of storage type can also be compared for equality, allowing simple rules that check the equivalence of different functions."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-3", "chunk-uid": "246afcfcf552", "chunk-page-index": 3, "text": "See storage-comparison for details. ## Uninterpreted sorts [todo] This section is incomplete."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-4", "chunk-uid": "246afcfcf552", "chunk-page-index": 4, "text": "See the old documentation. ## Conversions between CVL and Solidity types When a specification calls a contract function, the Prover must convert the arguments from their CVL types to the corresponding Solidity types, and must convert the return values from Solidity back to CVL. The Prover must also apply these conversions when inlining hooks and function summaries. There are restrictions on what types can be converted from CVL to Solidity and vice-versa. In general, if a contract uses a type that is not convertible, you can still interact with it, but you cannot access the corresponding values. For example, if a contract function returns a type that isn't convertible to CVL, you can call the function from CVL but you cannot access its return type. Similarly, if the function accepts an argument of a type that is not representable in CVL, you can still call the function from CVL, but only by providing it a generic calldataarg argument. The following restrictions apply when converting between CVL types and Solidity types: - The type must be a valid CVL type (except for contract or interface types, which are represented by address). - Reference types (arrays and structs) can only be passed to Solidity functions that expect calldata or memory arguments; there is no way to pass storage arrays. - Arrays returned from Solidity can only be converted to CVL if their elements have value types that are representable in CVL. There are additional restrictions on the types for arguments and return values for internal function summaries; see function-summary. ## Types Like Solidity, CVL is a statically typed language. There is overlap between the types supported by Solidity and the types supported by CVL, but CVL has some additional types and is also missing support for some Solidity types. The additional CVL types are: - mathint is an arbitrary precision integer that cannot overflow - method-type are used to represent arbitrary methods and arguments of the contract under verification - storage-type is used to --- ## represent a snapshot of the entire EVM storage {ref}env is used to represent the Solidity global variables msg, block, and tx - {ref}sort are used to represent unknown types ## {contents} Syntax The syntax for types in CVL is given by the following EBNF grammar: basictype ::= \"int*\" | \"uint*\" | \"address\" | \"bool\" | \"string\" | \"bytes*\" | basictype \"[\" [ number ] \"]\" | id \".\" id evmtype ::= basictype | \"(\" evmtype { \",\" evmtype } \")\" | evm_type \"[\" [ number ] \"]\" cvltype ::= basictype | \"mathint\" | \"calldataarg\" | \"storage\" | \"env\" | \"method\" | id See {doc}basics for the id and number productions. Solidity Types You can declare variables in CVL of any of the following solidity types: - int, uint, and the sized variants such as uint256 and int8 - bool, address, and the sized bytes variants (bytes1 through bytes32) - string and bytes - Single-dimensional arrays (both statically- and dynamically-sized) - Enum types, struct types, and type aliases that are defined in Solidity contracts. The following are not directly supported in CVL, although you can interact with contracts that use them (see type-conversions): * Function types * Multi-dimensional arrays * Mappings Integer types CVL integer types are mostly identical to Solidity integer types. See math-ops for details. Array access Array accesses in CVL behave slightly differently from Solidity accesses. In Solidity, an out-of-bounds array access will result in an exception, causing the transaction to revert. By contrast, out-of-bounds array accesses in CVL are treated as undefined values: if i > a.length then the Prover considers every possible value for a[i] when constructing counterexamples. CVL arrays also have the following limitations: - Only single dimensional arrays are supported - The push and pop methods are not supported. You can use harnessing to work around these limitations. User-defined types Specifications can use structs, enums, or user-defined value types that are defined in Solidity contracts. --- ## Struct types limitations Struct types have the following limitations: - Assignment to struct fields is unsupported. You can achieve the same effect using a require statement."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-5", "chunk-uid": "246afcfcf552", "chunk-page-index": 5, "text": "For example, instead of s.f = x; you can write require s.f == x;. However, be aware that require statements can introduce vacuity if there are multiple conflicting constraints. All user-defined type names (structs, enums, and user-defined values) must be explicitly qualified by the contract name that contains them. For types defined within a contract, the named contract must be the contract containing the type definition. Note that if a contract inherits a type from a supertype, the contract that actually contains the type must be named, not the inheriting contract. For types defined at the file level, the named contract can be any contract in the scene from which the type is visible. Warning: If you do not qualify the type name with a contract name, the type name will be misinterpreted as a sort. For example, consider the files parent.sol and child.sol, defined as follows: parent.sol type ParentFileType is uint64; contract Parent { enum ParentContractType { member1, member2 } } child.sol import 'parent.sol'; type ChildFileType is bool; contract Child is Parent { type alias ChildContractType is uint128; } Given these definitions, types can be named as follows: child.spec // valid types Parent.ParentFileType valid1; Child.ParentFileType valid2; Parent.ParentContractType valid3; // invalid types Child.ParentContractType invalid1; // user-defined types are not inherited Parent.ChildFileType invalid2; // ChildFileType is not visible in Parent ## Additional CVL types The mathint type --- ## Arithmetic Overflow and Underflow Arithmetic overflow and underflow are difficult to reason about and often lead to bugs. To avoid this complexity, CVL provides the mathint type that can represent an integer of any size; operations on mathints can never overflow or underflow. See math-ops for details on mathematical operations and casting between mathint and Solidity integer types. ## The env Type Rules often reason about the effects of multiple transactions. In different transactions, the global Solidity variables (such as msg.sender or block.timestamp) may have different values. To support reasoning about multiple transactions, CVL groups some of the solidity global variables into an \"environment\": an object of the special type env. Environments must be passed as the first argument of a call from CVL into a contract function (unless the contract function is declared envfree). For example, to call a Solidity function deposit(uint amount), a spec must explicitly pass in an additional environment argument: cvl rule check_deposit() { env e; uint amount; deposit(e, amount); // increases e.msg.sender's balance by `amount` } The value of the Solidity global variables can be extracted from the env object using a field-like syntax. The following fields are available on an environment e: |e.msg.sender|address of the sender of the message| |---|---| |e.msg.value|number of Wei sent with the message| |e.block.number|current block number| |e.block.timestamp|current block's time stamp| |e.block.basefee|current block's base fee| |e.block.coinbase|current block's coinbase| |e.block.difficulty|current block's difficulty| |e.block.gaslimit|current block's gas limit| |e.tx.origin|original message sender| The remaining solidity global variables are not accessible from CVL. ## The method and calldataarg Types Version Changed: 5.0 Formerly, parametric method calls would only call methods of `currentContract`; now they call methods of all contracts. This version also introduced the `f.contract` field. An important feature of CVL is the ability to reason about the effects of an arbitrary method called with arbitrary arguments. To support this, CVL provides the method type to represent an arbitrary method, and the calldataarg type to represent an arbitrary set of arguments. For example, the following rule checks that no method can decrease the user's balance: cvl rule balanceincreasing() { address user; uint balancebefore = balance(user); method f; env e; calldataarg args; f(e,args); } --- uint balance_after = balance(user); assert balance_after >= balance_before, \"balance must be increasing\"; Since f, e, and args are not given values, the Prover will consider every possible assignment. This means that when evaluating the call to f(e,args), the Prover will check the rule on every method of every contract on the {term}scene, with every possible set of method arguments. See {ref}parametric-rules for more information about how rules that declare method variables are verified. Variables of type method can only be declared as an argument to the rule or directly in the body of a rule. They may not be nested inside of if statements or declared in CVL functions. They may be passed as arguments to CVL functions. Properties of methods can be extracted from method variables using a field-like syntax. The following fields are available on a method m: |m.selector|m.isPure|m.isView|m.isFallback|m.numberOfArguments|m.contract| |---|---|---|---|---|---| |the ABI signature of the method|true when m is declared with the pure attribute|true when m is declared with the view attribute|true when m is the fallback function|the number of arguments to method m|the receiver contract for the method| There is no way to examine the contents of a calldataarg variable, because the type of its contents vary depending on which method the Prover is checking. The only thing you can do with it is pass it as an argument to a contract method call."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-6", "chunk-uid": "246afcfcf552", "chunk-page-index": 6, "text": "It is possible to work around this limitation; see {ref}partially parametric rules for further details. (storage-type)= The storage type The Certora Prover can compare different hypothetical transactions starting from the same state and compare their results. For example, checking a property like \"if you stake more, you earn more\" requires comparing the earnings after two possible transactions starting in the same initial state: one where you stake less, and one where you stake more. Properties that compare the results of different hypothetical executions are sometimes called hyperproperties. CVL supports this kind of specification using the special storage type. A variable of type storage represents a snapshot of the EVM storage and the state of {ref}ghosts <ghost-functions> at a given point in time. The EVM storage can be reset to a saved storage value s by appending at s to the end of a function call. For example, the following rule checks that \"if you stake more, you earn more\": ```cvl rule biggerstakemore_earnings() { storage initial = lastStorage; env e; uint less; uint more; require less < more; // stake less stake(e, less) at initial; earnings_less = earnings(e); // stake more stake(e, more) at initial; earnings_more = earnings(e); assert earnings_less < earnings_more, \"if you stake more, you earn more\"; --- ## The lastStorage variable contains the state of the EVM after the most recent contract function call. Variables of storage type can also be compared for equality, allowing simple rules that check the equivalence of different functions. See storage-comparison for details. ## Uninterpreted sorts {todo} This section is incomplete."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "types", "id": "246afcfcf552-7", "chunk-uid": "246afcfcf552", "chunk-page-index": 7, "text": "See the old documentation. ## Conversions between CVL and Solidity types When a specification calls a contract function, the Prover must convert the arguments from their CVL types to the corresponding Solidity types, and must convert the return values from Solidity back to CVL. The Prover must also apply these conversions when inlining hooks and function summaries. There are restrictions on what types can be converted from CVL to Solidity and vice-versa. In general, if a contract uses a type that is not convertible, you can still interact with it, but you cannot access the corresponding values. For example, if a contract function returns a type that isn't convertible to CVL, you can call the function from CVL but you cannot access its return type. Similarly, if the function accepts an argument of a type that is not representable in CVL, you can still call the function from CVL, but only by providing it a generic calldataarg argument. The following restrictions apply when converting between CVL types and Solidity types: - The type must be a valid CVL type (except for contract or interface types, which are represented by address). - Reference types (arrays and structs) can only be passed to Solidity functions that expect calldata or memory arguments; there is no way to pass storage arrays. - Arrays returned from Solidity can only be converted to CVL if their elements have value types that are representable in CVL. There are additional restrictions on the types for arguments and return values for internal function summaries; see function-summary."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-0", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 0, "text": "## (invariants)= Invariants Invariants describe a property of the state of a contract that is always expected to hold. {caution} Certain features of invariants are {term}unsound: the invariant can be verified by the Prover, but it may still be possible for the contract to violate it. The possible sources of unsoundness are {ref}preserved, {ref}invariant-filters, and {ref}invariant-revert. Invariant proofs are also unsound if some of the methods are filtered out using the {ref}--method or {ref}--parametric_contracts flags."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-1", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 1, "text": "See the linked sections for details. {contents} Syntax The syntax for invariants is given by the following EBNF grammar: invariant ::= \"invariant\" id [ \"(\" params \")\" ] expression [ \"filtered\" \"{\" id \"->\" expression \"}\" ] [ \"{\" { preserved_block } \"}\" preservedblock ::= \"preserved\" [ mepodsignature ] [ \"wip\" \"(\" params \")\" ] block mepodsignature ::= [ contractname \".\" ] id \"(\" [ evmtype [ id ] { \",\" evmtype [ id ] } ] \")\" | \"fallback\" \"(\" \")\" contractname ::= id | \"\" See {doc}basics for the id production, {doc}expr for the expression production, and {doc}statements for the block production. Overview In CVL, an invariant is a property of the contract state that is expected to be true whenever a contract method is not currently executing. This kind of invariant is sometimes called a \"representation invariant\". Each invariant has a name, possibly followed by a set of parameters, followed by a boolean expression. We say the invariant holds if the expression evaluates to true in every reachable state of the contract, and for all possible values of the parameters. While verifying an invariant, the Prover checks two things. First, it checks that the invariant is established after calling any constructor. Second, it checks that the invariant holds after the execution of any contract method, assuming that it held before the method was executed (if it does hold, we say the method preserves the invariant). If an invariant is proven, it is safe to assume that it holds in other rules and invariants. The {ref}requireInvariant command &lt;requireInvariant&gt; makes it easy to add this assumption to another rule, and is a quick way to rule out counterexamples that start in impossible states. See also {doc}/docs/user-guide/patterns/safe-assum."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-2", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 2, "text": "{note} Invariants are intended to describe the state of a contract at a particular point in time. Therefore, you should only use view functions inside of an invariant. Non-view functions are allowed, but the behavior is undefined. ## (invariant-revert)= Invariants that revert --- There is well-known unsoundness in the Prover's handling of invariants that occurs if an invariant expression reverts in the \"before\" state but not in the \"after\" state. In this case, the assumption that the invariant holds before calling the contract method will revert, causing any counterexample to be discarded. For example, consider the following contract: contract Example { private uint[] a; public function add(uint i) external { a.push(i); } public function get(uint i) external returns(uint) { return a[i]; } } This contract simply wraps an array of integers and allows you to add integers to the array. The following invariant states that all elements of the array are 0: invariant all_elements_are_zero(uint i) get(i) == 0; This property is clearly false; you can invalidate it by calling add(2). Nevertheless, the invariant will pass."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-3", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 3, "text": "The reason is that before a call to add pushes a nonzero integer into a[i], the length of a was i-1, so the call to get(i) will revert. Therefore, the Prover would discard the counterexample instead of reporting it. As above, an invariant stating that supply() == token.totalSupply() would be verified, but a method on token might change the total supply without updating the SupplyTracker contract. Since the Prover only checks the main contract's methods for preservation, it will not report that the invariant can be falsified. For this reason, invariants that depend on the environment or on the state of external contracts are a potential source of unsoundness, and should be used with care. There is an additional source of unsoundness that occurs if the invariant expression reverts in the before state but not in the after state. Preserved blocks Often, the proof that an invariant is preserved depends on another invariant, or on an external assumption about the system. These assumptions can be written in preserved blocks. Caution: Adding require statements to preserved blocks can be a source of unsoundness, since the invariants are only guaranteed to hold if the requirements are true for every method invocation. Recall that the Prover checks that a method preserves an invariant by first requiring the invariant (the prestate check), then executing the method, and then asserting the invariant (the poststate check). Preserved blocks are executed after the prestate check but before executing the method. They usually consist of require or requireInvariant statements, although other commands are also possible. Preserved blocks are listed after the invariant expression (and after the filter block, if any), inside a set of curly braces ({ ... }). Each preserved block consists of the keyword preserved followed by an optional method signature, an optional with declaration, and finally the block of commands to execute. Contract and method-specific preserved blocks The method signature of the preserved block may optionally contain a contract name followed by a . character followed by a contract method name. --- ## In the case where the preserved block does not have a contract name but does have a method name (not the fallback case), the preserved block will apply only to methods that match in the main contract. For example, here the preserved block will apply only to the method withdrawExcess(address) that appears in the main contract: cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved withdrawExcess(address token) { require token != asset; } } ## If the method signature includes a specific contract name, then the Prover only applies the preserved block to the methods in the named contract. For example, here the preserved block only applies to the asset contract method transfer(address,uint). The preserved block does not apply to the transfer(address,uint) method in any other contract. cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved asset.transfer(address x, uint y) with (env e) { require e.msg.sender != currentContract } } ## If the contract name is the wildcard character _, the Prover applies the preserved block to instances of the method in all contracts in the scene. For example, this preserve block applies to all contracts containing a method matching the transfer(address,uint) method signature. cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved _.transfer(address x, uint y) with (env e) { require e.msg.sender != currentContract } } ## If an invariant has multiple preserved blocks with the same method signature where one signature is more specific and the other is more general (as in the _.method case), then the more specific preserved block will apply. ## If a preserved block specifies a method signature, the signature must either be fallback() or match one of the contract methods, and the preserved block only applies when checking preservation of that contract method."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-4", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 4, "text": "The fallback() preserved block applies only to the fallback() function that should be defined in the contract. The arguments of the method are in scope within the preserved block. ## Generic preserved blocks If there is no method signature, the preserved block is a default block that is used for all methods that don't have a specific preserved block, including the fallback() method. If an invariant has both a default preserved block and a specific preserved block for a method, the specific preserved block is used; the default preserved block will not be executed. ## Binding the environment The with declaration is used to give a name to the {term}environment used while invoking the method. It can be used to restrict the transactions that are considered. For example, the following preserved block rules out counterexamples where the msg.sender is the 0 address: cvl invariant zero_address_has_no_balance() balanceOf(0) == 0 { preserved with (env e) { require e.msg.sender != 0; } } The variables defined as parameters to the invariant are also available in preserved blocks, which allows restricting the arguments that are considered when checking that a method preserves an invariant. As always, you should use caution when adding additional require statements, as they can rule out important cases. ```{caution} A common source of confusion is the difference between env parameters to an invariant and the env variables defined by the with declaration. Compare the following to the previous example: cvl invariant zero_address_has_no_balance_v2(env e) balanceOf(e, 0) == 0 { preserved { require e.msg.sender != 0; } } In this example, we require the msg.sender argument to balanceOf to be nonzero, but makes no restrictions on the environment for the call to the method we are checking for preservation. To see why this is not the desired behavior, consider a deposit method that increases the message sender's balance. When the zero_address_has_no_balance_v2 invariant is checked on deposit, the Prover will effectively check the following (see {ref}invariant-as-rule): --- ## Filters For performance reasons, you may want to avoid checking that an invariant is preserved by a particular method or set of methods. Invariant filters provide a method for skipping verification on a method-by-method basis."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-5", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 5, "text": "Caution: Filtering out methods while checking invariants is unsound. If you are filtering out a method because the invariant doesn't pass, consider using a preserved block instead; this allows you to add assumptions in a fine-grained way (although preserved blocks can also be unsound). To filter out methods from an invariant, add a filtered block after the expression defining the invariant. The body of the filtered block must contain a single filter of the form var -&gt; expr, where var is a variable name, and expr is a boolean expression that may depend on var. Before verifying that a method preserves an invariant, the expr is evaluated with var bound to a method object. This allows expr to refer to the checked method using var's fields, such as var.selector, var.contract, and var.isView. See method-type for a list of the fields available on method objects. If the expression evaluates to false with var replaced by a given method, the Prover will not check that the method preserves the invariant. For example, the following invariant will not be checked on the deposit(uint) method: invariant balance_is_0(address a) balanceOf(a) == 0 filtered { f -&gt; f.selector != sig:deposit(uint).selector } In this example, when the variable f is bound to deposit(uint), the expression f.selector != sig:deposit(uint).selector evaluates to false, so the method will be skipped. Note: If there is a preserved block for a method, the method will be verified even if the filter would normally exclude it. ## Writing an invariant as a rule Above we explained that verifying an invariant requires two checks: an initial-state check that the constructor establishes the invariant, and a preservation check that each method preserves the invariant. Invariants are the only mechanism in CVL for specifying properties of constructors, but parametric rules can be used to write the preservation check in a different way. This is useful for two reasons: First, it can help you understand what the preservation check is doing. Second, it can help break down a complicated invariant by defining new intermediate variables. --- ## The following example demonstrates all of the features of invariants: cvl invariant complex_example(env e1, uint arg) property_of(e1, arg) filtered { m -&gt; m.selector != sig:ignored(uint, address).selector } { preserved with (env e2) { require e2.msg.sender != 0; } preserved special_method(address a) with (env e3) { require a != 0; require e3.block.timestamp &gt; 0; } } The preservation check for this invariant could be written as a {term}parametric rule as follows: cvl rule complexexampleasrule(env e1, uint arg, mepod f) filtered { f -&gt; f.selector != sig:ignored(uint, address).selector } // pre-state check require propertyof(e1, arg); if (f.selector == sig:special_mepod(address).selector) { // special_mepod preserved block address a; env e3; require a != 0; require e3.block.timestamp &gt; 0; // mepod execution special_mepod(e3, a); } else { // general preserved block calldataarg args; env e2; require e2.msg.sender != 0; // mepod execution f(e2, args); // post-state check assert property_of(e1, arg); ## Invariants and induction This section describes the logical justification for invariant checks. You do not need to understand this section to use the Prover correctly, but it helps explain the connection between the invariant checks and mathematical proofs for those who are familiar with writing proofs. This section also justifies the safety of arbitrary requireInvariant statements in preserved blocks. This section assumes familiarity with basic proofs by induction. We use the symbols {math}∀, {math}⇒, and {math}∧ to stand for \"for all\", \"implies\", and \"and\" respectively. Consider an invariant i(x) that is verified by the Prover. For the moment, let's assume that i(x) has no preserved blocks. We will prove that for all reachable states of the contract, i(x) is true. A state s is reachable if we can start with an newly created state (that is, where all storage variables are 0), apply any constructor, and then call any number of contract methods to produce s. Let {math}P_i(x,n) be the statement \"if we start from the newly created state, apply any constructor, and then call {math}n contract methods, then the resulting state satisfies i(x).\" Our goal is then to prove {math}∀ n, ∀ x, P_i(x,n). We will prove this by induction on {math}n. --- In the base case we want to show that for any \\(x\\), if we apply any constructor to the newly created contract, that the resulting state satisfies \\(i(x)\\). This is exactly what the Prover verifies in the initial state check. In other words, the initial state check proves that \\(\\forall x, P_i(x,0)\\). For the inductive step, we assume that any \\(n\\) contract calls produce a state that satisfies \\(i(x)\\), and we want to show that a state produced after \\(n+1\\) calls also satisfies \\(i(x)\\). This is exactly what the Prover verifies in the preservation check: that if the state before the last method call satisfies \\(i(x)\\) then after the last method call it still satisfies \\(i(x)\\). In other words, the preservation check proves that \\(\\forall n, \\forall x, P_i(x,n) \\Rightarrow P_i(x, n+1)\\). This completes the proof that together, the initial state check and the preservation check ensure that the invariant \\(i\\) holds on all reachable states. Now, let us consider preserved blocks. Adding require statements to a preserved block for invariant \\(i\\) adds an additional assumption \\(Q\\) to the preservation check. Now, instead of \\(\\forall n, \\forall x, P_i(x,n) \\Rightarrow P_i(x, n+1),\\) the preservation check only proves \\(\\forall n, \\forall x, P_i(x,n) \\textbf{ \\land } Q \\Rightarrow P_i(x, n+1).\\) The addition of the assumption \\(Q\\) invalidates the above proof if we don't have reason to believe that \\(Q\\) actually holds, which is why we caution against adding require statements to preserved blocks. However, it is important to note that adding requireInvariant \\(j(y)\\) to a preserved block is safe (assuming that \\(j\\) is verified), even if the preserved block for \\(j\\) requires the invariant \\(i\\). To demonstrate this, we consider three examples. For the first example, consider the spec cvl invariant i(uint x) ... { preserved { requireInvariant i(x); } } Although this may seem like circular logic (we require \\(i\\) in the proof of \\(i\\)), it is not. The verification of the preservation check for \\(i\\) proves the statement \\(\\forall n, \\forall x, P_i(x, n) \\land P_i(x, n) \\Rightarrow P_i(x, n+1)\\), which is logically equivalent to the preservation check without the preserved block (since \\(P_i(x,n) \\land P_i(x,n)\\) is equivalent to just \\(P_i(x,n))\\). For the second example, consider the following spec: cvl invariant i(uint x) ... { preserved { requireInvariant j(x); } } invariant j(uint x) ... { preserved { requireInvariant i(x); } } Verifying these invariants gives us the preservation check for \\(i\\): \\(\\forall n, \\forall x, P_i(x, n) \\land P_j(x, n) \\Rightarrow P_i(x, n + 1)\\) and for \\(j\\): \\(\\forall n, \\forall x, P_j(x, n) \\land P_i(x, n) \\Rightarrow P_j(x, n + 1)\\) Putting these together allows us to conclude \\(\\forall n, \\forall x, P_i(x,n) \\land P_j(x,n) \\Rightarrow P_i(x,n+1) \\land P_j(x,n+1)\\) which is exactly what we need for an inductive proof of the statement \\(\\forall n, \\forall x, P_i(x,n) \\land P_j(x,n)\\). This statement then shows that both \\(i(x)\\) and \\(j(x)\\) are true in all reachable states. For the third example, consider the following spec: cvl invariant i(uint x) ... { preserved { requireInvariant i(f(x)); } } The preservation check now proves \\(\\forall n, \\forall x, P_i(x,n) \\land P_i(f(x), n) \\Rightarrow P_i(x, n+1)\\). Seeing that this gives us enough to write an inductive proof that \\(\\forall n, \\forall x, P_i(x,n) takes a little more effort, but it only requires a simple trick. Let \\(Q(n)\\) be the statement \\(\\forall x, P_i(x,n)\\). We prove \\(\\forall n, Q(n) by induction. --- The base case comes directly from the initial state check for i. For the inductive step, choose an arbitrary \\(n\\) and assume \\(Q(n)\\). We want to show \\(Q(n+1)\\), i.e. that \\(\\forall x, P_i(x, n+1)\\). Fix an arbitrary \\(x\\). We can apply \\(Q(n)\\) to \\(x\\) to conclude \\(P_i(x,n)\\). We can also apply \\(Q(n)\\) to \\(f(x)\\) to conclude \\(P_i(f(x), n)\\). These facts together with the preservation check show \\(P_i(x, n+1)\\). Since \\(x\\) was arbitrary, we can conclude \\(\\forall x, P(x, n+1)\\), which is \\(Q(n+1)\\). This completes the inductive step, and thus the proof. The techniques used in these three examples can be used to demonstrate that it is always logically sound to add a requireInvariant to a preserved block, even for complicated interdependent invariants (as long as the required invariants have been verified). Invariants Invariants describe a property of pe state of a contract pat is always expected to hold. Caution: Certain features of invariants are unsound: the invariant can be verified by the Prover, but it may still be possible for the contract to violate it. The possible sources of unsoundness are preserved, invariant-filters, and invariant-revert. Invariant proofs are also unsound if some of the methods are filtered out using the --method or parametric_contracts flags."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-6", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 6, "text": "See the linked sections for details. Syntax The syntax for invariants is given by the following EBNF grammar: invariant ::= \"invariant\" id [ \"(\" params \")\" ] expression [ \"filtered\" \"{\" id \"->\" expression \"}\" ] [ \"{\" { preserved_block } \"}\" ] preservedblock ::= \"preserved\" [ methodsignature ] [ \"with\" \"(\" params \")\" ] block methodsignature ::= [ contractname \".\" ] id \"(\" [ evmtype [ id ] { \",\" evmtype [ id ] } ] \")\" | \"fallback\" \"(\" \")\" contractname ::= id | \"\" See basics for the id production, expr for the expression production, and statements for the block production. Overview In CVL, an invariant is a property of the contract state that is expected to be true whenever a contract method is not currently executing. This kind of invariant is sometimes called a \"representation invariant\". Each invariant has a name, possibly followed by a set of parameters, followed by a boolean expression. We say the invariant holds if the expression evaluates to true in every reachable state of the contract, and for all possible values of the parameters. While verifying an invariant, the Prover checks two things. First, it checks that the invariant is established after calling any constructor. Second, it checks that the invariant holds after the execution of any contract method, assuming that it held before the method was executed (if it does hold, we say the method preserves the invariant). If an invariant is proven, it is safe to assume that it holds in other rules and invariants. The requireInvariant command &lt;requireInvariant&gt; makes it easy to add this assumption to another rule, and is a quick way to rule out counterexamples that start in impossible states. See also /docs/user-guide/patterns/safe-assum."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-7", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 7, "text": "--- {note} Invariants are intended to describe the state of a contract at a particular point in time. Therefore, you should only use view functions inside of an invariant. Non-view functions are allowed, but the behavior is undefined. (invariant-revert)= Invariants that revert There is well-known unsoundness in the Prover's handling of invariants that occurs if an invariant expression reverts in the \"before\" state but not in the \"after\" state. In this case, the assumption that the invariant holds before calling the contract method will revert, causing any counterexample to be discarded. For example, consider the following contract: cvl contract Example { private uint[] a; public function add(uint i) external { a.push(i); public function get(uint i) external returns(uint) { return a[i]; } } This contract simply wraps an array of integers and allows you to add integers to the array. The following invariant states that all elements of the array are 0: cvl invariant all_elements_are_zero(uint i) get(i) == 0; This property is clearly false; you can invalidate it by calling add(2). Nevertheless, the invariant will pass."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-8", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 8, "text": "The reason is that before a call to add pushes a nonzero integer into a[i], the length of a was i-1, so the call to get(i) will revert. Therefore, the Prover would discard the counterexample instead of reporting it. As above, an invariant stating that supply() == token.totalSupply() would be verified, but a method on token might change the total supply without updating the SupplyTracker contract. Since the Prover only checks the main contract's methods for preservation, it will not report that the invariant can be falsified."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-9", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 9, "text": "For this reason, invariants that depend on the environment or on the state of external contracts are a potential source of {term}unsoundness <unsound>, and should be used with care. (preserved)= Preserved blocks Often, the proof that an invariant is preserved depends on another invariant, or on an external assumption about the system. These assumptions can be written in preserved blocks. {caution} Adding `require` statements to preserved blocks can be a source of {term}`unsoundness <unsound>`, since the invariants are only guaranteed to hold if the requirements are true for every method invocation. Recall that the Prover checks that a method preserves an invariant by first requiring the invariant (the prestate check), then executing the method, and then asserting the invariant (the poststate check). Preserved blocks are executed after the prestate check but before executing the method. They usually consist of require or requireInvariant statements, although other commands are also possible. --- ## Preserved blocks Preserved blocks are listed after the invariant expression (and after the filter block, if any), inside a set of curly braces ({...}). Each preserved block consists of the keyword preserved followed by an optional method signature, an optional with declaration, and finally the block of commands to execute. ### Contract and method-specific preserved blocks The method signature of the preserved block may optionally contain a contract name followed by a . character followed by a contract method name. In the case where the preserved block does not have a contract name but does have a method name (not the fallback case), the preserved block will apply only to methods that match in the main contract. For example, here the preserved block will apply only to the method withdrawExcess(address) that appears in the main contract: cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved wipdrawExcess(address token) { require token != asset; } } If the method signature includes a specific contract name, then the Prover only applies the preserved block to the methods in the named contract. For example, here the preserved block only applies to the asset contract method transfer(address,uint). The preserved block does not apply to the transfer(address,uint) method in any other contract. cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved asset.transfer(address x, uint y) wip (env e) { require e.msg.sender != currentContract } } If the contract name is the wildcard character _, the Prover applies the preserved block to instances of the method in all contracts in the scene. For example, this preserve block applies to all contracts containing a method matching the transfer(address,uint) method signature. cvl invariant solvencyAsInv() asset.balanceOf() >= internalAccounting() { preserved _.transfer(address x, uint y) wip (env e) { require e.msg.sender != currentContract } } If an invariant has multiple preserved blocks with the same method signature where one signature is more specific and the other is more general (as in the _.method case), then the more specific preserved block will apply. If a preserved block specifies a method signature, the signature must either be fallback() or match one of the contract methods, and the preserved block only applies when checking preservation of that contract method."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-10", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 10, "text": "The fallback() preserved block applies only to the fallback() function that should be defined in the contract. The arguments of the method are in scope within the preserved block. ### Generic preserved blocks If there is no method signature, the preserved block is a default block that is used for all methods that don't have a specific preserved block, including the fallback() method. If an invariant has both a default preserved block and a specific preserved block for a method, the specific preserved block is used; the default preserved block will not be executed. ### Binding the environment The with declaration is used to give a name to the {term}environment used while invoking the method. It can be used to restrict the transactions that are considered. For example, the following preserved block rules out counterexamples where the msg.sender is the 0 address: cvl invariant zero_address_has_no_balance() balanceOf(0) == 0 { preserved wip (env e) { require e.msg.sender != 0; } } The variables defined as parameters to the invariant are also available in preserved blocks, which allows restricting the arguments that are considered when checking that a method preserves an invariant. As always, you should use caution when adding additional require statements, as they can rule out important cases. Caution: A common source of confusion is the difference between env parameters to an invariant and the env variables defined by the with declaration. Compare the following to the previous example: --- ## cvl invariant zero_address_has_no_balance_v2(env e) balanceOf(e, 0) == 0 { preserved { require e.msg.sender != 0; } } In this example, we require the msg.sender argument to balanceOf to be nonzero, but makes no restrictions on the environment for the call to the method we are checking for preservation. To see why this is not the desired behavior, consider a deposit method that increases the message sender's balance. When the zero_address_has_no_balance_v2 invariant is checked on deposit, the Prover will effectively check the following (see invariant-as-rule): cvl env e; require balanceOf(e,0) == 0; env calledEnv; require e.msg.sender != 0; // from the preserved block deposit(calledEnv, ...); assert balanceOf(e,0) == 0; Notice that the calledEnv is not restricted by the preserved block. The Prover will report a violation with the msg.sender set to 0 in the call to deposit and set to a nonzero value in the calls to balanceOf. This counterexample is not ruled out by the preserved block because the preserved block only places restrictions on the environment passed to balanceOf."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-11", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 11, "text": "In general, you should be cautious of invariants that depend on an environment."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-12", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 12, "text": "## Filters For performance reasons, you may want to avoid checking that an invariant is preserved by a particular method or set of methods. Invariant filters provide a method for skipping verification on a method-by-method basis. Filtering out methods while checking invariants is unsound. If you are filtering out a method because the invariant doesn't pass, consider using a preserved block instead; this allows you to add assumptions in a fine-grained way (although preserved blocks can also be unsound). To filter out methods from an invariant, add a filtered block after the expression defining the invariant. The body of the filtered block must contain a single filter of the form var -&gt; expr, where var is a variable name, and expr is a boolean expression that may depend on var. Before verifying that a method preserves an invariant, the expr is evaluated with var bound to a method object. This allows expr to refer to the checked method using var's fields, such as var.selector, var.contract, and var.isView. See method-type for a list of the fields available on method objects. If the expression evaluates to false with var replaced by a given method, the Prover will not check that the method preserves the invariant. For example, the following invariant will not be checked on the deposit(uint) method: cvl invariant balance_is_0(address a) balanceOf(a) == 0 filtered { f -&gt; f.selector != sig:deposit(uint).selector } In this example, when the variable f is bound to deposit(uint), the expression f.selector != sig:deposit(uint).selector evaluates to false, so the method will be skipped. If there is a preserved block for a method, the method will be verified even if the filter would normally exclude it. --- ## Writing an invariant as a rule Above we explained that verifying an invariant requires two checks: an initial-state check that the constructor establishes the invariant, and a preservation check that each method preserves the invariant. Invariants are the only mechanism in CVL for specifying properties of constructors, but parametric rules can be used to write the preservation check in a different way. This is useful for two reasons: First, it can help you understand what the preservation check is doing. Second, it can help break down a complicated invariant by defining new intermediate variables. The following example demonstrates all of the features of invariants: cvl invariant complex_example(env e1, uint arg) property_of(e1, arg) filtered { m -&gt; m.selector != sig:ignored(uint, address).selector } preserved wip (env e2) { require e2.msg.sender != 0; } preserved special_mepod(address a) wip (env e3) { require a != 0; require e3.block.timestamp &gt; 0; } The preservation check for this invariant could be written as a parametric rule as follows: cvl rule complexexampleasrule(env e1, uint arg, method f) filtered { f -&gt; f.selector != sig:ignored(uint, address).selector } { // pre-state check require propertyof(e1, arg); if (f.selector == sig:special_method(address).selector) { // special_method preserved block address a; env e3; require a != 0; require e3.block.timestamp &gt; 0; // method execution special_method(e3, a); } else { // general preserved block calldataarg args; env e2; require e2.msg.sender != 0; // method execution } f(e2, args); // post-state check assert property_of(e1, arg); } ## Invariants and induction This section describes the logical justification for invariant checks. You do not need to understand this section to use the Prover correctly, but it helps explain the connection between the invariant checks and mathematical proofs for those who are familiar with writing proofs. This section also justifies the safety of arbitrary requireInvariant statements in preserved blocks. This section assumes familiarity with basic proofs by induction. We use the symbols ∀, ⇒, and ∧ to stand for \"for all\", \"implies\", and \"and\" respectively. --- Consider an invariant i(x) that is verified by the Prover."}, {"source": "https://docs.certora.com/en/latest/", "source-type": "documentation", "title": "invariants", "id": "6267a6b73fa0-13", "chunk-uid": "6267a6b73fa0", "chunk-page-index": 13, "text": "For the moment, let's assume that i(x) has no preserved blocks. We will prove that for all reachable states of the contract, i(x) is true. A state s is reachable if we can start with a newly created state (that is, where all storage variables are 0), apply any constructor, and then call any number of contract methods to produce s. Let \\(P_i(x,n)\\) be the statement \"if we start from the newly created state, apply any constructor, and then call \\(n\\) contract methods, then the resulting state satisfies i(x).\" Our goal is then to prove \\(\\forall n, \\forall x, P_i(x,n)\\). We will prove this by induction on \\(n\\). In the base case we want to show that for any \\(x\\), if we apply any constructor to the newly created contract, that the resulting state satisfies i(x). This is exactly what the Prover verifies in the initial state check. In other words, the initial state check proves that \\(\\forall x, P_i(x,0)\\). For the inductive step, we assume that any \\(n\\) contract calls produce a state that satisfies i(x), and we want to show that a state produced after \\(n+1\\) calls also satisfies i(x). This is exactly what the Prover verifies in the preservation check: that if the state before the last method call satisfies i(x) then after the last method call it still satisfies i(x). In other words, the preservation check proves that \\(\\forall n, \\forall x, P_i(x,n) \\Rightarrow P_i(x, n+1)\\). This completes the proof that together, the initial state check and the preservation check ensure that the invariant i holds on all reachable states. Now, let us consider preserved blocks. Adding require statements to a preserved block for invariant i adds an additional assumption Q to the preservation check. Now, instead of \\(\\forall n, \\forall x, P_i(x,n) \\Rightarrow P_i(x, n+1)\\), the preservation check only proves \\(\\forall n, \\forall x, P_i(x,n) \\textbf{ ∧ Q} \\Rightarrow P_i(x, n+1)\\). The addition of the assumption Q invalidates the above proof if we don't have reason to believe that Q actually holds, which is why we caution against adding require statements to preserved blocks. However, it is important to note that adding requireInvariant j(y) to a preserved block is safe (assuming that j is verified), even if the preserved block for j requires the invariant i. To demonstrate this, we consider three examples. For the first example, consider the spec cvl invariant i(uint x) ... { preserved { requireInvariant i(x); } } Although this may seem like circular logic (we require i in the proof of i), it is not. The verification of the preservation check for i proves the statement \\(\\forall n, \\forall x, P_i(x, n) \\land P_i(x, n) \\Rightarrow P_i(x, n+1)\\), which is logically equivalent to the preservation check without the preserved block (since \\(P_i(x,n) \\land P_i(x,n)\\) is equivalent to just \\(P_i(x,n)\\)). For the second example, consider the following spec: cvl invariant i(uint x) ... { preserved { requireInvariant j(x); } } invariant j(uint x) ... { preserved { requireInvariant i(x); } } Verifying these invariants gives us the preservation check for i: \\(\\forall n, \\forall x, P_i(x, n) \\land P_j(x, n) \\Rightarrow P_i(x, n + 1)\\) and for j: \\(\\forall n, \\forall x, P_j(x, n) \\land P_i(x, n) \\Rightarrow P_j(x, n + 1\\) Putting these together allows us to conclude \\(\\forall n, \\forall x, P_i(x,n) \\land P_j(x,n) \\Rightarrow P_i(x,n+1) \\land P_j(x,n+1)\\) which is exactly what we need for an inductive proof of the statement \\(\\forall n, \\forall x, P_i(x,n) \\land P_j(x,n)\\). This statement then shows that both i(x) and j(x) are true in all reachable states. --- For the third example, consider the following spec: cvl invariant i(uint x) ... { preserved { requireInvariant i(f(x)); } } The preservation check now proves ∀ n, ∀ x, P_i(x,n) ∧ P_i(f(x), n) ⇒ P_i(x, n+1). Seeing that this gives us enough to write an inductive proof that ∀ n, ∀ x, P_i(x,n) takes a little more effort, but it only requires a simple trick. Let Q(n) be the statement ∀ x, P_i(x,n). We prove ∀ n, Q(n) by induction. The base case comes directly from the initial state check for i. For the inductive step, choose an arbitrary n and assume Q(n). We want to show Q(n+1), i.e. that ∀ x, P_i(x, n+1). Fix an arbitrary x. We can apply Q(n) to x to conclude P_i(x,n). We can also apply Q(n) to f(x) to conclude P_i(f(x), n). These facts together with the preservation check show P_i(x, n+1). Since x was arbitrary, we can conclude ∀ x, P(x, n+1), which is Q(n+1). This completes the inductive step, and thus the proof. The techniques used in these three examples can be used to demonstrate that it is always logically sound to add a requireInvariant to a preserved block, even for complicated interdependent invariants (as long as the required invariants have been verified)."}]