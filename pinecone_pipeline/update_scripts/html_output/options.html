<h1>CLI Options</h1>
<p>The <code>certoraRun</code> utility invokes the Solidity compiler and afterwards sends the job to Certora's servers. </p>
<p>The most commonly used command is:</p>
<p><code>bash
certoraRun contractFile:contractName --verify contractName:specFile
</code></p>
<p>If <code>contractFile</code> is named <code>contractName.sol</code>, the run command can be simplified to
<code>bash
certoraRun contractFile --verify contractName:specFile
</code></p>
<p>A short summary of these options can be seen by invoking <code>certoraRun --help</code></p>
<h2>Using Configuration (Conf) Files</h2>
<p>For larger projects, the command line for running the Certora Prover can become large
and cumbersome. It is therefore recommended to use configuration files instead.
These are <a href="https://json5.org/">JSON5</a> files (with <code>.conf</code> extension) that hold the parameters and options for the Prover.
See {ref}<code>conf-files</code> for more information.</p>
<p><code>{contents} Overview
</code></p>
<h2>Modes of operation</h2>
<p>The Certora Prover has three modes of operation. The modes are mutually exclusive - you cannot run the tool with more than one mode at a time.</p>
<p>(--verify)=</p>
<h3><a id="verify"></a><code>--verify</code></h3>
<p><strong>What does it do?</strong>
It runs formal verification of properties specified in a .spec file on a given contract. Each contract must have been declared in the input files or have the same name as the source code file it is in.</p>
<p><strong>When to use it?</strong>
When you wish to prove properties on the source code. This is by far the most common mode of the tool.</p>
<p><strong>Example</strong>
If we have a Solidity file <code>Bank.sol</code>, with a contract named <code>Bank</code> inside it, and a specification file called <code>Bank.spec</code>, the run command would be:
<code>certoraRun Bank.sol --verify Bank:Bank.spec</code></p>
<h2>Most frequently used options</h2>
<h3><a id="msg"></a><code>--msg &lt;description&gt;</code></h3>
<p><strong>What does it do?</strong>
Adds a message description to your run, similar to a commit message. This message will appear in the title of the completion email sent to you. Note that you need to wrap your message in quotes if it contains spaces.</p>
<p><strong>When to use it?</strong>
Adding a message makes it easier to track several runs. It is very useful if you are running many verifications simultaneously. It is also helpful to keep track of a single file verification status over time, so we recommend always providing an informative message.</p>
<p><strong>Example</strong>
To create the message above, we used
<code>certoraRun Bank.sol --verify Bank:Bank.spec --msg 'Removed an assertion'</code></p>
<p>(--rule)=</p>
<h3><a id="rule"></a><code>--rule &lt;rule_name_pattern&gt; ...</code></h3>
<p><strong>What does it do?</strong>
Formally verifies one or more given properties instead of the whole specification file. An invariant can also be selected.</p>
<p><strong>When to use it?</strong>
This option saves a lot of run time. Use it whenever you care about only a
specific subset of a specification's properties. The most common case is when
you add a new rule to an existing specification. The other is when code changes
cause a specific rule to fail; in the process of fixing the code, updating the
rule, and understanding counterexamples, you likely want to verify only that
specific rule.</p>
<p>One can either specify a specific rule name, or use pattern matching with a <code>*</code>.</p>
<p>Note that you can specify this flag multiple times to filter in several rules or rule patterns.
<strong>Example</strong>
If <code>Bank.spec</code> includes the following properties:</p>
<p><code>invariant address_zero_cannot_become_an_account()</code>
<code>rule withdraw_succeeds()</code>
<code>rule withdraw_fails()</code></p>
<p>If we want to verify only <code>withdraw_succeeds</code>, we run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds</code></p>
<p>If we want to verify both <code>withdraw_succeeds</code> and <code>withdraw_fails</code>, we run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds withdraw_fails</code></p>
<p>Alternatively, to verify both <code>withdraw_succeeds</code> and <code>withdraw_fails</code>, we could
simply run <code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw*</code></p>
<p>(--exclude_rule)=</p>
<h3><a id="exclude_rule"></a> <code>--exclude_rule &lt;rule_name_pattern&gt;</code></h3>
<p><strong>What does it do?</strong>
It is the opposite flag to {ref}<code>--rule</code> - use it to specify a list of rules that
should <em>not</em> be run.</p>
<p>Note that you can specify this flag multiple times to filter out several rules or rule patterns.</p>
<p><strong>Example</strong>
If <code>Bank.spec</code> includes the following properties:</p>
<p><code>invariant address_zero_cannot_become_an_account()</code>
<code>rule withdraw_succeeds()</code>
<code>rule withdraw_fails()</code></p>
<p>If we want to skip both rules we could run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --exclude_rule withdraw*</code></p>
<p><code>{note}
When used together with the {ref}`--rule` flag the logic is to collect all rules
that pass the `--rule` flag(s) and then subtract from them all rules that match
any `--exclude_rule` flags.
</code></p>
<p>(--method)=</p>
<h3><a id="method"></a><code>--method &lt;method_signature&gt;</code></h3>
<p><strong>What does it do?</strong>
Only uses functions with the given method signature when instantiating
{term}<code>parametric rule</code>s and {term}<code>invariant</code>s.  The method signature consists
of the name of a method and the types of its arguments.</p>
<p>You may provide multiple method signatures, in which case the Prover will run on
each of the listed methods.</p>
<p><strong>When to use it?</strong>
This option is useful when focusing on a specific counterexample; running on a
specific contract method saves time.</p>
<p><strong>Example</strong>
Suppose we are verifying an ERC20 contract, and we have the following
{term}<code>parametric rule</code>:</p>
<p>```cvl
rule r {
    method f; env e; calldataarg args;
    address owner; address spender;</p>
<pre><code>mathint allowance_before = allowance(owner, spender);
f(e,args);
mathint allowance_after  = allowance(owner, spender);

assert allowance_after &gt; allowance_before =&gt; e.msg.sender == owner;
</code></pre>
<p>}
```</p>
<p>If we discover a counterexample in the method <code>deposit(uint)</code>, and wish to change
the contract or the spec to rerun, we can just rerun on the <code>deposit</code> method:</p>
<p><code>sh
certoraRun --method 'deposit(uint)'
</code></p>
<p>Note that many shells will interpret the <code>(</code> and <code>)</code> characters specially, so
the method signature argument will usually need to be quoted as in the example.</p>
<p>(--parametric_contracts)=</p>
<h3><a id="parametric_contracts"></a><code>--parametric_contracts &lt;contract_name&gt; ...</code></h3>
<p><code>{versionadded} 5.0
Prior to version 5, method variables and invariants were only instantiated with
methods of {ref}`currentContract`.
</code></p>
<p><strong>What does it do?</strong>
Only uses methods on the specified contract when instantiating
{term}<code>parametric rule</code>s or {term}<code>invariant</code>s.  The contract name must be one
of the contracts included in the {term}<code>scene</code>.</p>
<p><strong>When to use it?</strong>
As with the {ref}<code>--rule</code> and {ref}<code>--method</code> options, this option is used to
avoid rerunning the entire verification</p>
<p><strong>Example</strong>
Suppose you are working on a multicontract verification and wish to debug a
counterexample in a method of the <code>Underlying</code> contract defined in the file
<code>Example.sol</code>:</p>
<p><code>sh
certoraRun Main:Example.sol Underlying:Example.sol --verify Main:Example.spec \
    --parametric_contracts Underlying
</code></p>
<p>(--wait<em>for</em>results)=</p>
<h3><a id="wait_for_results"></a><code>--wait_for_results</code></h3>
<p><strong>What does it do?</strong>
Wait for verification results after sending the verification request.
By default, the program exits after the request.
The return code will not be zero if the verification finds a violation.</p>
<p><strong>When to use it?</strong>
Use it to receive verification results in the terminal or a wrapping script.</p>
<p>In CI, the default behavior is different: the Prover waits for verification results,
and the return code will not be zero if a violation is found. 
You can force the Prover not to wait for verification results by using <code>--wait_for_results NONE</code>.
In that case, the return code will be zero if the jobs were sent successfully.</p>
<p><strong>Example</strong>
<code>sh
certoraRun Example.sol --verify Example:Example.spec --wait_for_results
</code></p>
<h2>Options affecting the type of verification run</h2>
<p>(--multi<em>assert</em>check)=</p>
<h3><a id="multi_assert_check"></a><code>--multi_assert_check</code></h3>
<p><strong>What does it do?</strong>
This mode checks each assertion statement that occurs in a rule, separately. The check is done by decomposing each rule into multiple sub-rules, each of which checks one assertion, while it assumes all preceding assertions. In addition, all assertions that originate from the Solidity code (as opposed to those from the specification), are checked together by a designated, single sub-rule.</p>
<p>As an illustrative example, consider the following rule <code>R</code> that has two assertions:</p>
<p><code>cvl
...
assert a1
...
assert a2
...
</code></p>
<p>The <code>multi_assert_check</code> mode would generate and check two sub-rules: <code>R1</code> where <code>a1</code> is proved while <code>a2</code> is removed, and <code>R2</code> where <code>a1</code> is assumed (i.e., transformed into a requirement statement), and <code>a2</code> is proved.</p>
<p><code>R</code> passes if and only if, <code>R1</code> and <code>R2</code> both pass. In particular, in case <code>R1</code> (resp. <code>R2</code>) fails, the counter-example shows a violation of <code>a1</code> (resp. <code>a2</code>).</p>
<p><code>{caution}
We suggest using this mode carefully. In general, as this mode generates and checks more rules, it may lead to worse running-time performance. Please see indications for use below.
</code></p>
<p><strong>When to use it?</strong>
When you have a rule with multiple assertions:</p>
<ol>
<li><p>As a timeout mitigation strategy: checking each assertion separately may, in some cases, perform better than checking all the assertions together and consequently solve timeouts.</p></li>
<li><p>If you wish to get multiple counter-examples in a single run of the tool, where each counter-example violates a different assertion in the rule.</p></li>
</ol>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --multi_assert_check</code></p>
<p>(--independent_satisfy)=</p>
<h3><a id="independent_satisfy"></a><code>--independent_satisfy</code></h3>
<p><strong>What does it do?</strong>
The independent satisfy mode checks each {ref}<code>satisfy statement &lt;satisfy&gt;</code> independently from all other satisfy statements that occurs in a rule.
Normally, each satisfy statement will be turned into a sub-rule (similarly to the {ref}<code>--multi_assert_check</code> mode),
but previously encountered satisfy statements will be still considered when creating a satisfying assignment.</p>
<p>As an illustrative example of the default mode, consider the following rule <code>R</code> that has two satisfy statements:</p>
<p><code>cvl
rule R {
  bool b;
  satisfy b, "R1";
  satisfy !b, "R2";
}
</code></p>
<p>The statements for "R1" and "R2" will actually create two sub-rules equivalent to:
```cvl
rule R1_default {
  bool b;
  satisfy b, "R1";
}</p>
<p>rule R2_default {
  bool b;
  // Previous satisfy statements are required in default mode.
  require b; // R1
  // Due to requiring <code>b</code>, this satisfy statement is equivalent to 'satisfy b &amp;&amp; !b, "R2";'
  satisfy !b, "R2";
}
```</p>
<p>Without turning <code>independent_satisfy</code> mode on, <code>R2</code> would have failed, as it would try to satisfy <code>b &amp;&amp; !b</code>, an unsatisfiable contradiction.
Turning on the <code>independent_satisfy</code> mode will ignore all currently unchecked satisfy statements for each sub-rule.
It would also generate and check two sub-rules, but with a slight difference: <code>R1</code> where <code>b</code> is satisfied (by <code>b=true</code>) while <code>satisfy !b</code> is removed, and <code>R2</code> where <code>satisfy b</code> is removed, and <code>!b</code> is satisfied (by <code>b=false</code>).</p>
<p>The two <code>independent_satisfy</code> generated sub-rules will be equivalent to:</p>
<p>```cvl
rule R1_independent {
  bool b;
  satisfy b, "R1";
}</p>
<p>rule R2_independent {
  bool b;
  // require b;
  satisfy !b, "R2";
}
```</p>
<p><strong>When to use it?</strong>
When you have a rule with multiple satisfy statements, and you would like to demonstrate each statement separately.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --independent_satisfy</code></p>
<p>(--rule_sanity)=</p>
<h3><a id="rule_sanity"></a><code>--rule_sanity</code></h3>
<p><strong>What does it do?</strong>
This option enables sanity checking for rules.  The <code>--rule_sanity</code> option may
be followed by one of <code>none</code>, <code>basic</code>, or <code>advanced</code>;
See {doc}<code>../checking/sanity</code> for more information about sanity checks.</p>
<p><strong>When to use it?</strong>
We suggest using this option routinely while developing rules.  It is also a
useful check if you notice rules passing surprisingly quickly or easily.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule_sanity basic</code></p>
<h3><a id="short_output"></a><code>--short_output</code></h3>
<p><strong>What does it do?</strong>
Reduces the verbosity of the tool.</p>
<p><strong>When to use it?</strong>
When we do not care much for the output. It is recommended when running the tool in continuous integration.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --short_output</code></p>
<h2>Options that control the Solidity compiler</h2>
<p>(--solc)=</p>
<h3><a id="solc"></a><code>--solc</code></h3>
<p><strong>What does it do?</strong>
Use this option to provide a path to the Solidity compiler executable file. We check in all directories in the <code>$PATH</code> environment variable for an executable with this name. If <code>--solc</code> is not used, we look for an executable called <code>solc</code>, or <code>solc.exe</code> on windows platforms.</p>
<p><strong>When to use it?</strong>
Whenever you want to use a Solidity compiler executable with a non-default name. This is usually used when you have several Solidity compiler executable versions you switch between.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc solc8.1</code></p>
<p>(--compiler<em>map)=
(--solc</em>map)=</p>
<h3><a id="compiler_map"></a><code>--compiler_map</code></h3>
<p><strong>What does it do?</strong>
Compiles every smart contract with a different compiler executable (Solidity version or Vyper). All used contracts must be listed.</p>
<p><strong>When to use it?</strong>
When different contracts have to be compiled for different Solidity versions.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol Exchange.sol Token.vy --verify Bank:Bank.spec --compiler_map Bank=solc4.25,Exchange=solc6.7,Token=vyper0.3.10</code></p>
<p>(--solc_optimize)=</p>
<h3><a id="solc_optimize"></a><code>--solc_optimize</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option as is to the solidity compiler's option <code>--optimize</code> and <code>--optimize-runs</code>.</p>
<p><strong>When to use it?</strong>
When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the
number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs)</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize 300</code></p>
<p>(--solc<em>optimize</em>map)=</p>
<h3><a id="solc_optimize_map"></a><code>--solc_optimize_map</code></h3>
<p><strong>What does it do?</strong>
Set optimize values when different files run with different number of runs
Passes the value of this option as is to the solidity compiler's option <code>--optimize</code> and <code>--optimize-runs</code>.</p>
<p><strong>When to use it?</strong>
When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the
number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs)</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize_map Bank=200,Exchange=300</code></p>
<p>(--solc<em>via</em>ir)=</p>
<h3><a id="solc_via_ir"></a><code>--solc_via_ir</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option  to the solidity compiler's option <code>--via-ir</code>.</p>
<p><strong>When to use it?</strong>
When we want to enable the IR-based code generator</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir</code></p>
<h3><a id="solc_evm_version"></a><code>--solc_evm_version</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option  to the solidity compiler's option <code>--evm-version</code>.</p>
<p><strong>When to use it?</strong>
When we want to select the Solidity compiler EVM version</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_evm_version Istanbul</code></p>
<h3><a id="solc_allow_path"></a><code>--solc_allow_path</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option as is to the solidity compiler's option <code>--allow-paths</code>.
See <a href="https://docs.soliditylang.org/en/v0.8.16/path-resolution.html#allowed-paths">--allow-path specification</a></p>
<p><strong>When to use it?</strong>
When we want to add an additional location the Solidity compiler to load sources from</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_allow_path ~/Projects/Bank</code></p>
<h3><a id="packages_path"></a><code>--packages_path</code></h3>
<p><strong>What does it do?</strong>
Gets the path to a directory including the Solidity packages.</p>
<p><strong>When to use it?</strong>
By default, we look for the packages in <code>$NODE_PATH</code>. If the packages are in any other directory, you must use <code>--packages_path</code>.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --packages_path Solidity/packages</code></p>
<p>(--packages)=</p>
<h3><a id="packages"></a><code>--packages</code></h3>
<p><strong>What does it do?</strong>
For each package, gets the path to a directory including that Solidity package.</p>
<p><strong>When to use it?</strong>
By default we look for the packages in <code>$NODE_PATH</code>. If there are packages are in several different directories, use <code>--packages</code>.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --packages ds-stop=$PWD/lib/ds-token/lib/ds-stop/src ds-note=$PWD/lib/ds-token/lib/ds-stop/lib/ds-note/src</code></p>
<h2>Options regarding source code loops</h2>
<p>(--optimistic_loop)=</p>
<h3><a id="optimistic_loop"></a><code>--optimistic_loop</code></h3>
<p><strong>What does it do?</strong>
The Certora Prover unrolls loops - if the loop should be executed three times, it will copy the code inside the loop three times. After we finish the loop's iterations, we add an assertion to verify we have actually finished running the loop. For example, in a <code>while (a &lt; b)</code> loop, after the loop's unrolling, we add <code>assert a &gt;= b</code>. We call this assertion the <em>loop unwind condition</em>.
This option changes the assertions of the loop unwind condition to requirements (in the case above <code>require a &gt;= b</code>). That means, we ignore all the cases where the loop unwind condition does not hold, instead of considering them as a failure.</p>
<p><strong>When to use it?</strong>
When you have loops in your code and are getting a counterexample labeled <code>loop unwind condition</code>. In general, you need this flag whenever the number of loop iterations varies. It is usually a necessity if using {ref}<code>--loop_iter</code>. Note that <code>--optimistic_loop</code> could cause {ref}<code>vacuous rules &lt;--rule_sanity&gt;</code>.</p>
<p><strong>Example</strong>
<code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_loop
</code></p>
<p>(--loop_iter)=</p>
<h3><a id="loop_iter"></a><code>--loop_iter</code></h3>
<p><strong>What does it do?</strong>
Sets the maximal number of loop iterations we verify for. The way the Certora Prover handles loops is by unrolling them - if the loop should be executed three times, it will copy the code inside the loop three times. This option sets the number of unrolls. Be aware that the run time grows exponentially by the number of loop iterations.</p>
<p><strong>When to use it?</strong>
The default number of loop iterations we unroll is one. However, in many cases, bugs only occur when there are several iterations. Common scenarios include iteration over list elements. Two, or in some cases three, is usually the most you will ever need to uncover bugs.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --loop_iter 2
</code></p>
<h2>Options regarding summarization</h2>
<p>(--optimistic<em>summary</em>recursion)=</p>
<h3><a id="optimistic_summary_recursion"></a><code>--optimistic_summary_recursion</code></h3>
<p><strong>What does it do?</strong>
In case there's a call to some Solidity function within a summary, we may end up
with recursive calls to this summary. For example, if in the summary of <code>foo</code> we
call the Solidity function <code>bar</code>, and <code>bar</code>'s Solidity code contains a call to
<code>foo</code>, we'll summarize <code>foo</code> again, which will lead to another call to <code>bar</code>
etc. In this case if this flag is set to <code>false</code> we may get an assertion failure
with a message along the lines of
<code>text
Recursion limit (...) for calls to ..., reached during compilation of summary ...
</code>
Such recursion can also happen with {ref}<code>dispatcher summaries &lt;dispatcher&gt;</code> —
if a contract method <code>f</code> makes an unresolved external call to a different method
<code>f</code>, and if <code>f</code> is summarized with a <code>DISPATCHER</code> summary, then the Prover will
consider paths where <code>f</code> recursively calls itself. Without <code>--optimistic_summary_recursion</code>,
the Prover may report a rule violation with the following assert message:
<code>text
When summarizing a call with dispatcher, found we already have it in the stack: ... consider removing its dispatcher summary.
</code>
The default behavior in this case is to assert that the recursion limit is not
reached (the limit is controlled by the {ref}<code>--summary_recursion_limit</code> flag).
With <code>--optimistic_summary_recursion</code>, the Prover will instead assume that the
limit is never reached.</p>
<p><strong>When to use it</strong>
Use this flag when there is recursion due to summaries calling Solidity
functions, and this causes an undesired assertion failure. In this case one can
either make the limit larger (via {ref}<code>--summary_recursion_limit</code>) or set this
flag to <code>true</code>.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_summary_recursion true
</code></p>
<p><code>{caution}
Note that this flag could be another cause for unsoundness - even if such recursion
_could_ actually happen in the deployed contract, this code-path won't be verified.
</code></p>
<p>(--summary<em>recursion</em>limit)=</p>
<h3><a id="summary_recursion_limit"></a><code>--summary_recursion_limit</code></h3>
<p><strong>What does it do?</strong>
Summaries can cause recursion (see {ref}<code>--optimistic_summary_recursion</code>). This
option sets the summary recursion level, which is the number of recursive calls
that the Prover will consider.</p>
<p>If the Prover finds an execution in which a function is called recursively more
than the contract recursion limit, the Prover will report an assertion failure (unless
{ref}<code>--optimistic_summary_recursion</code> is set, in which case the execution
will be ignored).
The default value is zero (i.e. no recursion is allowed).</p>
<p><strong>When to use it</strong>
1. Use this option when there is recursion due to summaries calling Solidity
functions, and this leads to an assertion failure. In this case one can either
make the limit larger or set (via {ref}<code>--optimistic_summary_recursion</code>) flag
to <code>true</code>.</p>
<ol start="2">
<li>Use it if you get the following assertion failure, and disabling {ref}<code>optimistic fallback &lt;-optimisticFallback&gt;</code> is not possible: <code>When inlining a fallback function, found it was already on the stack. Consider disabling optimistic fallback mode.</code></li>
</ol>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --summary_recursion_limit 3
</code></p>
<p>(--nondet<em>difficult</em>funcs)=</p>
<h3><a id="nondet_difficult_funcs"></a><code>--nondet_difficult_funcs</code></h3>
<p><strong>What does it do?</strong>
When this option is set, the Prover will auto-summarize
view or pure internal functions that return a value type and are
currently not summarized, and that are found to be heuristically difficult
for the Prover.</p>
<p>For more information, see {ref}<code>detect-candidates-for-summarization</code>.</p>
<p><strong>When to use it</strong>
Using this option is recommended when beginning to work on a large code
base that includes functions that could be difficult for the Prover.
It can help the user get faster feedback, both in the form of faster
verification results, as well as highlighting potentially difficult functions.</p>
<p><strong>Example</strong></p>
<p><code>bash
certoraRun Bank.sol --verify Bank:Bank.spec --nondet_difficult_funcs
</code></p>
<p>(--nondet<em>minimal</em>difficulty)=</p>
<h3><a id="nondet_minimal_difficulty"></a><code>--nondet_minimal_difficulty</code></h3>
<p><strong>What does it do?</strong>
This option sets the minimal difficulty threshold for the auto-summarization mode enabled by {ref}<code>--nondet_difficult_funcs</code>.</p>
<p><strong>When to use it</strong>
If the results of an initial run with {ref}<code>--nondet_difficult_funcs</code> were unsatisfactory,
one can adjust the default threshold to apply the auto-summarization to potentially more or fewer internal functions.</p>
<p>The notification in the rule report that contains the applied summaries will present the current threshold used by the Prover.</p>
<p><strong>Example</strong></p>
<p><code>bash
certoraRun Bank.sol --verify Bank:Bank.spec --nondet_difficult_funcs --nondet_minimal_difficulty 20
</code></p>
<h2>Options regarding hashing of unbounded data</h2>
<p>(--optimistic_hashing)=</p>
<h3><a id="optimistic_hashing"></a><code>--optimistic_hashing</code></h3>
<p><strong>What does it do?</strong></p>
<p>When hashing data of potentially unbounded length (including unbounded arrays, like <code>bytes</code>, <code>uint[]</code>, etc.), assume that its length is bounded by the value set through the <code>--hashing_length_bound</code> option. If this is not set, and the length can be exceeded by the input program, the Prover reports an assertion violation. I.e., when this option is set, the boundedness of the hashed data assumed checked by the Prover, when this option is set that boundedness is assumed instead.</p>
<p>See {doc}<code>../approx/hashing</code> for more details.</p>
<p><strong>When to use it?</strong></p>
<p>When the assertion regarding unbounded hashing is thrown, but it is acceptable for the Prover to ignore cases where the length hashed values exceeds the current bound.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_hashing
</code></p>
<p>(--hashing<em>length</em>bound)=</p>
<h3><a id="hashing_length_bound"></a><code>--hashing_length_bound</code></h3>
<p><strong>What does it do?</strong></p>
<p>Constraint on the maximal length of otherwise unbounded data chunks that are being hashed. This constraint is either assumed or checked by the Prover, depending on whether <code>--optimistic_hashing</code> has been set. The bound is specified as a number of bytes.</p>
<p>The default value of this option is 224 (224 bytes correspond to 7 EVM machine words as 7 * 32 == 224).</p>
<p><strong>When to use it?</strong>
Reason to lower this value:</p>
<p>Lowering potentially improves SMT performance, especially if there are many occurrences of unbounded hashing in the program.</p>
<p>Reasons to raise this value:</p>
<ul>
<li>when <code>--optimistic_hashing</code> is not set: avoid the assertion being violated when the hashed values are actually bounded, but by a bound that is higher than the default value (in case of <code>--optimistic_hashing</code> being not set)</li>
<li>when <code>--optimistic_hashing</code> is set: find bugs that rely on a hashed array being at least of that length. (Optimistic hashing excludes all cases from the scope of verification where something being hashed is longer than this bound.)</li>
</ul>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --hashing_length_bound 128
</code></p>
<h2>Options that help reduce the running time</h2>
<h3><code>--method</code></h3>
<p><strong>What does it do?</strong>
Parametric rules will only verify the method with the given signature, instead of all public and external methods of the contract. Note that you will need to wrap the method's signature with quotes, as the shell doesn't interpret parenthesis correctly otherwise.</p>
<p><strong>When to use it?</strong>
When you are trying to solve/understand a counterexample of a parametric rule on a specific method.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --method 'withdraw(uint256,bool)'</code></p>
<p>(--compilation<em>steps</em>only)=</p>
<h3><a id="compilation_steps_only"></a><code>--compilation_steps_only</code></h3>
<p><strong>What does it do?</strong>
Exits the program after source code and spec compilation without sending
a verification request to the cloud.</p>
<p><strong>When to use it?</strong>
Use it to check if the spec has correct syntax but do not wish
to send a verification request and wait for its results.</p>
<p>Here are a few example scenarios:
1. When writing hooks, ghosts, summaries, or CVL functions, you can verify the spec before continuing to write rules.
2. In CI, you can check CVL correctness after every PR but run the expensive and long verification only on nightly runs.
3. When you have no internet connection but still want to develop spec offline.</p>
<p><strong>Example</strong>
<code>sh
certoraRun Example.sol --verify Example:Example.spec --compilation_steps_only
</code></p>
<p>(--smt_timeout)=</p>
<h3><a id="smt_timeout"></a><code>--smt_timeout &lt;seconds&gt;</code></h3>
<p><strong>What does it do?</strong>
Sets the maximal timeout for all the
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solvers</a>.
Gets an integer input, which represents seconds.</p>
<p>The Certora Prover generates a logical formula from the specification and
source code. Then, it passes it on to an array of SMT solvers. The time it can
take for the SMT solvers to solve the equation is highly variable, and could
potentially be infinite. This is why they must be limited in run time.</p>
<p>Note that the SMT timeout applies separately to each individual rule (or each method
for parametric rules).  To set the global timeout, see {ref}<code>--global_timeout</code>.</p>
<p>Also note that, while the most prominent one, this is not the only timeout that
applies to SMT solvers, for details see {ref}<code>-mediumTimeout</code> and
{ref}<code>control-flow-splitting</code>.</p>
<p><strong>When to use it?</strong>
The default time out for the solvers is 300 seconds. There are two use cases for this option.
One is to decrease the timeout. This is useful for simple rules, that are solved quickly by the SMT solvers. Here, it is beneficial to reduce the timeout, so that when a new code breaks the specification, the tool will fail quickly. This is the more common use case.
The second use is when the solvers can prove the property, they just need more time. Usually, if the rule isn't solved in 600 seconds, it will not be solved in 2,000 either. It is better to concentrate your efforts on simplifying the rule, the source code, add more summaries, or use other time-saving options. The prime causes for an increase of <code>--smt_timeout</code> are rules that are solved quickly, but time out when you add a small change, such as a requirement, or changing a strict inequality to a weak inequality.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --smt_timeout 300</code></p>
<p>(--global_timeout)=</p>
<h3><a id="global_timeout"></a><code>--global_timeout &lt;seconds&gt;</code></h3>
<p>Sets the maximal timeout for the Prover.
Gets an integer input, which represents seconds.</p>
<p>The Certora Prover is bound to run a maximal time of 2 hours (7200 seconds).
Users may opt to set this number lower to facilitate faster iteration on specifications.
Values larger than two hours (7200 seconds) are ignored.</p>
<p>Jobs that exceed the global timeout will simply be terminated, so the result
reports may not be generated.</p>
<p>The global timeout is different from the {ref}<code>--smt_timeout</code> option: the
<code>--smt_timeout</code> flag constrains the amount of time allocated to the processing
of each individual rule, while the <code>--global_timeout</code> flag constrains the
processing of the entire job, including static analysis and other
preprocessing.</p>
<p><strong>When to use it?</strong>
When running on just a few rules, or when willing to make faster iterations on specs without waiting too long for the entire set of rules to complete.
Note that even if in the shorter running time not all rules were processed, a second run may pull some results from cache, and therefore more results will be available.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --global_timeout 60</code></p>
<h2>Options to set addresses and link contracts</h2>
<p>(--link)=</p>
<h3><a id="link"></a><code>--link</code></h3>
<p><strong>What does it do?</strong>
Links a slot in a contract with another contract.</p>
<p><strong>When to use it?</strong>
Many times a contract includes the address of another contract as one of its fields. If we do not use <code>--link</code>, it will be interpreted as any possible address, resulting in many nonsensical counterexamples.</p>
<p><strong>Example</strong>
Assume we have the contract <code>Bank.sol</code> with the following code snippet:
<code>IERC20 public underlyingToken;</code></p>
<p>We have a contract <code>BankToken.sol</code>, and <code>underlyingToken</code> should be its address. To do that, we use:
<code>certoraRun Bank.sol BankToken.sol --verify Bank:Bank.spec --link Bank:underlyingToken=BankToken</code></p>
<p>(--address)=</p>
<h3><a id="address"></a><code>--address</code></h3>
<p><strong>What does it do?</strong>
Sets the address of a contract to a given address.</p>
<p><strong>When to use it?</strong>
When we have an external contract with a constant address. By default, the Python script assigns addresses as it sees fit to contracts.</p>
<p><strong>Example</strong></p>
<p>If we wish the <code>Oracle</code> contract to be at address 12, we use
<code>certoraRun Bank.sol Oracle.sol --verify Bank:Bank.spec --address Oracle:12</code></p>
<h3><a id="struct_link"></a><code>--struct_link</code></h3>
<p><strong>What does it do?</strong>
Links a slot in a struct with another contract. To do that you must calculate the slot number of the field you wish to replace.</p>
<p><strong>When to use it?</strong>
Many times a contract includes the address of another contract inside a field of one of its structs. If we do not use <code>--struct_link</code>, it will be interpreted as any possible address, resulting in many nonsensical counterexamples.</p>
<p><strong>Example</strong>
Assume we have the contract <code>Bank.sol</code> with the following code snippet:
<code>TokenPair public tokenPair;</code></p>
<p>Where <code>TokenPair</code> is
<code>solidity
struct TokenPair {
    IERC20 tokenA;
    IERC20 tokenB;
}
</code></p>
<p>We have two contracts <code>BankToken.sol</code> and <code>LoanToken.sol</code>. We want <code>tokenA</code> of the <code>tokenPair</code> to be <code>BankToken</code>, and <code>tokenB</code> to be <code>LoanToken</code>. Addresses take up only one slot. We assume <code>tokenPair</code> is the first field of Bank (so it starts at slot zero). To do that, we use:
<code>certoraRun Bank.sol BankToken.sol LoanToken.sol --verify Bank:Bank.spec --struct_link Bank:0=BankToken Bank:1=LoanToken</code></p>
<p>(--contract<em>recursion</em>limit)=</p>
<h3><a id="contract_recursion_limit"></a><code>--contract_recursion_limit</code></h3>
<p><strong>What does it do?</strong>
Contract inlining can cause recursion (see {ref}<code>--optimistic_contract_recursion</code>). This
option sets the contract recursion level, which is the number of recursive calls
that the Prover will consider when inlining contracts linked using, e.g., <code>--link</code> or <code>--struct_link</code>.</p>
<p><code>{note}
In this context, recursion refers to the state where the same _external_ function
appears twice in the call stack.
Contracts can also exhibit recursive behavior due to recursive calls to _internal_ functions,
which is unrelated to this option.
</code></p>
<p>If a counterexample causes a function to be called recursively more than the
contract recursion limit, it will report an assertion failure (unless
{ref}<code>--optimistic_contract_recursion</code> is set, in which case the counterexample
will be ignored).
The default value is zero (i.e., no recursion is allowed).</p>
<p><strong>When to use it</strong>
Use this option when after linking the resulting program may have paths
with recursive calls to external Solidity
functions, and this leads to a recursion-specific assertion failure,
showing the message <code>Contract recursion limit reached</code>.
In this case one can either
make the limit larger or set <code>--optimistic_contract_recursion</code> flag
to <code>true</code>.</p>
<p>Note that making the limit larger is not always sufficient,
as the code may in fact allow theoretically unbounded recursion.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --contract_recursion_limit 3
</code></p>
<p>(--optimistic<em>contract</em>recursion)=</p>
<h3><a id="optimistic_contract_recursion"></a><code>--optimistic_contract_recursion</code></h3>
<p><strong>What does it do?</strong>
Contract linking can cause recursion (see also {ref}<code>--contract_recursion_limit</code>).
This option sets the Prover to optimistically assume that recursion cannot go
beyond what is defined by {ref}<code>--contract_recursion_limit</code>,
but only if {ref}<code>--contract_recursion_limit</code> is set to a number higher than 0.</p>
<p><strong>When to use it?</strong>
1. When the recursion due to contract linking is unbounded.
2. When we are interested only in a limited recursion depth due to contract linking.</p>
<p><code>{caution}
Note that this flag could be another cause for unsoundness - even if such recursion
_could_ actually happen in the deployed contract, this code-path won't be verified
beyond the specified recursion limit ({ref}`--contract_recursion_limit`).
</code></p>
<p><strong>Example</strong>
<code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_contract_recursion true --contract_recursion_limit 1
</code></p>
<p>(-optimisticFallback)=</p>
<h3><a id="optimistic_fallback"></a><code>--optimistic_fallback</code></h3>
<p>This option determines whether to optimistically assume unresolved external
calls with an empty input buffer (length 0) <em>cannot</em> make arbitrary changes to all states. It makes changes to how
{ref}<code>AUTO summaries &lt;auto-summary&gt;</code> are executed. By default unresolved external
calls with an empty input buffer will {term}<code>havoc</code> all the storage state of external contracts. When
<code>--optimistic_fallback</code> is enabled, the call will either execute the fallback function in the specified contract, revert, or execute a transfer. It will not havoc any state.</p>
<h2>Options for controlling contract creation</h2>
<p>(--dynamic_bound)=</p>
<h3><a id="dynamic_bound"></a><code>--dynamic_bound &lt;n&gt;</code></h3>
<p><strong>What does it do?</strong>
If set to zero (the default), contract creation (via the <code>new</code> statement or the <code>create</code>/<code>create2</code> instructions) will result in a havoc, like any other unresolved external call. If non-zero, then dynamic contract creation will be modeled with cloning, where each contract will be cloned at most n times.</p>
<p><strong>When to use it?</strong>
When you wish to model contract creation, that is, simulating the actual creation of the contract. Without it, <code>create</code> and <code>create2</code> commands simply return a fresh address; the Prover does not model their storage, code, constructors, immutables, etc. Any interaction with these generated addresses is modeled imprecisely with conservative havoc.</p>
<p><strong>Example</strong>
Suppose a contract <code>C</code> creates a new instance of a contract <code>Foo</code>, and you wish to inline the constructor of <code>Foo</code> at the creation site.
<code>certoraRun C.sol Foo.sol --dynamic_bound 1</code></p>
<h3><a id="dynamic_dispatch"></a><code>--dynamic_dispatch</code></h3>
<p><strong>What does it do?</strong>
If false (the default), then all contract method invocations on newly created instances will be unresolved. The user must explicitly write {ref}<code>`DISPATCHER` &lt;dispatcher&gt;</code> summaries for all methods called on newly created instances.
If true, the Prover will, on a best-effort basis, automatically apply the <code>DISPATCHER</code> summary for call sites that must be with a newly created contract as a receiver.</p>
<p>Importantly, this option is only applicable to cases where the Prover can prove that the callee is a created contract. For example, in the below example, the <code>bar</code> function will be unresolved:
<code>solidity
MyFoo f;
if(*) {
   f = new MyFoo(...);
} else {
  f = storageStruct.myFoo;
}
f.bar();
</code></p>
<p><strong>When to use it?</strong>
When you prefer not to add explicit <code>DISPATCHER</code> summaries to methods invoked by the created contract.</p>
<p><strong>Example</strong>
Suppose a contract <code>C</code> creates a new instance of a contract <code>Foo</code>, and you wish to inline the constructor of <code>Foo</code> at the creation site,
and <code>Foo</code> calls some method <code>m()</code> which you wish to automatically link to the newly created contract.
Note that you must add a <code>--dynamic_bound</code> argument as well.
<code>certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch true</code></p>
<h3><a id="prototype"></a><code>--prototype &lt;hex string&gt;=&lt;contract&gt;</code></h3>
<p><strong>What does it do?</strong>
Instructs the Prover to use a specific contract type for the return value from a call to <code>create</code> or <code>create2</code> on the given hexadecimal string as a prefix. The hexadecimal string represents proxy code that forwards calls to another contract. As we are using the prototype flag to skip calls to the proxy, no constructor code is being simulated for these contract creation resolutions.</p>
<p><strong>When to use it?</strong>
If you are verifying a contract creation that uses low level calls to <code>create</code> or <code>create2</code> for contract creation.</p>
<p><strong>Example</strong>
Suppose you have a contract <code>C</code> that creates another contract <code>Foo</code> like this:
<code>solidity
assembly {
     let ptr := mload(0x40)
     mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
     mstore(add(ptr, 0x14), shl(0x60, implementation))
     mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
     instance := create(0, ptr, 0x37)
}
</code>
Then you can set the string <code>3d602d80600a3d3981f3363d3d373d3d3d363d73</code> appearing in the first <code>mstore</code> after the <code>0x</code> prefix as a "prototype" for <code>Foo</code>.
The Prover will then be able to create a new instance of <code>Foo</code> at the point where the code creates it:
<code>certoraRun C.sol Foo.sol --prototype 3d602d80600a3d3981f3363d3d373d3d3d363d73=Foo --dynamic_bound 1</code>
Note: this argument has no effect if the {ref}<code>dynamic bound &lt;--dynamic_bound&gt;</code> is zero.</p>
<p>Also note that the hex string must be:
- a strict prefix of the memory region passed to the create command
- must be unique within each invocation of the tool
- must not contain gaps, e.g., <code>3d602d80600a3d3981f3363d3d373d3d3d363d730000</code> in the above example will not work (those last four bytes will be overwritten) but <code>3d602d80600a3d3981f3363d3d373d3d3d363d</code> will</p>
<h2>Version options</h2>
<h3><a id="version"></a><code>--version</code></h3>
<p><strong>What does it do?</strong>
Shows the version of the local installation of the tool you have.</p>
<p><strong>When to use it?</strong>
When you suspect you have an old installation. To install the newest version, use <code>pip install --upgrade certora-cli</code>.
<strong>Example</strong></p>
<p><code>certoraRun --version</code></p>
<h2>Advanced options</h2>
<h3><a id="java_args"></a><code>--java_args</code></h3>
<p><strong>What does it do?</strong></p>
<p>Allows setting configuring the underlying JVM.</p>
<p><strong>When to use it?</strong></p>
<p>Upon instruction from the Certora team.</p>
<p><strong>Example</strong></p>
<p><code>--java_args '"-Dcvt.default.parallelism=2"'</code> - will set the number of “tasks” that can run in parallel to 2.</p>
<p>(--prover_args)=</p>
<h3><a id="prover_args"></a><code>--prover_args</code></h3>
<p>The <code>--prover_args</code> option allows you to provide fine-grained tuning options to the
Prover.  <code>--prover_args</code> receives a string containing Prover-specific options, and will be sent as-is to the Prover.
<code>--prover_args</code> cannot set Prover options that are set by standalone <code>certoraRun</code> options (e.g. the Prover option <code>--t</code> is
set by <code>--smt_timeout</code> therefore cannot appear in <code>--prover_args</code>). <code>--prover_args</code> value must be quoted</p>
<p>(-optimisticReturnsize)=</p>
<h4><a id="optimisticReturnsize"></a><code>--prover_args '-optimisticReturnsize=true'</code></h4>
<p>This option determines whether {ref}<code>havoc summaries &lt;havoc-summary&gt;</code> assume
that the called method returns the correct number of return values.
It will set the value returned by the <code>RETURNSIZE</code> EVM instruction according to the
called method.
Note that certain conditions should hold in order for the option to take effect.
Namely, if there is a single candidate method in the havoc site,
and all instances of this method in the {term}<code>scene</code> have exactly the same
expected number of return values, then the <code>RETURNSIZE</code> value will be set to
the expected size matching the methods in the scene.
Otherwise, <code>RETURNSIZE</code> will remain non-deterministic.</p>
<p>(-superOptimisticReturnsize)=</p>
<h4><a id="superOptimisticReturnsize"></a><code>--prover_args '-superOptimisticReturnsize=true'</code></h4>
<p>This option determines whether {ref}<code>havoc summaries &lt;havoc-summary&gt;</code> assume
that the called method returns the correct number of return values.
It will set the value returned by the <code>RETURNSIZE</code> EVM instruction
to the size of the output buffer as specified by the summarized <code>CALL</code> instruction.</p>
<p>(--precise<em>bitwise</em>ops)=</p>
<h4><a id="precise_bitwise_ops"></a><code>--precise_bitwise_ops</code></h4>
<p>This option models bitwise operations exactly instead of using the default
{term}<code>overapproximation</code>s. It is useful when the Prover reports a
counterexample caused by incorrect modeling of bitwise operations, but can
dramatically increase the time taken for verification.</p>
<p>The disadvantage of this encoding is that it does not model <code>mathint</code>
precisely: the maximum supported integer value is :math:<code>2^256-1</code> in this case,
effectively restricting a <code>mathint</code> to a <code>uint256</code>. We currently do not have a
setting or encoding that models precisely both bitwise operations and <code>mathint</code>.</p>
<p>(-smt_groundQuantifiers)=</p>
<h4><a id="smt_groundQuantifiers"></a><code>--prover_args -smt_groundQuantifiers=false</code></h4>
<p>This option disables quantifier grounding.  See {ref}<code>grounding</code> for more
information.</p>
<p>(-maxNumberOfReachChecksBasedOnDomination)=</p>
<h4><a id="maxNumberOfReachChecksBasedOnDomination"></a><code>--prover_args '-maxNumberOfReachChecksBasedOnDomination &lt;n&gt;'</code></h4>
<p>This option sets the number of program points to test with the <code>deepSanity</code>
built-in rule.  See {ref}<code>built-in-deep-sanity</code>.</p>
<p>(-enableStorageSplitting)=</p>
<h4><a id="enableStorageSplitting"></a><code>--prover_args '-enableStorageSplitting false'</code></h4>
<p>This option disables the storage splitting optimization.</p>
<p>(--allow<em>solidity</em>calls<em>in</em>quantifiers)=</p>
<h3><a id="allow_solidity_calls_in_quantifiers"></a><code>--allow_solidity_calls_in_quantifiers</code></h3>
<p><strong>What does it do?</strong></p>
<p>Instructs the Prover to permit contract method calls in quantified expression
bodies.</p>
<p><strong>When to use it?</strong></p>
<p>Upon instruction from the Certora team.</p>
<p><strong>Example</strong></p>
<p><code>--allow_solidity_calls_in_quantifiers</code> instructs the Prover to not generate an
error on encountering contract method calls in quantified expression bodies.</p>
<p>(control-flow-splitting-options)=</p>
<h2>Control flow splitting options</h2>
<p>See <a href="control-flow-splitting">here</a> for an explanation of control flow splitting.</p>
<p>(-depth)=</p>
<h3><a id="depth"></a><code>--prover_args '-depth &lt;number&gt;'</code></h3>
<p><strong>What does it do?</strong></p>
<p>Sets the maximum splitting depth.</p>
<p><strong>When to use it?</strong></p>
<p>When the deepest {term}<code>split</code>s are too heavy to solve, but not too high in
number, increasing this will lead to smaller, but more numerous
{term}<code>split leaves</code>, which run at the full SMT timeout (as set by
{ref}<code>--smt_timeout</code>).
Conversely, if run time is too high because there are too many splits,
decreasing this number means that more time is spent on fewer, but bigger split
leaves.
The default value for this option is 10.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-depth 5'
</code></p>
<p>(-mediumTimeout)=</p>
<h3><a id="mediumTimeout"></a><code>--prover_args '-mediumTimeout &lt;seconds&gt;'</code></h3>
<p>The "medium timeout" determines how much time the SMT solver gets for checking a
{term}<code>split</code> that is not a {term}<code>split leaf</code>.
(For split leaves, the full {ref}<code>--smt_timeout</code> is used.)</p>
<p><strong>What does it do?</strong></p>
<p>Sets the time that non-leaf splits get before being split again.</p>
<p><strong>When to use it?</strong></p>
<p>When a little more time can close some splitting subtrees early, this can save a
lot of time, since the subtree's size is exponential in the remaining depth. On
the other hand, if something will be split further anyway, this can save the
run time spent on intermediate "TIMEOUT" results. Use
{ref}<code>-smt_initialSplitDepth</code> to eliminate that time investment altogether up to
a given depth.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-mediumTimeout 20'
</code></p>
<p>(-dontStopAtFirstSplitTimeout)=</p>
<h3><a id="dontStopAtFirstSplitTimeout"></a><code>--prover_args '-dontStopAtFirstSplitTimeout &lt;true/false&gt;'</code></h3>
<p><strong>What does it do?</strong></p>
<p>We can tell the Certora Prover to continue even when the a {term}<code>split</code> has had
a maximum-depth timeout. Note that this is only useful when there exists a
{term}<code>counterexample</code> for the rule under verification, since in order to prove
the absence of counterexamples (i.e. correctness), all splits need to be
counterexample-free. (In case of a rule using <code>satisfy</code> rather than <code>assert</code>,
the corresponding statements hold for {term}<code>witness example</code>s. In that case,
this option is only useful if the rule is correct.)</p>
<p><strong>When to use it?</strong></p>
<p>When looking for a SAT result and observing an <a href="timeouts-introduction">SMT-type timeout</a>.
The default value for this option is <code>false</code>.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-dontStopAtFirstSplitTimeout true'
</code></p>
<p>(-smt_initialSplitDepth)=</p>
<h3><a id="smt_initialSplitDepth"></a><code>--prover_args '-smt_initialSplitDepth &lt;number&gt;'</code></h3>
<p>With this option, the splitting can be configured to skip the SMT solver-based checks
at low splitting levels, thus generating sub-{term}<code>split</code>s up to a given depth immediately.</p>
<p><strong>What does it do?</strong></p>
<p>The first <code>&lt;number&gt;</code> split levels are not checked with the SMT solver, but rather
split immediately.</p>
<p><strong>When to use it?</strong></p>
<p>When there is a lot of overhead induced by processing and trying to solve splits
that are very hard, and thus run into a timeout anyway.</p>
<p><code>{note} The number of
splits generated here is equal to `2^n` where `n` is the initial splitting depth
(assuming the program has enough branching points, which is usually the case);
thus, low numbers are advisable. For instance setting this to 5 means that the
Prover will immediately produce 32 splits.
</code></p>
<p><code>{note}
The {ref}`-depth` setting has precedence over this setting. I.e., if `-depth`
is set to a lower value than `-smt_initialSplitDepth`, the initial splitting
will only proceed up to the splitting depth given via `-depth`.
</code></p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-smt_initialSplitDepth 3'
</code></p>
<html><head><meta content="https://github.com/Certora/Documentation/prover/cli/options.md" name="url"/><meta content="No Title Found" name="title"/><meta content="CLI Options
The certoraRun utility invokes the Solidity compiler and afterwards sends the job to Certora's servers. 
The most commonly used command is:
bash
certoraRun contractFile:contractName --veri" name="text"/></head><body><h1>CLI Options</h1>
<p>The <code>certoraRun</code> utility invokes the Solidity compiler and afterwards sends the job to Certora's servers. </p>
<p>The most commonly used command is:</p>
<p><code>bash
certoraRun contractFile:contractName --verify contractName:specFile
</code></p>
<p>If <code>contractFile</code> is named <code>contractName.sol</code>, the run command can be simplified to
<code>bash
certoraRun contractFile --verify contractName:specFile
</code></p>
<p>A short summary of these options can be seen by invoking <code>certoraRun --help</code></p>
<h2>Using Configuration (Conf) Files</h2>
<p>For larger projects, the command line for running the Certora Prover can become large
and cumbersome. It is therefore recommended to use configuration files instead.
These are <a href="https://json5.org/">JSON5</a> files (with <code>.conf</code> extension) that hold the parameters and options for the Prover.
See {ref}<code>conf-files</code> for more information.</p>
<p><code>{contents} Overview
</code></p>
<h2>Modes of operation</h2>
<p>The Certora Prover has three modes of operation. The modes are mutually exclusive - you cannot run the tool with more than one mode at a time.</p>
<p>(--verify)=</p>
<h3><a id="verify"></a><code>--verify</code></h3>
<p><strong>What does it do?</strong>
It runs formal verification of properties specified in a .spec file on a given contract. Each contract must have been declared in the input files or have the same name as the source code file it is in.</p>
<p><strong>When to use it?</strong>
When you wish to prove properties on the source code. This is by far the most common mode of the tool.</p>
<p><strong>Example</strong>
If we have a Solidity file <code>Bank.sol</code>, with a contract named <code>Bank</code> inside it, and a specification file called <code>Bank.spec</code>, the run command would be:
<code>certoraRun Bank.sol --verify Bank:Bank.spec</code></p>
<h2>Most frequently used options</h2>
<h3><a id="msg"></a><code>--msg &lt;description&gt;</code></h3>
<p><strong>What does it do?</strong>
Adds a message description to your run, similar to a commit message. This message will appear in the title of the completion email sent to you. Note that you need to wrap your message in quotes if it contains spaces.</p>
<p><strong>When to use it?</strong>
Adding a message makes it easier to track several runs. It is very useful if you are running many verifications simultaneously. It is also helpful to keep track of a single file verification status over time, so we recommend always providing an informative message.</p>
<p><strong>Example</strong>
To create the message above, we used
<code>certoraRun Bank.sol --verify Bank:Bank.spec --msg 'Removed an assertion'</code></p>
<p>(--rule)=</p>
<h3><a id="rule"></a><code>--rule &lt;rule_name_pattern&gt; ...</code></h3>
<p><strong>What does it do?</strong>
Formally verifies one or more given properties instead of the whole specification file. An invariant can also be selected.</p>
<p><strong>When to use it?</strong>
This option saves a lot of run time. Use it whenever you care about only a
specific subset of a specification's properties. The most common case is when
you add a new rule to an existing specification. The other is when code changes
cause a specific rule to fail; in the process of fixing the code, updating the
rule, and understanding counterexamples, you likely want to verify only that
specific rule.</p>
<p>One can either specify a specific rule name, or use pattern matching with a <code>*</code>.</p>
<p>Note that you can specify this flag multiple times to filter in several rules or rule patterns.
<strong>Example</strong>
If <code>Bank.spec</code> includes the following properties:</p>
<p><code>invariant address_zero_cannot_become_an_account()</code>
<code>rule withdraw_succeeds()</code>
<code>rule withdraw_fails()</code></p>
<p>If we want to verify only <code>withdraw_succeeds</code>, we run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds</code></p>
<p>If we want to verify both <code>withdraw_succeeds</code> and <code>withdraw_fails</code>, we run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw_succeeds withdraw_fails</code></p>
<p>Alternatively, to verify both <code>withdraw_succeeds</code> and <code>withdraw_fails</code>, we could
simply run <code>certoraRun Bank.sol --verify Bank:Bank.spec --rule withdraw*</code></p>
<p>(--exclude_rule)=</p>
<h3><a id="exclude_rule"></a> <code>--exclude_rule &lt;rule_name_pattern&gt;</code></h3>
<p><strong>What does it do?</strong>
It is the opposite flag to {ref}<code>--rule</code> - use it to specify a list of rules that
should <em>not</em> be run.</p>
<p>Note that you can specify this flag multiple times to filter out several rules or rule patterns.</p>
<p><strong>Example</strong>
If <code>Bank.spec</code> includes the following properties:</p>
<p><code>invariant address_zero_cannot_become_an_account()</code>
<code>rule withdraw_succeeds()</code>
<code>rule withdraw_fails()</code></p>
<p>If we want to skip both rules we could run
<code>certoraRun Bank.sol --verify Bank:Bank.spec --exclude_rule withdraw*</code></p>
<p><code>{note}
When used together with the {ref}`--rule` flag the logic is to collect all rules
that pass the `--rule` flag(s) and then subtract from them all rules that match
any `--exclude_rule` flags.
</code></p>
<p>(--method)=</p>
<h3><a id="method"></a><code>--method &lt;method_signature&gt;</code></h3>
<p><strong>What does it do?</strong>
Only uses functions with the given method signature when instantiating
{term}<code>parametric rule</code>s and {term}<code>invariant</code>s.  The method signature consists
of the name of a method and the types of its arguments.</p>
<p>You may provide multiple method signatures, in which case the Prover will run on
each of the listed methods.</p>
<p><strong>When to use it?</strong>
This option is useful when focusing on a specific counterexample; running on a
specific contract method saves time.</p>
<p><strong>Example</strong>
Suppose we are verifying an ERC20 contract, and we have the following
{term}<code>parametric rule</code>:</p>
<p>```cvl
rule r {
    method f; env e; calldataarg args;
    address owner; address spender;</p>
<pre><code>mathint allowance_before = allowance(owner, spender);
f(e,args);
mathint allowance_after  = allowance(owner, spender);

assert allowance_after &gt; allowance_before =&gt; e.msg.sender == owner;
</code></pre>
<p>}
```</p>
<p>If we discover a counterexample in the method <code>deposit(uint)</code>, and wish to change
the contract or the spec to rerun, we can just rerun on the <code>deposit</code> method:</p>
<p><code>sh
certoraRun --method 'deposit(uint)'
</code></p>
<p>Note that many shells will interpret the <code>(</code> and <code>)</code> characters specially, so
the method signature argument will usually need to be quoted as in the example.</p>
<p>(--parametric_contracts)=</p>
<h3><a id="parametric_contracts"></a><code>--parametric_contracts &lt;contract_name&gt; ...</code></h3>
<p><code>{versionadded} 5.0
Prior to version 5, method variables and invariants were only instantiated with
methods of {ref}`currentContract`.
</code></p>
<p><strong>What does it do?</strong>
Only uses methods on the specified contract when instantiating
{term}<code>parametric rule</code>s or {term}<code>invariant</code>s.  The contract name must be one
of the contracts included in the {term}<code>scene</code>.</p>
<p><strong>When to use it?</strong>
As with the {ref}<code>--rule</code> and {ref}<code>--method</code> options, this option is used to
avoid rerunning the entire verification</p>
<p><strong>Example</strong>
Suppose you are working on a multicontract verification and wish to debug a
counterexample in a method of the <code>Underlying</code> contract defined in the file
<code>Example.sol</code>:</p>
<p><code>sh
certoraRun Main:Example.sol Underlying:Example.sol --verify Main:Example.spec \
    --parametric_contracts Underlying
</code></p>
<p>(--wait<em>for</em>results)=</p>
<h3><a id="wait_for_results"></a><code>--wait_for_results</code></h3>
<p><strong>What does it do?</strong>
Wait for verification results after sending the verification request.
By default, the program exits after the request.
The return code will not be zero if the verification finds a violation.</p>
<p><strong>When to use it?</strong>
Use it to receive verification results in the terminal or a wrapping script.</p>
<p>In CI, the default behavior is different: the Prover waits for verification results,
and the return code will not be zero if a violation is found. 
You can force the Prover not to wait for verification results by using <code>--wait_for_results NONE</code>.
In that case, the return code will be zero if the jobs were sent successfully.</p>
<p><strong>Example</strong>
<code>sh
certoraRun Example.sol --verify Example:Example.spec --wait_for_results
</code></p>
<h2>Options affecting the type of verification run</h2>
<p>(--multi<em>assert</em>check)=</p>
<h3><a id="multi_assert_check"></a><code>--multi_assert_check</code></h3>
<p><strong>What does it do?</strong>
This mode checks each assertion statement that occurs in a rule, separately. The check is done by decomposing each rule into multiple sub-rules, each of which checks one assertion, while it assumes all preceding assertions. In addition, all assertions that originate from the Solidity code (as opposed to those from the specification), are checked together by a designated, single sub-rule.</p>
<p>As an illustrative example, consider the following rule <code>R</code> that has two assertions:</p>
<p><code>cvl
...
assert a1
...
assert a2
...
</code></p>
<p>The <code>multi_assert_check</code> mode would generate and check two sub-rules: <code>R1</code> where <code>a1</code> is proved while <code>a2</code> is removed, and <code>R2</code> where <code>a1</code> is assumed (i.e., transformed into a requirement statement), and <code>a2</code> is proved.</p>
<p><code>R</code> passes if and only if, <code>R1</code> and <code>R2</code> both pass. In particular, in case <code>R1</code> (resp. <code>R2</code>) fails, the counter-example shows a violation of <code>a1</code> (resp. <code>a2</code>).</p>
<p><code>{caution}
We suggest using this mode carefully. In general, as this mode generates and checks more rules, it may lead to worse running-time performance. Please see indications for use below.
</code></p>
<p><strong>When to use it?</strong>
When you have a rule with multiple assertions:</p>
<ol>
<li><p>As a timeout mitigation strategy: checking each assertion separately may, in some cases, perform better than checking all the assertions together and consequently solve timeouts.</p></li>
<li><p>If you wish to get multiple counter-examples in a single run of the tool, where each counter-example violates a different assertion in the rule.</p></li>
</ol>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --multi_assert_check</code></p>
<p>(--independent_satisfy)=</p>
<h3><a id="independent_satisfy"></a><code>--independent_satisfy</code></h3>
<p><strong>What does it do?</strong>
The independent satisfy mode checks each {ref}<code>satisfy statement &lt;satisfy&gt;</code> independently from all other satisfy statements that occurs in a rule.
Normally, each satisfy statement will be turned into a sub-rule (similarly to the {ref}<code>--multi_assert_check</code> mode),
but previously encountered satisfy statements will be still considered when creating a satisfying assignment.</p>
<p>As an illustrative example of the default mode, consider the following rule <code>R</code> that has two satisfy statements:</p>
<p><code>cvl
rule R {
  bool b;
  satisfy b, "R1";
  satisfy !b, "R2";
}
</code></p>
<p>The statements for "R1" and "R2" will actually create two sub-rules equivalent to:
```cvl
rule R1_default {
  bool b;
  satisfy b, "R1";
}</p>
<p>rule R2_default {
  bool b;
  // Previous satisfy statements are required in default mode.
  require b; // R1
  // Due to requiring <code>b</code>, this satisfy statement is equivalent to 'satisfy b &amp;&amp; !b, "R2";'
  satisfy !b, "R2";
}
```</p>
<p>Without turning <code>independent_satisfy</code> mode on, <code>R2</code> would have failed, as it would try to satisfy <code>b &amp;&amp; !b</code>, an unsatisfiable contradiction.
Turning on the <code>independent_satisfy</code> mode will ignore all currently unchecked satisfy statements for each sub-rule.
It would also generate and check two sub-rules, but with a slight difference: <code>R1</code> where <code>b</code> is satisfied (by <code>b=true</code>) while <code>satisfy !b</code> is removed, and <code>R2</code> where <code>satisfy b</code> is removed, and <code>!b</code> is satisfied (by <code>b=false</code>).</p>
<p>The two <code>independent_satisfy</code> generated sub-rules will be equivalent to:</p>
<p>```cvl
rule R1_independent {
  bool b;
  satisfy b, "R1";
}</p>
<p>rule R2_independent {
  bool b;
  // require b;
  satisfy !b, "R2";
}
```</p>
<p><strong>When to use it?</strong>
When you have a rule with multiple satisfy statements, and you would like to demonstrate each statement separately.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --independent_satisfy</code></p>
<p>(--rule_sanity)=</p>
<h3><a id="rule_sanity"></a><code>--rule_sanity</code></h3>
<p><strong>What does it do?</strong>
This option enables sanity checking for rules.  The <code>--rule_sanity</code> option may
be followed by one of <code>none</code>, <code>basic</code>, or <code>advanced</code>;
See {doc}<code>../checking/sanity</code> for more information about sanity checks.</p>
<p><strong>When to use it?</strong>
We suggest using this option routinely while developing rules.  It is also a
useful check if you notice rules passing surprisingly quickly or easily.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --rule_sanity basic</code></p>
<h3><a id="short_output"></a><code>--short_output</code></h3>
<p><strong>What does it do?</strong>
Reduces the verbosity of the tool.</p>
<p><strong>When to use it?</strong>
When we do not care much for the output. It is recommended when running the tool in continuous integration.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --short_output</code></p>
<h2>Options that control the Solidity compiler</h2>
<p>(--solc)=</p>
<h3><a id="solc"></a><code>--solc</code></h3>
<p><strong>What does it do?</strong>
Use this option to provide a path to the Solidity compiler executable file. We check in all directories in the <code>$PATH</code> environment variable for an executable with this name. If <code>--solc</code> is not used, we look for an executable called <code>solc</code>, or <code>solc.exe</code> on windows platforms.</p>
<p><strong>When to use it?</strong>
Whenever you want to use a Solidity compiler executable with a non-default name. This is usually used when you have several Solidity compiler executable versions you switch between.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc solc8.1</code></p>
<p>(--compiler<em>map)=
(--solc</em>map)=</p>
<h3><a id="compiler_map"></a><code>--compiler_map</code></h3>
<p><strong>What does it do?</strong>
Compiles every smart contract with a different compiler executable (Solidity version or Vyper). All used contracts must be listed.</p>
<p><strong>When to use it?</strong>
When different contracts have to be compiled for different Solidity versions.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol Exchange.sol Token.vy --verify Bank:Bank.spec --compiler_map Bank=solc4.25,Exchange=solc6.7,Token=vyper0.3.10</code></p>
<p>(--solc_optimize)=</p>
<h3><a id="solc_optimize"></a><code>--solc_optimize</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option as is to the solidity compiler's option <code>--optimize</code> and <code>--optimize-runs</code>.</p>
<p><strong>When to use it?</strong>
When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the
number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs)</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize 300</code></p>
<p>(--solc<em>optimize</em>map)=</p>
<h3><a id="solc_optimize_map"></a><code>--solc_optimize_map</code></h3>
<p><strong>What does it do?</strong>
Set optimize values when different files run with different number of runs
Passes the value of this option as is to the solidity compiler's option <code>--optimize</code> and <code>--optimize-runs</code>.</p>
<p><strong>When to use it?</strong>
When we want to activate in the solidity compiler the opcode-based optimizer for the generated bytecode and control the
number of times the optimizer will be activated (if no value is set, the compiler's default is 200 runs)</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_optimize_map Bank=200,Exchange=300</code></p>
<p>(--solc<em>via</em>ir)=</p>
<h3><a id="solc_via_ir"></a><code>--solc_via_ir</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option  to the solidity compiler's option <code>--via-ir</code>.</p>
<p><strong>When to use it?</strong>
When we want to enable the IR-based code generator</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_via_ir</code></p>
<h3><a id="solc_evm_version"></a><code>--solc_evm_version</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option  to the solidity compiler's option <code>--evm-version</code>.</p>
<p><strong>When to use it?</strong>
When we want to select the Solidity compiler EVM version</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_evm_version Istanbul</code></p>
<h3><a id="solc_allow_path"></a><code>--solc_allow_path</code></h3>
<p><strong>What does it do?</strong>
Passes the value of this option as is to the solidity compiler's option <code>--allow-paths</code>.
See <a href="https://docs.soliditylang.org/en/v0.8.16/path-resolution.html#allowed-paths">--allow-path specification</a></p>
<p><strong>When to use it?</strong>
When we want to add an additional location the Solidity compiler to load sources from</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --solc_allow_path ~/Projects/Bank</code></p>
<h3><a id="packages_path"></a><code>--packages_path</code></h3>
<p><strong>What does it do?</strong>
Gets the path to a directory including the Solidity packages.</p>
<p><strong>When to use it?</strong>
By default, we look for the packages in <code>$NODE_PATH</code>. If the packages are in any other directory, you must use <code>--packages_path</code>.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --packages_path Solidity/packages</code></p>
<p>(--packages)=</p>
<h3><a id="packages"></a><code>--packages</code></h3>
<p><strong>What does it do?</strong>
For each package, gets the path to a directory including that Solidity package.</p>
<p><strong>When to use it?</strong>
By default we look for the packages in <code>$NODE_PATH</code>. If there are packages are in several different directories, use <code>--packages</code>.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --packages ds-stop=$PWD/lib/ds-token/lib/ds-stop/src ds-note=$PWD/lib/ds-token/lib/ds-stop/lib/ds-note/src</code></p>
<h2>Options regarding source code loops</h2>
<p>(--optimistic_loop)=</p>
<h3><a id="optimistic_loop"></a><code>--optimistic_loop</code></h3>
<p><strong>What does it do?</strong>
The Certora Prover unrolls loops - if the loop should be executed three times, it will copy the code inside the loop three times. After we finish the loop's iterations, we add an assertion to verify we have actually finished running the loop. For example, in a <code>while (a &lt; b)</code> loop, after the loop's unrolling, we add <code>assert a &gt;= b</code>. We call this assertion the <em>loop unwind condition</em>.
This option changes the assertions of the loop unwind condition to requirements (in the case above <code>require a &gt;= b</code>). That means, we ignore all the cases where the loop unwind condition does not hold, instead of considering them as a failure.</p>
<p><strong>When to use it?</strong>
When you have loops in your code and are getting a counterexample labeled <code>loop unwind condition</code>. In general, you need this flag whenever the number of loop iterations varies. It is usually a necessity if using {ref}<code>--loop_iter</code>. Note that <code>--optimistic_loop</code> could cause {ref}<code>vacuous rules &lt;--rule_sanity&gt;</code>.</p>
<p><strong>Example</strong>
<code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_loop
</code></p>
<p>(--loop_iter)=</p>
<h3><a id="loop_iter"></a><code>--loop_iter</code></h3>
<p><strong>What does it do?</strong>
Sets the maximal number of loop iterations we verify for. The way the Certora Prover handles loops is by unrolling them - if the loop should be executed three times, it will copy the code inside the loop three times. This option sets the number of unrolls. Be aware that the run time grows exponentially by the number of loop iterations.</p>
<p><strong>When to use it?</strong>
The default number of loop iterations we unroll is one. However, in many cases, bugs only occur when there are several iterations. Common scenarios include iteration over list elements. Two, or in some cases three, is usually the most you will ever need to uncover bugs.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --loop_iter 2
</code></p>
<h2>Options regarding summarization</h2>
<p>(--optimistic<em>summary</em>recursion)=</p>
<h3><a id="optimistic_summary_recursion"></a><code>--optimistic_summary_recursion</code></h3>
<p><strong>What does it do?</strong>
In case there's a call to some Solidity function within a summary, we may end up
with recursive calls to this summary. For example, if in the summary of <code>foo</code> we
call the Solidity function <code>bar</code>, and <code>bar</code>'s Solidity code contains a call to
<code>foo</code>, we'll summarize <code>foo</code> again, which will lead to another call to <code>bar</code>
etc. In this case if this flag is set to <code>false</code> we may get an assertion failure
with a message along the lines of
<code>text
Recursion limit (...) for calls to ..., reached during compilation of summary ...
</code>
Such recursion can also happen with {ref}<code>dispatcher summaries &lt;dispatcher&gt;</code> —
if a contract method <code>f</code> makes an unresolved external call to a different method
<code>f</code>, and if <code>f</code> is summarized with a <code>DISPATCHER</code> summary, then the Prover will
consider paths where <code>f</code> recursively calls itself. Without <code>--optimistic_summary_recursion</code>,
the Prover may report a rule violation with the following assert message:
<code>text
When summarizing a call with dispatcher, found we already have it in the stack: ... consider removing its dispatcher summary.
</code>
The default behavior in this case is to assert that the recursion limit is not
reached (the limit is controlled by the {ref}<code>--summary_recursion_limit</code> flag).
With <code>--optimistic_summary_recursion</code>, the Prover will instead assume that the
limit is never reached.</p>
<p><strong>When to use it</strong>
Use this flag when there is recursion due to summaries calling Solidity
functions, and this causes an undesired assertion failure. In this case one can
either make the limit larger (via {ref}<code>--summary_recursion_limit</code>) or set this
flag to <code>true</code>.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_summary_recursion true
</code></p>
<p><code>{caution}
Note that this flag could be another cause for unsoundness - even if such recursion
_could_ actually happen in the deployed contract, this code-path won't be verified.
</code></p>
<p>(--summary<em>recursion</em>limit)=</p>
<h3><a id="summary_recursion_limit"></a><code>--summary_recursion_limit</code></h3>
<p><strong>What does it do?</strong>
Summaries can cause recursion (see {ref}<code>--optimistic_summary_recursion</code>). This
option sets the summary recursion level, which is the number of recursive calls
that the Prover will consider.</p>
<p>If the Prover finds an execution in which a function is called recursively more
than the contract recursion limit, the Prover will report an assertion failure (unless
{ref}<code>--optimistic_summary_recursion</code> is set, in which case the execution
will be ignored).
The default value is zero (i.e. no recursion is allowed).</p>
<p><strong>When to use it</strong>
1. Use this option when there is recursion due to summaries calling Solidity
functions, and this leads to an assertion failure. In this case one can either
make the limit larger or set (via {ref}<code>--optimistic_summary_recursion</code>) flag
to <code>true</code>.</p>
<ol start="2">
<li>Use it if you get the following assertion failure, and disabling {ref}<code>optimistic fallback &lt;-optimisticFallback&gt;</code> is not possible: <code>When inlining a fallback function, found it was already on the stack. Consider disabling optimistic fallback mode.</code></li>
</ol>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --summary_recursion_limit 3
</code></p>
<p>(--nondet<em>difficult</em>funcs)=</p>
<h3><a id="nondet_difficult_funcs"></a><code>--nondet_difficult_funcs</code></h3>
<p><strong>What does it do?</strong>
When this option is set, the Prover will auto-summarize
view or pure internal functions that return a value type and are
currently not summarized, and that are found to be heuristically difficult
for the Prover.</p>
<p>For more information, see {ref}<code>detect-candidates-for-summarization</code>.</p>
<p><strong>When to use it</strong>
Using this option is recommended when beginning to work on a large code
base that includes functions that could be difficult for the Prover.
It can help the user get faster feedback, both in the form of faster
verification results, as well as highlighting potentially difficult functions.</p>
<p><strong>Example</strong></p>
<p><code>bash
certoraRun Bank.sol --verify Bank:Bank.spec --nondet_difficult_funcs
</code></p>
<p>(--nondet<em>minimal</em>difficulty)=</p>
<h3><a id="nondet_minimal_difficulty"></a><code>--nondet_minimal_difficulty</code></h3>
<p><strong>What does it do?</strong>
This option sets the minimal difficulty threshold for the auto-summarization mode enabled by {ref}<code>--nondet_difficult_funcs</code>.</p>
<p><strong>When to use it</strong>
If the results of an initial run with {ref}<code>--nondet_difficult_funcs</code> were unsatisfactory,
one can adjust the default threshold to apply the auto-summarization to potentially more or fewer internal functions.</p>
<p>The notification in the rule report that contains the applied summaries will present the current threshold used by the Prover.</p>
<p><strong>Example</strong></p>
<p><code>bash
certoraRun Bank.sol --verify Bank:Bank.spec --nondet_difficult_funcs --nondet_minimal_difficulty 20
</code></p>
<h2>Options regarding hashing of unbounded data</h2>
<p>(--optimistic_hashing)=</p>
<h3><a id="optimistic_hashing"></a><code>--optimistic_hashing</code></h3>
<p><strong>What does it do?</strong></p>
<p>When hashing data of potentially unbounded length (including unbounded arrays, like <code>bytes</code>, <code>uint[]</code>, etc.), assume that its length is bounded by the value set through the <code>--hashing_length_bound</code> option. If this is not set, and the length can be exceeded by the input program, the Prover reports an assertion violation. I.e., when this option is set, the boundedness of the hashed data assumed checked by the Prover, when this option is set that boundedness is assumed instead.</p>
<p>See {doc}<code>../approx/hashing</code> for more details.</p>
<p><strong>When to use it?</strong></p>
<p>When the assertion regarding unbounded hashing is thrown, but it is acceptable for the Prover to ignore cases where the length hashed values exceeds the current bound.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_hashing
</code></p>
<p>(--hashing<em>length</em>bound)=</p>
<h3><a id="hashing_length_bound"></a><code>--hashing_length_bound</code></h3>
<p><strong>What does it do?</strong></p>
<p>Constraint on the maximal length of otherwise unbounded data chunks that are being hashed. This constraint is either assumed or checked by the Prover, depending on whether <code>--optimistic_hashing</code> has been set. The bound is specified as a number of bytes.</p>
<p>The default value of this option is 224 (224 bytes correspond to 7 EVM machine words as 7 * 32 == 224).</p>
<p><strong>When to use it?</strong>
Reason to lower this value:</p>
<p>Lowering potentially improves SMT performance, especially if there are many occurrences of unbounded hashing in the program.</p>
<p>Reasons to raise this value:</p>
<ul>
<li>when <code>--optimistic_hashing</code> is not set: avoid the assertion being violated when the hashed values are actually bounded, but by a bound that is higher than the default value (in case of <code>--optimistic_hashing</code> being not set)</li>
<li>when <code>--optimistic_hashing</code> is set: find bugs that rely on a hashed array being at least of that length. (Optimistic hashing excludes all cases from the scope of verification where something being hashed is longer than this bound.)</li>
</ul>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --hashing_length_bound 128
</code></p>
<h2>Options that help reduce the running time</h2>
<h3><code>--method</code></h3>
<p><strong>What does it do?</strong>
Parametric rules will only verify the method with the given signature, instead of all public and external methods of the contract. Note that you will need to wrap the method's signature with quotes, as the shell doesn't interpret parenthesis correctly otherwise.</p>
<p><strong>When to use it?</strong>
When you are trying to solve/understand a counterexample of a parametric rule on a specific method.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --method 'withdraw(uint256,bool)'</code></p>
<p>(--compilation<em>steps</em>only)=</p>
<h3><a id="compilation_steps_only"></a><code>--compilation_steps_only</code></h3>
<p><strong>What does it do?</strong>
Exits the program after source code and spec compilation without sending
a verification request to the cloud.</p>
<p><strong>When to use it?</strong>
Use it to check if the spec has correct syntax but do not wish
to send a verification request and wait for its results.</p>
<p>Here are a few example scenarios:
1. When writing hooks, ghosts, summaries, or CVL functions, you can verify the spec before continuing to write rules.
2. In CI, you can check CVL correctness after every PR but run the expensive and long verification only on nightly runs.
3. When you have no internet connection but still want to develop spec offline.</p>
<p><strong>Example</strong>
<code>sh
certoraRun Example.sol --verify Example:Example.spec --compilation_steps_only
</code></p>
<p>(--smt_timeout)=</p>
<h3><a id="smt_timeout"></a><code>--smt_timeout &lt;seconds&gt;</code></h3>
<p><strong>What does it do?</strong>
Sets the maximal timeout for all the
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solvers</a>.
Gets an integer input, which represents seconds.</p>
<p>The Certora Prover generates a logical formula from the specification and
source code. Then, it passes it on to an array of SMT solvers. The time it can
take for the SMT solvers to solve the equation is highly variable, and could
potentially be infinite. This is why they must be limited in run time.</p>
<p>Note that the SMT timeout applies separately to each individual rule (or each method
for parametric rules).  To set the global timeout, see {ref}<code>--global_timeout</code>.</p>
<p>Also note that, while the most prominent one, this is not the only timeout that
applies to SMT solvers, for details see {ref}<code>-mediumTimeout</code> and
{ref}<code>control-flow-splitting</code>.</p>
<p><strong>When to use it?</strong>
The default time out for the solvers is 300 seconds. There are two use cases for this option.
One is to decrease the timeout. This is useful for simple rules, that are solved quickly by the SMT solvers. Here, it is beneficial to reduce the timeout, so that when a new code breaks the specification, the tool will fail quickly. This is the more common use case.
The second use is when the solvers can prove the property, they just need more time. Usually, if the rule isn't solved in 600 seconds, it will not be solved in 2,000 either. It is better to concentrate your efforts on simplifying the rule, the source code, add more summaries, or use other time-saving options. The prime causes for an increase of <code>--smt_timeout</code> are rules that are solved quickly, but time out when you add a small change, such as a requirement, or changing a strict inequality to a weak inequality.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --smt_timeout 300</code></p>
<p>(--global_timeout)=</p>
<h3><a id="global_timeout"></a><code>--global_timeout &lt;seconds&gt;</code></h3>
<p>Sets the maximal timeout for the Prover.
Gets an integer input, which represents seconds.</p>
<p>The Certora Prover is bound to run a maximal time of 2 hours (7200 seconds).
Users may opt to set this number lower to facilitate faster iteration on specifications.
Values larger than two hours (7200 seconds) are ignored.</p>
<p>Jobs that exceed the global timeout will simply be terminated, so the result
reports may not be generated.</p>
<p>The global timeout is different from the {ref}<code>--smt_timeout</code> option: the
<code>--smt_timeout</code> flag constrains the amount of time allocated to the processing
of each individual rule, while the <code>--global_timeout</code> flag constrains the
processing of the entire job, including static analysis and other
preprocessing.</p>
<p><strong>When to use it?</strong>
When running on just a few rules, or when willing to make faster iterations on specs without waiting too long for the entire set of rules to complete.
Note that even if in the shorter running time not all rules were processed, a second run may pull some results from cache, and therefore more results will be available.</p>
<p><strong>Example</strong>
<code>certoraRun Bank.sol --verify Bank:Bank.spec --global_timeout 60</code></p>
<h2>Options to set addresses and link contracts</h2>
<p>(--link)=</p>
<h3><a id="link"></a><code>--link</code></h3>
<p><strong>What does it do?</strong>
Links a slot in a contract with another contract.</p>
<p><strong>When to use it?</strong>
Many times a contract includes the address of another contract as one of its fields. If we do not use <code>--link</code>, it will be interpreted as any possible address, resulting in many nonsensical counterexamples.</p>
<p><strong>Example</strong>
Assume we have the contract <code>Bank.sol</code> with the following code snippet:
<code>IERC20 public underlyingToken;</code></p>
<p>We have a contract <code>BankToken.sol</code>, and <code>underlyingToken</code> should be its address. To do that, we use:
<code>certoraRun Bank.sol BankToken.sol --verify Bank:Bank.spec --link Bank:underlyingToken=BankToken</code></p>
<p>(--address)=</p>
<h3><a id="address"></a><code>--address</code></h3>
<p><strong>What does it do?</strong>
Sets the address of a contract to a given address.</p>
<p><strong>When to use it?</strong>
When we have an external contract with a constant address. By default, the Python script assigns addresses as it sees fit to contracts.</p>
<p><strong>Example</strong></p>
<p>If we wish the <code>Oracle</code> contract to be at address 12, we use
<code>certoraRun Bank.sol Oracle.sol --verify Bank:Bank.spec --address Oracle:12</code></p>
<h3><a id="struct_link"></a><code>--struct_link</code></h3>
<p><strong>What does it do?</strong>
Links a slot in a struct with another contract. To do that you must calculate the slot number of the field you wish to replace.</p>
<p><strong>When to use it?</strong>
Many times a contract includes the address of another contract inside a field of one of its structs. If we do not use <code>--struct_link</code>, it will be interpreted as any possible address, resulting in many nonsensical counterexamples.</p>
<p><strong>Example</strong>
Assume we have the contract <code>Bank.sol</code> with the following code snippet:
<code>TokenPair public tokenPair;</code></p>
<p>Where <code>TokenPair</code> is
<code>solidity
struct TokenPair {
    IERC20 tokenA;
    IERC20 tokenB;
}
</code></p>
<p>We have two contracts <code>BankToken.sol</code> and <code>LoanToken.sol</code>. We want <code>tokenA</code> of the <code>tokenPair</code> to be <code>BankToken</code>, and <code>tokenB</code> to be <code>LoanToken</code>. Addresses take up only one slot. We assume <code>tokenPair</code> is the first field of Bank (so it starts at slot zero). To do that, we use:
<code>certoraRun Bank.sol BankToken.sol LoanToken.sol --verify Bank:Bank.spec --struct_link Bank:0=BankToken Bank:1=LoanToken</code></p>
<p>(--contract<em>recursion</em>limit)=</p>
<h3><a id="contract_recursion_limit"></a><code>--contract_recursion_limit</code></h3>
<p><strong>What does it do?</strong>
Contract inlining can cause recursion (see {ref}<code>--optimistic_contract_recursion</code>). This
option sets the contract recursion level, which is the number of recursive calls
that the Prover will consider when inlining contracts linked using, e.g., <code>--link</code> or <code>--struct_link</code>.</p>
<p><code>{note}
In this context, recursion refers to the state where the same _external_ function
appears twice in the call stack.
Contracts can also exhibit recursive behavior due to recursive calls to _internal_ functions,
which is unrelated to this option.
</code></p>
<p>If a counterexample causes a function to be called recursively more than the
contract recursion limit, it will report an assertion failure (unless
{ref}<code>--optimistic_contract_recursion</code> is set, in which case the counterexample
will be ignored).
The default value is zero (i.e., no recursion is allowed).</p>
<p><strong>When to use it</strong>
Use this option when after linking the resulting program may have paths
with recursive calls to external Solidity
functions, and this leads to a recursion-specific assertion failure,
showing the message <code>Contract recursion limit reached</code>.
In this case one can either
make the limit larger or set <code>--optimistic_contract_recursion</code> flag
to <code>true</code>.</p>
<p>Note that making the limit larger is not always sufficient,
as the code may in fact allow theoretically unbounded recursion.</p>
<p><strong>Example</strong></p>
<p><code>
certoraRun Bank.sol --verify Bank:Bank.spec --contract_recursion_limit 3
</code></p>
<p>(--optimistic<em>contract</em>recursion)=</p>
<h3><a id="optimistic_contract_recursion"></a><code>--optimistic_contract_recursion</code></h3>
<p><strong>What does it do?</strong>
Contract linking can cause recursion (see also {ref}<code>--contract_recursion_limit</code>).
This option sets the Prover to optimistically assume that recursion cannot go
beyond what is defined by {ref}<code>--contract_recursion_limit</code>,
but only if {ref}<code>--contract_recursion_limit</code> is set to a number higher than 0.</p>
<p><strong>When to use it?</strong>
1. When the recursion due to contract linking is unbounded.
2. When we are interested only in a limited recursion depth due to contract linking.</p>
<p><code>{caution}
Note that this flag could be another cause for unsoundness - even if such recursion
_could_ actually happen in the deployed contract, this code-path won't be verified
beyond the specified recursion limit ({ref}`--contract_recursion_limit`).
</code></p>
<p><strong>Example</strong>
<code>
certoraRun Bank.sol --verify Bank:Bank.spec --optimistic_contract_recursion true --contract_recursion_limit 1
</code></p>
<p>(-optimisticFallback)=</p>
<h3><a id="optimistic_fallback"></a><code>--optimistic_fallback</code></h3>
<p>This option determines whether to optimistically assume unresolved external
calls with an empty input buffer (length 0) <em>cannot</em> make arbitrary changes to all states. It makes changes to how
{ref}<code>AUTO summaries &lt;auto-summary&gt;</code> are executed. By default unresolved external
calls with an empty input buffer will {term}<code>havoc</code> all the storage state of external contracts. When
<code>--optimistic_fallback</code> is enabled, the call will either execute the fallback function in the specified contract, revert, or execute a transfer. It will not havoc any state.</p>
<h2>Options for controlling contract creation</h2>
<p>(--dynamic_bound)=</p>
<h3><a id="dynamic_bound"></a><code>--dynamic_bound &lt;n&gt;</code></h3>
<p><strong>What does it do?</strong>
If set to zero (the default), contract creation (via the <code>new</code> statement or the <code>create</code>/<code>create2</code> instructions) will result in a havoc, like any other unresolved external call. If non-zero, then dynamic contract creation will be modeled with cloning, where each contract will be cloned at most n times.</p>
<p><strong>When to use it?</strong>
When you wish to model contract creation, that is, simulating the actual creation of the contract. Without it, <code>create</code> and <code>create2</code> commands simply return a fresh address; the Prover does not model their storage, code, constructors, immutables, etc. Any interaction with these generated addresses is modeled imprecisely with conservative havoc.</p>
<p><strong>Example</strong>
Suppose a contract <code>C</code> creates a new instance of a contract <code>Foo</code>, and you wish to inline the constructor of <code>Foo</code> at the creation site.
<code>certoraRun C.sol Foo.sol --dynamic_bound 1</code></p>
<h3><a id="dynamic_dispatch"></a><code>--dynamic_dispatch</code></h3>
<p><strong>What does it do?</strong>
If false (the default), then all contract method invocations on newly created instances will be unresolved. The user must explicitly write {ref}<code>`DISPATCHER` &lt;dispatcher&gt;</code> summaries for all methods called on newly created instances.
If true, the Prover will, on a best-effort basis, automatically apply the <code>DISPATCHER</code> summary for call sites that must be with a newly created contract as a receiver.</p>
<p>Importantly, this option is only applicable to cases where the Prover can prove that the callee is a created contract. For example, in the below example, the <code>bar</code> function will be unresolved:
<code>solidity
MyFoo f;
if(*) {
   f = new MyFoo(...);
} else {
  f = storageStruct.myFoo;
}
f.bar();
</code></p>
<p><strong>When to use it?</strong>
When you prefer not to add explicit <code>DISPATCHER</code> summaries to methods invoked by the created contract.</p>
<p><strong>Example</strong>
Suppose a contract <code>C</code> creates a new instance of a contract <code>Foo</code>, and you wish to inline the constructor of <code>Foo</code> at the creation site,
and <code>Foo</code> calls some method <code>m()</code> which you wish to automatically link to the newly created contract.
Note that you must add a <code>--dynamic_bound</code> argument as well.
<code>certoraRun C.sol Foo.sol --dynamic_bound 1 --dynamic_dispatch true</code></p>
<h3><a id="prototype"></a><code>--prototype &lt;hex string&gt;=&lt;contract&gt;</code></h3>
<p><strong>What does it do?</strong>
Instructs the Prover to use a specific contract type for the return value from a call to <code>create</code> or <code>create2</code> on the given hexadecimal string as a prefix. The hexadecimal string represents proxy code that forwards calls to another contract. As we are using the prototype flag to skip calls to the proxy, no constructor code is being simulated for these contract creation resolutions.</p>
<p><strong>When to use it?</strong>
If you are verifying a contract creation that uses low level calls to <code>create</code> or <code>create2</code> for contract creation.</p>
<p><strong>Example</strong>
Suppose you have a contract <code>C</code> that creates another contract <code>Foo</code> like this:
<code>solidity
assembly {
     let ptr := mload(0x40)
     mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
     mstore(add(ptr, 0x14), shl(0x60, implementation))
     mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
     instance := create(0, ptr, 0x37)
}
</code>
Then you can set the string <code>3d602d80600a3d3981f3363d3d373d3d3d363d73</code> appearing in the first <code>mstore</code> after the <code>0x</code> prefix as a "prototype" for <code>Foo</code>.
The Prover will then be able to create a new instance of <code>Foo</code> at the point where the code creates it:
<code>certoraRun C.sol Foo.sol --prototype 3d602d80600a3d3981f3363d3d373d3d3d363d73=Foo --dynamic_bound 1</code>
Note: this argument has no effect if the {ref}<code>dynamic bound &lt;--dynamic_bound&gt;</code> is zero.</p>
<p>Also note that the hex string must be:
- a strict prefix of the memory region passed to the create command
- must be unique within each invocation of the tool
- must not contain gaps, e.g., <code>3d602d80600a3d3981f3363d3d373d3d3d363d730000</code> in the above example will not work (those last four bytes will be overwritten) but <code>3d602d80600a3d3981f3363d3d373d3d3d363d</code> will</p>
<h2>Version options</h2>
<h3><a id="version"></a><code>--version</code></h3>
<p><strong>What does it do?</strong>
Shows the version of the local installation of the tool you have.</p>
<p><strong>When to use it?</strong>
When you suspect you have an old installation. To install the newest version, use <code>pip install --upgrade certora-cli</code>.
<strong>Example</strong></p>
<p><code>certoraRun --version</code></p>
<h2>Advanced options</h2>
<h3><a id="java_args"></a><code>--java_args</code></h3>
<p><strong>What does it do?</strong></p>
<p>Allows setting configuring the underlying JVM.</p>
<p><strong>When to use it?</strong></p>
<p>Upon instruction from the Certora team.</p>
<p><strong>Example</strong></p>
<p><code>--java_args '"-Dcvt.default.parallelism=2"'</code> - will set the number of “tasks” that can run in parallel to 2.</p>
<p>(--prover_args)=</p>
<h3><a id="prover_args"></a><code>--prover_args</code></h3>
<p>The <code>--prover_args</code> option allows you to provide fine-grained tuning options to the
Prover.  <code>--prover_args</code> receives a string containing Prover-specific options, and will be sent as-is to the Prover.
<code>--prover_args</code> cannot set Prover options that are set by standalone <code>certoraRun</code> options (e.g. the Prover option <code>--t</code> is
set by <code>--smt_timeout</code> therefore cannot appear in <code>--prover_args</code>). <code>--prover_args</code> value must be quoted</p>
<p>(-optimisticReturnsize)=</p>
<h4><a id="optimisticReturnsize"></a><code>--prover_args '-optimisticReturnsize=true'</code></h4>
<p>This option determines whether {ref}<code>havoc summaries &lt;havoc-summary&gt;</code> assume
that the called method returns the correct number of return values.
It will set the value returned by the <code>RETURNSIZE</code> EVM instruction according to the
called method.
Note that certain conditions should hold in order for the option to take effect.
Namely, if there is a single candidate method in the havoc site,
and all instances of this method in the {term}<code>scene</code> have exactly the same
expected number of return values, then the <code>RETURNSIZE</code> value will be set to
the expected size matching the methods in the scene.
Otherwise, <code>RETURNSIZE</code> will remain non-deterministic.</p>
<p>(-superOptimisticReturnsize)=</p>
<h4><a id="superOptimisticReturnsize"></a><code>--prover_args '-superOptimisticReturnsize=true'</code></h4>
<p>This option determines whether {ref}<code>havoc summaries &lt;havoc-summary&gt;</code> assume
that the called method returns the correct number of return values.
It will set the value returned by the <code>RETURNSIZE</code> EVM instruction
to the size of the output buffer as specified by the summarized <code>CALL</code> instruction.</p>
<p>(--precise<em>bitwise</em>ops)=</p>
<h4><a id="precise_bitwise_ops"></a><code>--precise_bitwise_ops</code></h4>
<p>This option models bitwise operations exactly instead of using the default
{term}<code>overapproximation</code>s. It is useful when the Prover reports a
counterexample caused by incorrect modeling of bitwise operations, but can
dramatically increase the time taken for verification.</p>
<p>The disadvantage of this encoding is that it does not model <code>mathint</code>
precisely: the maximum supported integer value is :math:<code>2^256-1</code> in this case,
effectively restricting a <code>mathint</code> to a <code>uint256</code>. We currently do not have a
setting or encoding that models precisely both bitwise operations and <code>mathint</code>.</p>
<p>(-smt_groundQuantifiers)=</p>
<h4><a id="smt_groundQuantifiers"></a><code>--prover_args -smt_groundQuantifiers=false</code></h4>
<p>This option disables quantifier grounding.  See {ref}<code>grounding</code> for more
information.</p>
<p>(-maxNumberOfReachChecksBasedOnDomination)=</p>
<h4><a id="maxNumberOfReachChecksBasedOnDomination"></a><code>--prover_args '-maxNumberOfReachChecksBasedOnDomination &lt;n&gt;'</code></h4>
<p>This option sets the number of program points to test with the <code>deepSanity</code>
built-in rule.  See {ref}<code>built-in-deep-sanity</code>.</p>
<p>(-enableStorageSplitting)=</p>
<h4><a id="enableStorageSplitting"></a><code>--prover_args '-enableStorageSplitting false'</code></h4>
<p>This option disables the storage splitting optimization.</p>
<p>(--allow<em>solidity</em>calls<em>in</em>quantifiers)=</p>
<h3><a id="allow_solidity_calls_in_quantifiers"></a><code>--allow_solidity_calls_in_quantifiers</code></h3>
<p><strong>What does it do?</strong></p>
<p>Instructs the Prover to permit contract method calls in quantified expression
bodies.</p>
<p><strong>When to use it?</strong></p>
<p>Upon instruction from the Certora team.</p>
<p><strong>Example</strong></p>
<p><code>--allow_solidity_calls_in_quantifiers</code> instructs the Prover to not generate an
error on encountering contract method calls in quantified expression bodies.</p>
<p>(control-flow-splitting-options)=</p>
<h2>Control flow splitting options</h2>
<p>See <a href="control-flow-splitting">here</a> for an explanation of control flow splitting.</p>
<p>(-depth)=</p>
<h3><a id="depth"></a><code>--prover_args '-depth &lt;number&gt;'</code></h3>
<p><strong>What does it do?</strong></p>
<p>Sets the maximum splitting depth.</p>
<p><strong>When to use it?</strong></p>
<p>When the deepest {term}<code>split</code>s are too heavy to solve, but not too high in
number, increasing this will lead to smaller, but more numerous
{term}<code>split leaves</code>, which run at the full SMT timeout (as set by
{ref}<code>--smt_timeout</code>).
Conversely, if run time is too high because there are too many splits,
decreasing this number means that more time is spent on fewer, but bigger split
leaves.
The default value for this option is 10.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-depth 5'
</code></p>
<p>(-mediumTimeout)=</p>
<h3><a id="mediumTimeout"></a><code>--prover_args '-mediumTimeout &lt;seconds&gt;'</code></h3>
<p>The "medium timeout" determines how much time the SMT solver gets for checking a
{term}<code>split</code> that is not a {term}<code>split leaf</code>.
(For split leaves, the full {ref}<code>--smt_timeout</code> is used.)</p>
<p><strong>What does it do?</strong></p>
<p>Sets the time that non-leaf splits get before being split again.</p>
<p><strong>When to use it?</strong></p>
<p>When a little more time can close some splitting subtrees early, this can save a
lot of time, since the subtree's size is exponential in the remaining depth. On
the other hand, if something will be split further anyway, this can save the
run time spent on intermediate "TIMEOUT" results. Use
{ref}<code>-smt_initialSplitDepth</code> to eliminate that time investment altogether up to
a given depth.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-mediumTimeout 20'
</code></p>
<p>(-dontStopAtFirstSplitTimeout)=</p>
<h3><a id="dontStopAtFirstSplitTimeout"></a><code>--prover_args '-dontStopAtFirstSplitTimeout &lt;true/false&gt;'</code></h3>
<p><strong>What does it do?</strong></p>
<p>We can tell the Certora Prover to continue even when the a {term}<code>split</code> has had
a maximum-depth timeout. Note that this is only useful when there exists a
{term}<code>counterexample</code> for the rule under verification, since in order to prove
the absence of counterexamples (i.e. correctness), all splits need to be
counterexample-free. (In case of a rule using <code>satisfy</code> rather than <code>assert</code>,
the corresponding statements hold for {term}<code>witness example</code>s. In that case,
this option is only useful if the rule is correct.)</p>
<p><strong>When to use it?</strong></p>
<p>When looking for a SAT result and observing an <a href="timeouts-introduction">SMT-type timeout</a>.
The default value for this option is <code>false</code>.</p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-dontStopAtFirstSplitTimeout true'
</code></p>
<p>(-smt_initialSplitDepth)=</p>
<h3><a id="smt_initialSplitDepth"></a><code>--prover_args '-smt_initialSplitDepth &lt;number&gt;'</code></h3>
<p>With this option, the splitting can be configured to skip the SMT solver-based checks
at low splitting levels, thus generating sub-{term}<code>split</code>s up to a given depth immediately.</p>
<p><strong>What does it do?</strong></p>
<p>The first <code>&lt;number&gt;</code> split levels are not checked with the SMT solver, but rather
split immediately.</p>
<p><strong>When to use it?</strong></p>
<p>When there is a lot of overhead induced by processing and trying to solve splits
that are very hard, and thus run into a timeout anyway.</p>
<p><code>{note} The number of
splits generated here is equal to `2^n` where `n` is the initial splitting depth
(assuming the program has enough branching points, which is usually the case);
thus, low numbers are advisable. For instance setting this to 5 means that the
Prover will immediately produce 32 splits.
</code></p>
<p><code>{note}
The {ref}`-depth` setting has precedence over this setting. I.e., if `-depth`
is set to a lower value than `-smt_initialSplitDepth`, the initial splitting
will only proceed up to the splitting depth given via `-depth`.
</code></p>
<p><strong>Example</strong></p>
<p><code>sh
certoraRun Bank.sol --verify Bank:bank.spec --prover_args '-smt_initialSplitDepth 3'
</code></p>
</body></html>