<p>(verification-report)=</p>
<h1>Certora Verification Reports</h1>
<p>```{toctree}</p>
<p>storage-in-calltrace.md
```</p>
<h2>Understanding counter-examples</h2>
<p>There could be many reasons for false counterexamples, but here are a few common ones.</p>
<p>A counterexample that looks fishy does not rule out a potential bug that the rule can uncover.</p>
<ol>
<li><p><strong>External call havocs.</strong> Look for warnings in the Call Resolution table - this could indicate <em>havocs</em>. Havocs are a common cause of counterexamples that seem to come out of nowhere!</p></li>
<li><p><strong>Links are not applied as expected.</strong> Note that if you use <code>--link</code> to link, you may sometimes need to require that the field is equal to the linked-to contract's address within the rule itself. (Dispatcher links do not have this issue.)</p></li>
<li><p><strong>Bitwise operations.</strong> By default, the tool will overapproximate bitwise
operations applied in a non-standard way (xor, or, and non 2^n-1 masks for
and). Try to look over the dump and look for red-background lines.  You may
be able to solve these by passing the <code>--prover_arsg -useBitVectorTheory</code> option
on the command line</p></li>
<li><p><strong>Aliasing.</strong> Be on the lookout if your environment’s <code>msg.sender</code> is the same as <code>currentContract</code> or any linked contract. The tool should report these more clearly but read the call trace carefully. Also, note trivial assignments like 0.</p></li>
<li><p><strong>Correct storage modeling.</strong> Suppose you have a rule that calls some getter, then you call a function that’s expected to affect the results of that getter, but in the counterexample it stays the same. It could be that the code invoked is not reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function.</p></li>
</ol>
<html><head><meta content="https://github.com/Certora/Documentation/blob/master/prover/portal/report.md" name="url"/><meta content="No Title Found" name="title"/><meta content="(verification-report)=
Certora Verification Reports
```{toctree}
storage-in-calltrace.md
```
Understanding counter-examples
There could be many reasons for false counterexamples, but here are a few co" name="text"/></head><body><p>(verification-report)=</p>
<h1>Certora Verification Reports</h1>
<p>```{toctree}</p>
<p>storage-in-calltrace.md
```</p>
<h2>Understanding counter-examples</h2>
<p>There could be many reasons for false counterexamples, but here are a few common ones.</p>
<p>A counterexample that looks fishy does not rule out a potential bug that the rule can uncover.</p>
<ol>
<li><p><strong>External call havocs.</strong> Look for warnings in the Call Resolution table - this could indicate <em>havocs</em>. Havocs are a common cause of counterexamples that seem to come out of nowhere!</p></li>
<li><p><strong>Links are not applied as expected.</strong> Note that if you use <code>--link</code> to link, you may sometimes need to require that the field is equal to the linked-to contract's address within the rule itself. (Dispatcher links do not have this issue.)</p></li>
<li><p><strong>Bitwise operations.</strong> By default, the tool will overapproximate bitwise
operations applied in a non-standard way (xor, or, and non 2^n-1 masks for
and). Try to look over the dump and look for red-background lines.  You may
be able to solve these by passing the <code>--prover_arsg -useBitVectorTheory</code> option
on the command line</p></li>
<li><p><strong>Aliasing.</strong> Be on the lookout if your environment’s <code>msg.sender</code> is the same as <code>currentContract</code> or any linked contract. The tool should report these more clearly but read the call trace carefully. Also, note trivial assignments like 0.</p></li>
<li><p><strong>Correct storage modeling.</strong> Suppose you have a rule that calls some getter, then you call a function that’s expected to affect the results of that getter, but in the counterexample it stays the same. It could be that the code invoked is not reaching the expected write to the relevant storage slot, or it computed the slot’s address differently. The deepest level in the call trace for stores and loads will show the actual number used for the slot’s address, so you can find-in-page the slot number from the getter and see if you find any match for it inside the function.</p></li>
</ol>
</body></html>